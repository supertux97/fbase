\documentclass{report}
\input{sml.tex}
\title{Funksjonell programmering gjennom utvikling av et sp\o rrespr\aa k}
\author{Erlend \O
stlie}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{changepage}

\usepackage[backend=biber,sorting=none]{biblatex}
\addbibresource{refs.bib}

\usepackage{url}
\definecolor{lightGray}{rgb}{0.90, 0.90, 0.90}

\usepackage[a4paper, total={6in, 8in}]{geometry}
\usepackage{graphicx}
\usepackage{minitoc}
\usepackage{minted}
\usepackage{geometry}
\usepackage{float}
\usepackage{color, colortbl}
\usepackage{parskip}
\usepackage[norsk]{babel}
\usepackage[font=small,skip=5pt]{caption}
\newcommand*{\escape}[1]{\texttt{\textbackslash#1}}
\usepackage[format=plain,
            labelfont={it},
            textfont=it]{caption}
\captionsetup{justification=raggedright,singlelinecheck=false}
\date{\today}
\newcommand{\qq}{\symbol{34}}
\def \tabX {20pt}
\def \tabY {0pt}
\newcommand{\tab}[1]{
	\begin{adjustwidth}{\tabX}{\tabY}
	#1
	\end{adjustwidth}
}
\newcommand{\keyword}[1]{\colorbox{lightGray}{#1}}

\begin{document}

\maketitle
\dominitoc
\tableofcontents 

\addcontentsline{toc}{chapter}{\protect\numberline{}Introduksjon}%
\chapter*{Introduksjon}
Funksjonell programmering har tradisjonelt vært forbeholdt akademia og spesielt interesserte. Paradigmet har eksistert i form av programmeringsspråk siden IPL ble lansert i 1956 og Lisp i 1958, men har igjennom historien aldri fått den store oppslutningen. Den siste tiden har man likevel kunnet  se tendenser til at funksjonelle språk får større fotfeste, også i programvareindustrien. Eksempelvis benytter Facebook det funksjonelle språket Haskell til filtrering av spam \cite{facebook_haskell}, mens Whatsapp bruker Erlang, et språk med stort fokus på parallellitet, men som kan regnes som et  funksjonelt programmeringsspråk, til store deler av backenden \cite{whatsapp_erlang}. Man kan også se at en rekke ikke-funksjonelle språk låner egenskaper og teknikker fra funksjonell programmering. Eksempler på slike språk er Rust, C\# og Java.
S
Denne oppgaven har satt seg mål om å få kunnskap og erfaring fra funksjonell programmering ved å utvikle et spørrespråk. Spørrespråket skal kunne  hente ut og  transformere lagret data. Oppgaven har også implementert  logikk for å evaluere uttrykk, men det ble ikke tid til å integrere dette i spørrespråket. Det funksjonelle språket Standard ML (heretter også SML) skal benyttes. Utviklingen av spørrespråket er ment å fungere som en arena der  teknikker fra funksjonell programmering kan testes i praksis. Siden dette systemet også er av en større skala kan man få erfaring med hvordan et funksjonelt språk skalerer og hvordan man kan skape struktur i koden. Funksjonell programmering kan være interessant å benytte til denne type prosjekt siden et spørrespråk er avhengig av store mengder data-transformasjoner bak kulissene. Et funksjonelt språk vil potensielt kunne være godt egnet til dette. Dessuten vil store deler av oppgaven omhandle tolkning av spørringer, lagret data og metadata. Dette er en oppgave som  også potensielt passer godt for funksjonell programmering.  For å gjøre systemet fleksibelt og enkelt å vedlikeholde er det i tillegg avhengig av store deler abstraksjon, noe som også blir tilbudt i stor grad innen denne programmeringsstilen. Denne oppgaven skal tar for seg ulike funksjonelle teknikker og egenskaper, både fra et teoretisk perspektiv, men også i mer praktisk kontekst i forhold til utvikling av databasen. Målet er å undersøke hvordan de ulike funksjonelle teknikkene og egenskapene virker inn på utviklingen av et spørrespråk.

Oppgaven gikk i utgangspunktet ut på å utvikle et komplett spørrespråk, men har i senere tid blitt begrenset til uthenting av data gjennom operasjonene \textit{from,merge og output}, i tillegg til kode for å tolke matematiske uttrykk. Syntaksen til spørrespråket blir beskrevet i kapittel 2.

\chapter{Funskjonell Progammering}
\section{Hva er funksjonell programmering?}
Funksjonell programmering er et programmeringsparadigme. Et programmeringsparadigme kan defineres på ulike måter, men én definisjon er at det er stil eller måte koden blir skrevet på og organisert på. Det er viktig å legge vekt på at funksjonell programmering kun er en stil, og at denne stilen ikke er begrenset til en bestemt gruppe med språk. Likevel snakker man gjerne om funksjonelle språk, og da vil dette være språk som er designet for å programmere i den funksjonelle stilen. Likevel er det fullt mulig å bedrive funksjonell programmering i språk ikke regnes som funksjonelle, slik som C, men opplevelsen vil ofte bli bedre dersom man benytter språk spesielt laget for funksjonell programmering. Eksempler på slike språk er Standard ML, Haskell og Scala. 

Imperativ programmering og paradigmets populære underkategorier objektorientert og prosedyrisk programmering er de dominerende paradigmene i dag. En abstrakt definisjon på forskjellen mellom det imperative og det funksjonelle paradigmet kan være at det imperative er basert på turingmaskinen, mens det funksjonelle er basert på lambda-kalkylen. Denne forskjellen gjør funksjonell programmering til et på mange måter grunnleggende annerledes paradigme - i det funksjonelle paradigmet skapes resultatene ved å la dataen flyte og transformeres gjennom funksjoner(funksjoner i matematisk forstand), fremfor at  tilstanden til programmet stegvis blir mutert inntil resultatet er skapt. At man unngår å endre tilstanden til programmet er en essensiell og karakteristisk egenskap ved funksjonell programmering, og rapporten vil komme tilbake til hvilke implikasjoner dette vil ha på koden og på utviklingsprosessen. Funksjonell programmering regnes i tillegg som en underkategori av deklarativ programmering, noe rapporten også vil nevne. Paradigmet sin deklarative natur og det faktum at man unngår mutering, baner i tillegg vei for rekursjon, som også vil bli drøftet. Sist vil rapporten se på hvordan funksjonell programmering fungerer i større skala, med tanke på gjenbruk og abstraksjon, utvidbarhet og organisering av koden. Hensikten med rapporten er å se hvordan de ulike aspektene til funksjonell programmering kommer til uttrykk i praktisk programvareutvikling, og i dette tilfellet, utvikling av et spørrespråk for en database.\\

\section{Uforanderlighet og rene funksjoner}
Mest sannsynlig er uforanderlighet den mest definerende egenskapen med funksjonell programmering. Prinsippet går ut på at man ikke har variabler, kun konstanter. Rene funksjoner kan sies å være en konsekvens av uforanderlighet og går ut på at en funksjon må være skrevet som en matematisk funksjon: Som en direkte og absolutt kopling mellom input og output. Funksjonen produserer en verdi, og gjør ikke noe annet. Selv om prinsippene bak uforanderlighet og rene funksjoner er enkle, har det store konsekvenser for hvordan kode blir skrevet og hvilke teknikker som blir brukt i koden.  Objekter i tradisjonell forstand, tradisjonelle løkker og statements blir utelukket til fordel for andre teknikker. Denne seksjonen skal diskutere effektene man får som følge av uforanderlighet.

\section{Uforanderlighet}
Funksjonell programmering kan sies å ha en grunnleggere annerledes modell for hva et program/en algoritme er, i forhold til imperativ programmering. I imperativ programmering er en algoritme vanligvis en samling av statements og variabeldeklarasjoner. Når algoritmen kjører blir variablene mutert inntil programmet er ferdig og det ønskede resultatet er produsert. Hvis man bestemmer seg for å stoppe å bruke variabler, men heller kun konstanter, vil man høyest sannsynlig måtte endre måten man skriver koden på. Derfor kommer også et behov for nye teknikker inn. Løkker blir for eksempel erstattet av rekursjon, mens funksjoner for å endre en struktur vil returnere en ny struktur fremfor å endre den som ble sendt inn som parameter. I funksjonell programmering kan man se på en algoritme som ett enkelt uttrykk som blir evaluert. Uttrykket kan godt ha mange del-uttrykk og benytte funksjoner for å abstrahere bort deler av koden, men det er fortsatt ett enkelt uttrykk. Den funksjonelle stilen gjør det derfor nødvendig å utvikle kode på en ulik måte enn tilfellet er i imperativ programmering. Resten av dette kapitlet går nærmere inn på hvordan dette kan fungere i praksis. Kapittel 3 {\qq}\ref{chap:inplementation}{\qq} eksemplifiserer den funksjonelle stilen i en større skala. 

Den imperative modellen er for mange naturlig å bruke fordi den etterlikner den virkelige verden. Likevel kan variabler sies å skape voldsomt mye problemer, blant annet knyttet til hvordan man forstår koden. Kodeforståelse er kritisk når man kommer over en kodebit andre har skrevet eller når man driver med feilsøking. I den imperative modellen må man holde styr på tilstanden til programmet til en hver tid og legge merke til alle endringene av variablene. Man må ofte skape seg et mentalt bilde av tilstanden til en rekke objekter, tellervariabler i løkker og globale variabler.  Denne oversikten blir enda mer utfordrende å skaffe seg når dataen blir brukt av ulike deler av programmet og til og med kanskje av flere tråder. Forskning fra 2001 tyder på at mennesket som regel kun kan ha 4 ting i arbeidsminnet samtidig \cite{forskningArbeidsminne}. Dette betyr at utviklerne ofte ikke kan ha hele oversikten i holdet samtidig. Når man mislykkes å forstå virkemåten til programmet, er faren for bugs høyst tilstedeværende. Også feilsøking blir mer krevende av samme grunn. Med konstanter fremfor variabler trenger man ikke holde styr på programmets tilstand, siden den ikke kan endres. Man kan derfor argumentere for at forståelse av koden og feilsøking blir enklere ved å bruke konstanter fremfor variabler. Eksempel på en algoritme løst med og uten tradisjonelle variabler finnes i figur \ref{fig:fibImperative} og \ref{fig:fibConstant}. Her er Java benyttet i begge tilfellene for å understreke at uforanderlighet også kan benyttes i språk som tradisjonelt regnes som imperative.
\begin{figure}[H]
\caption{Funksjon for å regne ut det n-te Fibonacci-tallet (Java)}
\label{fig:fibImperative}
\begin{minted}{java}
public static int fibVar(int n){
        int prev,curr;
        prev = curr = 1;

        if(n <= 1) return 1;

        for(int no = 3; no <= n; no++){
            int tmp = curr;
            curr += prev;
            prev = tmp;
        }

        return curr;
    }
\end{minted}
\end{figure}
\textit{Funksjonen finner det n-te Fibonacci-tallet ved å holde styr på gjeldende og forrige Fibonacci-tall og oppdatere de for hver iterasjon av løkken.}

\begin{figure}[H]
\caption{Funksjon for å regne ut det n-te Fibonacci-tallet, uten variabler (Java)}
\label{fig:fibConstant}
\begin{minted}{java}
 public static int fibNoVar(int n){
        if(n <= 1) return 1;
        
        return fib(n -1) + fib(n-2);
    }
\end{minted}
\end{figure}
\textit{Funksjonen finner det n-te Fibonacci-tallet ved å definere fib av n <= 1 som 1 og fib av et hvilket som helst annet tall som den rekursive løsningen av det forrige Fibonacci-tallet og det forrige-forrige Fibonacci-tallet. Funksjonen bruker ikke mutering men gir en ny verdi til n ved å subtrahere verdien når funksjonen kalles rekursivt.}

Hvis man sammenlikner de to funksjonene kan man se at den første funksjonen har flere bevegelige deler, i form av variabler. Flere bevegelige deler betyr mer informasjon å holde i arbeidsminnet for utvikleren. Muligheten for å gjøre feil vil derfor kunne bli større. Spesielt i forhold til feilsøking kan den første varianten være mer krevende. På tross av en stil som kanskje fører til mindre å holde styr på for utvikleren, foretrekker mange å programmere i den imperative stilen siden den definerer stegene mer eksplisitt enn det den funksjonelle gjør.

\subsection{Rene funksjoner}
Rene funksjoner er som nevnt tidligere funksjoner som kun kopler input til output, og ikke noe mer. Dette faktumet innebærer også at en ren funksjon ikke har side-effekter, altså at den ikke påvirker \textit{verdenen} utenfor funksjonen. Man finner derfor ikke noe helt tilsvarende det man kaller \textit{void} i Java og C\# i rene funksjonelle språk. Side-effekter innebærer mutering av variabler eller parametre, men også IO-operasjoner slik som å skrive ut i konsollen og å skrive til en fil eller en database. I tillegg vil naturligvis også handlingen å kalle på urene funksjoner gjøre funksjonen som kaller uren. Siden en ren funksjon ikke kan avhenge av ekstern kontekst vil den rene funksjonen alltid produsere samme svar med en bestemt input, uavhengig av programmets tilstand. Effekten av dette er at man kan  bytte ut funksjonskallet med verdien det produserer uten å endre programmets virkemåte. Dette prinsippet kalles ofte \textit{referential-transparency}. På bakgrunn av de nevnte egenskapene vil  rene funksjoner fungere som isolerte enheter. Det vil derfor være enkelt å flytte eller bytte ut rene funksjoner, og de kan dessuten testes isolert. Det siste poenget vil kunne være tidsbesparende da man ofte må emulere en programtilstand når testing skal gjennomføres i mer komplekse programmer. I tillegg vil kodeforståelsen og dermed også feilsøkingen i følge D. Turner et. al(2001) kunne bli enklere med rene funksjoner siden man ikke trenger å ha kunnskap om programmets kontekst og hva som har blitt utført tidligere\cite{pureFunctions}. Det skal legges til at et program helt uten sideeffekter i praksis er et program uten nytteverdi. Det er derfor nødvendig å ty til visse sideeffekter og dermed ende opp med et lite antall urene funksjoner, men man ønsker da å isolere bruken. Enkelte språk, slik som Haskell og Elm benytter dessuten et konsept kalt monader for å løse samhandling med \textit{verdenen på utsiden} på en funksjonell måte.

\subsection{Parallell kjøring og flertrådede programmer}
Nå som prosessorer leveres med stadig flere kjerner blir det mer viktig å utnytte så mange av de som mulig for å oppnå god ytelse. Korrekt håndtering av tråder og parallellisering regnes av mange som en utfordrende aktivitet innen programvareutvikling. Noe av det som gjør aktiviteten ekstra utfordrende er når flere tråder deler på samme data, og dataen har mulighet til å bli endret. Eksempel på en slik situasjon: En tråd tester først integriteten til et objekt og utfører deretter arbeid på objektet, dersom det er gyldig. Situasjonen der en tråd endrer objektet og gjør det ugyldig etter at gyldigheten har blitt kontrollert, kan skape problemer. Løsningen på denne utfordringen er ofte ulike låsemekanismer eller ulike former for synkronisering. I funksjonell programmering forsvinner mange av utfordringene knyttet til flertråds- og parallell kjøring på grunn av uforanderlighet.

I et imperativt språk er det fullt mulig å utviklet et program der dataen som deles mellom trådene er uforanderlig. På denne måten vil mange av utfordringene knyttet til flertrådkjøring forsvinne. Likevel vil dette være enklere i et funksjonelt språk siden dataen der er uforanderlig som standard. I et funksjonelt språk kan dataen fritt deles mellom et vilkårlig antall tråder og man vil ikke måtte bekymre seg for om en av trådene endrer dataen på et uønsket tidspunkt. Gyldigheten til dataen trenger bare å testes én gang; er den gyldig i den første testen vil den alltid være gyldig. På denne måten vil hyppige gyldighetstester, låsemekanismer og synkronisering i mange tilfeller bli overflødig. Låsemekanismer der en tråd venter på at en annen skal endre dataen, som avhenger av et tidsavbrudd vil også bli mindre relevant. Tidsavbrudd for tråder som produserer data vil likevel være aktuelt i noen tilfeller. 

Også parallell kjøring- der en algoritme sitt arbeid blir delt opp og de ulike delene utført separat, vil være mye enklere å håndtere i et funksjonelt språk. Igjen sørger uforanderligheten for at en av trådene ikke kan endre dataen de andre trådene arbeider med, noe som betyr at jobben til de ulike trådene vil bli utført på en isolert måte. Eksempler der parallellisering vil kunne bli brukt og som vil ta stor nytte av uforanderlighet er f.eks i merge- eller quicksort.

\section{Rekursive funksjoner og deklarativ programmering}
\label{sec:rec}
\subsection{Hva er rekursjon?}
På et abstrakt nivå er noe rekursivt dersom navnet til det som blir definert er en del av selve definisjonen \cite{elements_of_func}. Av dette kan man tyde at rekursjon ikke nødvendigvis er koplet opp mot funksjoner, men denne rapporten vil konsentrere seg om rekursive funksjonsdefinisjoner. Rekursive funksjoner går ut på at en funksjon kaller seg selv, noe som innebærer at funksjonen bruker seg selv som et steg på veien til løsningen av et problem. I noen tilfeller vil rekursjonen ha semantikk og oppførsel med likhetstrekk til konvensjonelle løkker, men i andre tilfeller vil rekursjonens virkemåte være grunnleggende annerledes. Spesielt i det siste tilfellet kan man argumentere for at rekursjon lar deg løse problemer på en mye mer elegant måte enn tilfellet hadde vært uten rekursjon. Rapporten kommer tilbake til dette senere. Deklarativ programmering er et annet tema som er tett knyttet opp mot funksjonell programmering og også på noen måter, rekursjon. Denne seksjonen skal ta for seg begge prinsippene og hvordan de relaterer til funksjonell programmering.\\

Rekursjon er en teknikk som er tilgjengelig i så godt som alle moderne programmeringsspråk. Grunnen er at de fleste språk bruker en kall-stack for funksjonskall og at det i prinsipp ikke spiller noen rolle hvilken funksjon som blir kalt på. En funksjon som kaller seg vil det derfor bli behandlet som et hvilket som helst funksjonskall. På tross av den nesten universelle tilgjengeligheten blir teknikken ofte mye mer brukt i forbindelse med funksjonell programmering enn det den gjør i imperativ. Årsakene til dette er flere men blant annet er rekursjon enste mulighet i enkelte språk til å gjenta kode på en organisert måte(som en form for løkke) i tillegg til at rekursjon er et uvurderlig verktøy i den funksjonelle verktøykassen når det kommer til å skrive programmer i funksjonell stil. Rekursjon og funksjonell programmering går på mange måter hånd i hånd.
\subsection*{Hvorfor rekursjon i funksjonell programmering?}
En måte å angripe problemet på er å heller spørre: Hvorfor ikke løkker i funksjonell programmering? Mange av grunnene til dette kommer fra løkkenes natur og virkemåte. En løkke består som regel av en kodeblokk og en betingelse som sjekkes for hver gang kodeblokken eventuelt blir gjentatt. For at løkken ikke skal bli gjentatt ut i det uendelige er det gitt at uttrykket i betingelsen må endres. Eneste muligheten for dette er enten at uttrykket aldri er sant, at det er et ikke-deterministisk funksjonskall (f.eks. en randomfunskjon), et uttrykk som avhenger av eksterne kilder, eller mer vanlig, at en eller flere variabler muteres inne i kodeblokken. De fleste språkene har også en løkkevariant der initialisering og mutering av teller/løkkevariabler og løkke-betingelsen er kombinert. Uansett varianten vil løkken i de fleste tilfeller være avhengig av mutering i en eller annen form for å ta slutt, men også for å få gjort nyttig arbeid inne i selve løkkekroppen. Løkkenes muterende natur medfører at løkker strider mot grunnleggende prinsipper i funksjonell programmering omtalt i kapitlet {\qq}Konstanter fremfor variabler{\qq}. Alternativet til løkker i funksjonelle språk er ofte funksjoner av høyere orden eller rekursjon. Det må også legges til at mange moderne språk tilbyr iterator-baserte løkker, f.eks. ved bruk av \textit{for(Type navn: liste) }i Java, som er mer funksjonelle i natur.
\subsection{Fordeler og ulemper}
\subsubsection*{Lesbarhet og semantikk}
Denne seksjonen skal ta for seg en algoritme for å skrive ut en tekstlig representasjon av et binært tre i både funksjonell og imperativ stil, for deretter å sammenlikne semantikk og lesbarhet til kodesnuttene.

\begin{figure}[H]
\caption{Funksjon for å lage en tekstlig versjon av et tre (Standard ML)}
\label{fig:treeToStrSML}
\begin{minted}{sml}
 fun treeToStr(exprTree: ExprTree) = 
     case exprTree of
         Node(left,value,right) =>  
           Util.format("Tree( Val:$ L:$ R:$ )", 
             [getValue(value), exprTreeToStr(left),exprTreeToStr(right)])
        |EmptyNode => ""
        |treeLit(lit) => getValue(lit) 
\end{minted}
\end{figure}
\textit{Funksjonen bruker preorder-traverering til å rekursivt lage en tekstlig representasjon av et tre. Util.format er en funksjon for tekstformatering, på samme måte som System.out.printf i Java der dollartegnet i Util.format er analogt til \%s i Java-varianten. Denne funksjonen benyttes til feilsøking i databasen for å skrive ut uttrykks-trær. Eksempelvis vil uttrykket 1+2+3 få denne tekstlig reprsetntasjonen:Tree( Val:+ L:1.0 R:Tree( Val:+ L:2.0 R:3.0 ) ).
}

\begin{figure}[H]
\caption{Funksjon for å lage en tekstlig versjon av et tre (Java)}
\begin{minted}{java}
   public static String treeToStr (Tree treeRoot){
        Stack<Tree> treeStack = new Stack<>();
        treeStack.add(treeRoot);

        String str = "";
        while (!treeStack.isEmpty()){
            Tree curr = treeStack.pop();
            if(curr != null){
                str += (String.format("%s (Val: %s ",curr.getType(), curr.value));

                treeStack.push(curr.right);
                treeStack.push(curr.left);
            }
            else{
                str += (")");
            }
        }
        return  str;
    }
\end{minted}
\end{figure}
\textit{Funksjonen bruker en stack for å lage en tekstlig versjon av treet. For hver node legges verdien til noden til i strengen og høyre og venstre tre legges til i stacken. Dette gjentas inntil stacken er tom, noe som indikerer at vi har nådd bunnen av treet. Funksjonen getType henter typen til noden (om noden er en rotnode, venstre- eller høyrenode)}

Hvis man studerer de to kodesnuttene kan man legge merke til at den funksjonelle er mer kompakt med tanke på antall linjer kode, men kanskje mer tydelig: Den angriper problemet på en grunnleggende annerledes måte enn den imperative varianten. I stedet for å eksplisitt definere de ulike stegene i algoritmen, benyttes en mer deklarativ stil. I deklarativ programmering kan utvikleren konsentrere seg om \textit{hva} som skal bli beregnet, uten nødvendigvis å måtte tenke på eller definere \textit{hvordan} dette skal gjøres \cite{declarative_programming}. Sagt på en annen måte- deklarativ programmering innebærer at utvikleren definerer logikken, men ikke programflyten. Dette medfører at elementer som if-setninger, løkker, og nøkkelord som \textit{continue} og \textit{break} ikke benyttes. Både funksjonell programmering og logisk programmering regnes for å tilhøre den deklarative stilen. SQL er kanskje det mest kjente  deklarative programmeringsspråket, selv om dette hverken er funksjonelt eller logisk. Regulæruttrykk, selv om det ikke er et programmeringsspråk men heller et domespesifikt språk, er også et kjent eksempel. I kodesnutten i figur \ref{fig:treeToStrSML} kan man se dette i praksis ved at algoritmen har minimalt med styring av kontrollflyt, men heller definerer {\qq}regler{\qq}  for ulike scenarioer av input. Dessuten vil man enklere kunne få et inntrykk av hvordan den endelige strengen vil kunne se ut, kun ved å se på linjen for strengformateringen. Deklarativ programmering har som effekt at utvikleren opererer på et høyere nivå av abstraksjon. Dette er noe som kan bidra til kode som både er enklere å lese og forstå fordi tekniske implementerings-detaljer blir utelatt. Pattern-macthing er også en mekanisme som kan sies å tilhøre denne stilen, og blir brukt i den funksjonelle versjonen av tre-til-streng algoritmen. Pattern-matching vil bli diskutert i større detalj senere i rapporten. 

Knyttet opp mot rekursjon vil den deklarative stilen innebære at utvikleren ikke trenger å definere hvordan kodeblokkene blir gjentatt(gjennom løkker og logikken som styrer løkken) og at {\qq}stacken{\qq} som håndteres manuelt i den imperative varianten abstraheres bort. Dette vil kunne påvirke lesbarheten betraktelig. Traversering av rekursive datastrukturer som binær- og filtrær er derfor problemer som egner seg godt for rekursjon. Det samme er tilfellet for splitt-og-hersk algoritmer(slik som quicksort). I andre tilfeller er muligens ikke fordelene like åpenbare.\\
\\
På den andre siden kan deklarativ programmering gi utvikleren et mer utydelig inntrykk av hva som faktisk foregår. Dette er fordi den faktiske logikken og programflyten blir gjemt bort under flere lag med abstraksjon. Mulighetene for optimalisering og spesialtilpassing blir også mindre av samme grunn. Et annet aspekt er at høytnivåkonseptene som følger med deklarativ programmering kan være utfordrende å forstå siden mange av begrepene er svært abstrakte og fordi det kan være vanskelig å finne en konkret parallell i den virkelige verden. For eksempel kan en løkke være enklere å forstå enn rekursjon og en imperativ variant som finner summen av elementene i en liste være mer intuitiv enn å bruke \textit{reduce/fold}.\\
\\
Den deklarative stilen i det første eksempelet vil kunne gjøre funksjonen enklere å lese og skrive. Likevel krever den rekursive løsningen at utvikleren har kjennskap til og erfaring med rekursive algoritmer. Uten dette kan rekursive funksjoner være svært krevende å forstå, og ikke minst feilsøke, spesielt rekursjon som ikke er halerekursiv eller rekursjon som er av den multirekursive typen. En av grunnene til dette angår semantikken til koden og måten utvikleren kan få en forståelse for virkemåten til algoritmen. Ved en imperativ variant kan vedkommende gå gjennom algoritmen på en lineær måte og holde styr på tilstanden til programmet. Denne stilen vil for mange være mer naturlig og har også den fordelen at den vil kunne være enklere å feilsøke med en konvensjonell debugger. Den rekursive varianten er mer todimensjonal av natur ved at programflyten ikke bare går nedover, men også innover og oppover. Dette medfører at for å gå gjennom og få en forståelse for algoritmen må man danne seg en mental stack og bevege seg nedover og oppover kalltreet eller eventuelt skrible ned kallstacken på et papir. Det skal sies at dersom man har kjennskap til rekursjon, vil denne oppgaven bli enklere, men det vil fremdeles kreve en viss mental kapasitet når man skal lese og forstå mer komplekse rekursive algoritmer, spesielt når det ikke er deg selv som er forfatteren.\\


\begin{figure}[H]
\caption{Funksjon for å fjerne kommentarer fra kildekode(Standard ML)}
\label{fig:rmComments}
\begin{minted}{sml}
fun rmComments(lines: string list):string list =
  case lines of
      (x::xs) =>
          let
             val substr = strToSs(x)
             val (noComment, comment) = Substring.splitl (fn c => c <> #"#") substr
       in
           ssToStr(noComment) :: rmComments(xs)
       end
    |[] => []
\end{minted}
\end{figure}
\textit{Funksjonen fjerner alle tegn fra og med \#-tegnet for hver streng i listen blir sendt inn. splitl deler opp en streng ved hjelp av en predikatfunksjon som blir kjørt på hvert enkelt tegn. Delen uten kommentarer konkatineres med den rekursive løsningen til resten av lista.}
\label{fig:kalltreRmComments}
\begin{figure}[H]
Strengen som sendes inn: \\
\textit{from Person as P \#P er en alias \\
		filter department = {\qq}IT{\qq} \#Bare datafolkene \\
        output name,salary \#Grunnleggende info \\
        }
 \caption{Kalltre for funksjonen i figur \ref{fig:rmComments}}
\begin{minted}{text}
"from Person as P" :: rmComments("filter department = IT #Bare datafolkene 
        			  output name,salary #Grunnleggende info")
	"filter department = IT" :: rmComments("output name,salary #Grunnleggende info")
    	"output name, salary"

\end{minted}
\end{figure}


\subsection{Effektivitet}
\label{subsec:effektiivitet}
Rekursive funksjoner blir i mange tilfeller foretrukket fremfor løkker i en rekke funksjonelle språk, mens teknikken ofte er reservert til spesielle tilfeller slik som traversering av trær i språk som er mer imperative. En viktig årsak til dette er måten de ulike kompilatorene og interpreterne implementerer rekursjonen, spesifikt om de tilbyr hale-rekursjon-optimalisering eller ikke.


For hvert funksjonskall, inklusive rekursive funksjonskall, opprettes en stackframe som lagres på kallstacken. Inne i hver stackframe lagres blant annet parameterverdier, lokale variabler(ikke i dette tilfellet) og posisjonen i koden det skal fortsettes fra etter at funksjonen har returnert. I figur \ref{fig:kalltreRmComments} kan man se at måten den rekursive funksjonen i figur \ref{fig:rmComments} kjører på medfører at tilstanden til funksjonen(i dette tilfellet strengen før ::) må lagres. Den må lagres slik at strengen kan bli konkatinert på et senere tidspunkt når rekursjonen trekker seg oppover. I dette tilfellet vil man da få laget 3 stackframes før rekursjonen trekker seg opp igjen, noe som vil medføre ekstra  minnebruk og ekstra operasjoner med å legge til og fjerne frames fra kallstacken. Hale-kall optimalisering vil kunne eliminere de nevnte ulempene ved å transformere enkelte former for rekursjon til vanlig iterasjon. Funksjonen for å fjerne kommentarer er et trivielt eksempel som ikke hadde dratt nevneverdig effekt av en slik optimalisering, men hvis rekursjonen hadde vært svært dyp, hadde antallet stackframes blitt svært høyt, noe som potensielt kunne ha fylt opp kallstacken og i verste tilfelle medført en stack-owerflow exception. Dette er i tillegg til at algoritmen blir mer ressurskrevende å kjøre. I seksjon \ref{sec:hastighetestester} demonstreres slik dyp rekursjon der en funksjon testes med 100 000, 1 million og 100 millioner rekursive funksjonskall, med og uten halekall-optimalisering. 
\\


For at en kompilator skal kunne utføre hale-kall-optimalisering må rekursjonen være implementert på en bestemt måte - det kan kun forekomme ett rekursivt kall som må komme helt til sist og det kan ikke akkumuleres verdier rekursivt. Dette innebærer at det rekursive kallet \textit{ssToStr(noComment) :: rmComments(xs)} i figur \ref{fig:rmComments} ikke oppfyller krav nr. 2 og dermed ikke er halerekursivt. Hvis de to egenskapene er oppfylt vil det ikke være noen grunn til å opprette stackframes, siden det ikke vil være noen grunn til å gå tilbake til tidligere rekursive kall. Rapporten går mer i dybden på denne erkjennelsen senere. Kravet om ett rekursivt kall helt til slutt medfører at algoritmer som naturlig implementeres med multi-rekursjon slik som traversering av trær, må bli skrevet om og vil få ganske annerledes logikk. For mer konvensjonell rekursjon er det ofte enklere å refaktorere koden til å være halerekursiv. \\

\begin{figure}[H]
\caption{Funksjon for å fjerne kommentarer fra kildekode, halerekursiv (Standard ML)}
\label{fig:rmCommentsTailrec}
\begin{minted}{sml}
 fun rmCommentsTailrec(inpLines: string list):string list =
   let fun rmTailRec(inpLines:string list, result:string list) = 
    case inpLines of
      (x::xs) =>
     let 
        val substr = Util.strToSs(x)
        val (noComment, comment) = Substring.splitl (fn c => c <> #"#") substr
      in  
        rmTailRec(xs, Util.ssToStr(noComment) :: result)
      end 
      |[] => rev(result)
    in
      rmTailRec(inpLines,[])
   end

\end{minted}
\end{figure}
Funksjonen i figur \ref{fig:rmCommentsTailrec} er transformert til å være halerekursiv. Den utfører samme oppgaven som i figur \ref{fig:rmComments}, men for at den skal oppfylle kravene for halerekursivitet er den blitt refaktorert til å benytte en indre funksjon og et akkumulator-parameter i stedet for å akkumulere rekursivt. Den nye implementeringen medførte også et par andre små endringer slik som reversering av listen når den returneres, men totalt sett var endringen relativt triviell. At refaktoreringen var lite krevende er ikke alltid tilfellet. Eksempelvis benytter den halerekursive varianten av funksjonen for å beregne det n-te Fibonacci tallet en helt annerledes algoritme enn varianten med ordinær rekursjon.

Siden det rekursive kallet er det siste og eneste som blir utført i en halerekursiv funksjon, trenger ikke lokale variabler eller posisjon for returnering å bli lagret.  Fordi rekursjonen aldri kommer til å trekke seg opp igjen, men kun kalle seg selv med endrede parameterverdier vil det som nevnt tidligere ikke være noen grunn for at rekursjonen skal måtte gå {\qq}tilbake{\qq}. På grunnlag av denne kunnskapen kan kompilatoren optimalisere bak kulissene slik at nye stackframes ikke opprettes, men heller at én gjenbrukes. Rekursjonen blir omgjort til normal iterasjon, med de hastighetsforbedringene dette medfører. Hvis man har en kompilator som genererer Assembly vil hale-rekursjonen kunne bli konvertert til å bruke goto og mutering av registre, noe som vil gi svært god ytelse. Uoptimalisert rekursjon i Assembly innebærer at  stackframes må dyttes av og på stacken i tillegg til at parameterne må kopieres(hvis man har pass-by-value slik som i Standard ML) for hvert enkelt funksjonskall. Flere operasjoner medfører mer jobb for CPU-en og dermed lavere ytelse. Flere stackframes medfører også større minnebruk. Standard ML er et språk der de mest populære kompilatorene har halekall-optimalisering, noe man vil kunne se tydelig utsalg for i hastighetstester.


\subsubsection{Hastighetstester}
\label{sec:hastighetestester}
For å teste forskjeller i effektivitet mellom ordinær rekursjon og halerekursjon benyttes en funksjon for å summere elementene i en liste.

\begin{figure}[H]
\caption{Sum av elementene i en liste, ordinær rekursjon (Standard ML)}
\label{fig:sumSML}
\begin{minted}{sml}
fun sum [] = 0
   |sum(x::xs) = x + sum(xs)
\end{minted}

\end{figure}
\textit{Funksjonen legger rekursivt sammen verdien til første element(x) pluss summen til resten av lista(xs). Dersom lista er tom er summen 0.}

\begin{figure}[H]
\caption{Sum av elementene i en liste, halerekursiv (Standard ML)}
\label{fig:sumSMLTailRec}
\begin{minted}{sml}
fun sumTail(li) = 
let fun sumFrom([], summed) = summed
	   |sumFrom(x::xs, summed) = sumFrom(xs,summed + x)
in
	sumFrom(li, 0)
end
\end{minted}
\end{figure}
\textit{Funksjonen funger nesten som den med ordinær rekursjon, men benytter en indre funksjon og en akkumulator-variabel for summen.}
\begin{figure}[H]
\caption{Oversikt over resultater ved kjøring av sum og sumTail}
\begin{center}
\begin{tabular}{|r | r| r| r|}
\hline
\rowcolor{lightGray} Funksjon & Ordninær rekursjon & Hale-rekursjon & Forbedring \\
\hline
sum: 100 000 & 16.6 msek & 13.3 msek & 24.8\% \\
\hline
sum: 1 million & 30.3 msek & 21.6 msek & 40\% \\
\hline
sum: 100 millioner & 182 msek & 3336 msek & 1732\% \\
\hline 
\end{tabular}
\end{center}
\end{figure}
Vi ser av resultatene ovenfor at hale-rekursjon-optimalisering gir betydelige forbedringer med tanke på effektivitet, spesielt når problemstørrelsen øker.

\subsection*{Oppsummering}
I databasen blir rekursjon benyttet hyppig. Dette har flere positive effekter - blant annet kode som er mer konsis og kompakt og i mange tilfeller som også kan oppleves som mer lesbar. Det er forbundet en viss lærigskurve med den rekursive stilen, men etter å ha blitt komfortabel med teknikken føles rekursjon i mange tilfeller mer naturlig. Noen av årsaken til dette kan være at man ender opp med kode på et høyere nivå som også er mer deklarativ. Andre årsaker kan være at man deler opp problemet i stadig mindre biter og ender opp med å løse problemet når det er svært enkelt(typisk for algoritmer slik som mergesort). Å dele opp et problem i mindre deler er en svært kjent taktikk i dagliglivet(tenk f.eks. matlaging) og dette kan være ett av elementene som gjør rekursjon intuitivt for visse problemer. Til slutt skal det også legges til at selv om rekursjon i mange tilfeller vil gi store fordeler, vil en rekursiv løsning på et problem alltid kunne skrives imperativt ved å bruke løkker. Dette kan eksemplifiseres med at alle programmer skrevet i et funksjonelt programmeringsspråk til slutt vil ende opp som maskinkode kjørende på den grunnleggende imperative CPU-en. \\ \\

\section{Abstraksjon, organisering og gjenbruk av kode}
Når programstørrelsen øker og kompleksiteten til programmet vokser, blir det stadig viktigere å organisere koden på en hensiktsmessig måte. Det vil også være avgjørende å bruke hensiktsmessige abstraksjoner for å lage kode som enkelt kan gjenbrukes og tilpasses nye krav. Objektorientert programmering innehar flere mekanismer for å oppnå nettopp dette og disse egenskapene kan muligens tillegges noe av grunnen til paradigmets store suksess. På tross av at funksjonell programmering er grunnleggende annerledes fra objektorientert, kan man likevel få mange av de samme gode egenskapene i dette paradigmet. Denne delen skal se på mekanismer og teknikker for å organisere kode og hvordan man kan få abstrakt og gjenbrukbar kode i det funksjonelle paradigmet og samtidig trekke paralleller til objektorientert programmering.

\subsection{Abstraksjon med first-class-functions}
I funksjonell programmering har funksjoner en viktig og spesiell plass - noe navnet antyder. I funksjonell programmering sidestilles nemlig funksjoner med de andre datatypene slik som tall og strenger, og kan dermed brukes på de samme stedene. Sagt på en annen måte regnes funksjoner som en hvilken som helst annen datatype og ikke en spesiell, annenrangs type slik tilfellet er i en del imperative språk. Dette medfører at funksjoner kan bli lagret i datastrukturer som f.eks. lister, at de kan bli sendt som argumenter, at en funksjon kan returnere en annen funksjon, og at en funksjon kan bli definert inne i en annen funksjon. Dette er en kraftfull mekanisme som lar deg skrive mer abstrakt og gjenbrukbar kode. At funksjoner kan defineres inne i andre skaper et hierki og kan gi en bedre organisering og struktur på koden.

\subsubsection*{Funksjoner som argumenter}
I imperativ programmering er man kjent med funksjoner som en viktig abstraksjons-enhet. En  funksjon kan ta imot argumenter , noe som gjør at brukeren kan bestemme deler av oppførselen til algoritmen. Denne muligheten gjør funksjonen mer generell og abstrakt og dermed også mer gjenbrukbar. I imperativ programmering pleier som regel parameterne å være data slik som strenger, tall eller lister. På denne måten blir dataen funksjonen jobber med abstrahert bort. I en funksjon for å beregne verdiutviklingen til penger i banken  kan man f.eks. ha et parameter for rente-verdi, ett for antall år pengene er i banken og ett for opprinnelig beløp. Ved å ha de tre argumentene kan man benytte funksjonen til å regne verdiutviklingen med ulike kombinasjoner av rentebeløp,  opprinnelige beløp og  antall år. Selv om data som parametre kan bidra til abstraksjon på et rimelig høyt nivå,  tar funksjonell programmering abstraksjonen enda høyere ved å også la utvikleren abstrahere bort kodeblokker, altså det funksjonen \textit{gjør}. En funksjon som gjennomfører en kompleks beregning, kan ta imot funksjoner for å utføre deler av beregningen. Andre vanlige bruksområder er i forhold til lister, der man ofte ønsker å utføre en bestemt operasjon på hvert enkelt listeelement. Konseptet med funksjoner som tar imot eller returnerer funksjoner kalles i høyere-nivå-funksjoner i funksjonell programmering. Funksjoner slik som map, reduce, filter og takewhile er eksempler av denne typen som blir mye brukt i den funksjonelle stilen.

En funksjon som benyttes hyppig i spørrespråket er en funksjon for å konvertere en liste til en streng. Funksjonen benyttes  til feilsøking og for å produsere deler av feilmeldingene brukeren møter dersom spørringen eller dataen som blir forespurt er ugyldig.

\begin{figure}[H]
\label{fig:listToStr}
\caption{Funksjon for å konvertere en liste til en streng (Standard ML)}
\begin{minted}{sml}
fun listToStr ([], toStr:('a->string), sep:string):string = ""
  | listToStr([x], toStr, sep) = toStr x
  | listToStr(x::xs, toStr, sep) = toStr x ^ sep ^ listToStr(xs,toStr,sep)

\end{minted}
\end{figure}
\textit{Funksjonen lager en streng-representasjon av listen. toStr blir brukt til å 
konvertere hvert enkelt listeelement  til en streng og sep blir satt inn mellom elementene. Streng-representasjonen er definert som en tom streng for en tom liste og listefunksjonen brukt på ett element hvis listen bare har ett element. Dersom listen har mer enn ett element er definisjonen strengen bestående av  første element, separatoren og den rekursive løsningen til resten av elementene. }

I funksjonen over er fremgangsmåten for å konvertere et listeelement abstrahert bort i parameteret toStr. På denne måten vil funksjonen  fungere for lister av vilkårlig type. Funksjonen som sendes inn, har i likhet med de andre parameterne og elementer generelt i SML, en type. Av funksjonens signatur kan vi lese at den  må ta imot et element av type 'a(samme type som listeelementene skal ha) og produsere en verdi av type streng. Utenom dette står brukeren av funksjonen fritt til å lage en egen implementering. Denne funksjonen vil bli brukt på hvert element i listen for å lage den endelige strengen. Når man kaller på listToStr kan man enten sende med en predefinert funksjon, eller man kan definere funksjonen navnløst og på stedet, ved å lage en såkalt lambdafunksjon. Se figur \ref{fig:listToStrCalling} for eksempel på de to variantene.

\begin{figure}[H]
\caption{Kall på listToStr med predefinert funksjon og lambdafunksjon(Standard ML)}
\label{fig:listToStrCalling}
\begin{minted}{sml}
val intList =  [1,2,3,4,5]
val strList1 = listToStr(intList, Int.toString, " ")
val strList2 = listToStr(intList, (fn e => "num: " ^ Int.toString(e)),  " ") 
\end{minted}
\end{figure}

Her er Int.toString en bibliotekfunksjon som konverterer ett tall til én streng. Siden funksjoner som nevnt er første-klasses-typer i SML kan de sendes som et vanlig argument. Variant nr. to benytter en lambdafunksjon som setter sammen "num:" med strengrepresentasjonen av tallet. Predefinerte funksjoner har en enklere syntaks og er mest hensiktsmessige hvis du har en funksjon du ønsker å bruke flere ganger. Lambda-funksjoner er mest hensiktsmessig for en funksjon som kun blir brukt én gang  og som er mer ad-hoc.

\subsubsection*{Funksjoner inne i funksjoner}
På samme måte som en funksjon eller et uttrykk kan ha lokale konstanter av de tradisjonelle datatypene kan de også ha lokale funksjoner.  En lokal funksjon defineres inne i en annen funksjon eller uttrykk(vil ikke bli omtalt i denne rapporten), og vil dermed ha tilgang til parameterne til den omsluttende funksjonen. Med dette kan man si at den lokale funksjonen dermed blir en del av den omsluttende, på samme måte som en lokal variabel blir en del av den omsluttende funksjonen. Å flytte kode ut i lokale funksjoner gir tydeligere oppdeling av koden, og siden lokale funksjoner kan defineres vilkårlig dypt får man også en teknikk for å skape et hierarki. Med lokale funksjoner kan man skape mer modulær kode og ved å flytte noen av operasjonene til en lokal funksjon også gjøre funksjonen mer lesbar. Lesbarheten kommer av at at man navn til selve operasjonen som utføres og på parameterne som sendes inn. Dette er fordeler man også kjenner til fra funksjoner på topp-nivå. Samtidig unngår man problemene som ofte er knyttet til denne typen funksjoner slik som navnekollisjoner og nødvendigheten av å sende rundt mange parametre.  Et eksempel på bruk av lokale funksjoner finnes i figur \ref{fig:getLitteralFromType}. Et annet bruksområde er i forhold til halerekursive funksjoner (også omtalt i seksjon \ref{sec:rec}) under overskriften {\qq}\ref{subsec:effektiivitet}{\qq}. Man kan da benytte en lokal funksjon med et akkumulator-parameter i tillegg til de andre nødvendige parameterne. Den omsluttende funksjonen kan da kalle på den indre og sette en fornuftig start-verdi på akkumulatorparameteret. Et eksempel på dette er funksjonen i figur \ref{fig:sumSMLTailRec}. 

\begin{figure}[H]
\caption{Funksjon for å hente en litteral fra en streng. En type blir sendt med for å teste om typen i strengen er korrekt}
\label{fig:getLitteralFromType}
\begin{minted}{sml}

fun getLitteralFromType(
      source:string,  type_:MetadataParser.Type,  lineNo:int,
      filename:string):Tok.litteral option = 

  let fun raiseWrongDataExn(expected, found) = 
        raise ErrorHandler.typeErrorStoredData(
                expected, ParseUtil.getTypeOfSource(source),lineNo,filename)

      val firstCharOpt = Util.hdStringOpt(source)
  in  
      case firstCharOpt of
           SOME(firstChar)  =>  
              (case type_ of
               STRING => if ParseUtil.isStartOfString(firstChar) then
                        ...
                         else 
                            raiseWrongDataExn("string")
              |NUMBER => if ParseUtil.isStartOfDigit(firstChar) then
                       ...
                         else
                           raiseWrongDataExn("integer")
              |BOOL  => if ParseUtil.isStrBoolean(source) then
                         ...
                        else 
                          raiseWrongDataExn("boolean") )
          |NONE => NONE 
  end 

\end{minted}
\end{figure}

\textit{Funksjonen henter ut en streng, et tall eller en boolsk verdi fra en streng. Basert på typen som blir sendt med forsøker funksjonen å lage en verdi av en av de tre nevnte typene basert på det den finner i strengen. Hvis typene ikke stemmer overens skal en bestemt exception bli kastet.  {\qq}...{\qq} innebærer at en del av koden er utelatt.}

Man kan se av funksjonen over at den lokale funksjonen reduserer duplisering av kode og samtidig er fleksibel nok til å  fungere for de ulike typene som skal sjekkes. Siden denne funksjonen omfatter en relativt spesifikk situasjon, gir det mening å ha den som en lokal funksjon og ikke blant de andre top-nivå funksjonene som en generell funksjon. Funksjonen tar også nytte av å ha direkte tilgang på parameterne til den omsluttende funksjonen, i dette tilfellet \textit{lineNo} og \textit{filename}. 
\subsection{Organisering av kode med strukturer, signaturer og funktorer}
\label{sec:organisering}
Standard ML inkluderer et sett med mekanikker for å organisere kode og skape abstraksjon. I SML kalles de \textit{structure}, \textit{signature} og \textit{functor}.


Strukturer går ut på å pakke ett sett med deklareringer sammen. Deklareringer kan være konstanter, funksjoner, datatyper, typealiaser, exceptions, strukturer, funktorer eller signaturer. Alene fungerer en struktur litt som et namespace ved at man må referere til en bestemt struktur når man vil benytte seg av et av elementene inne i strukturen. Dette sørger for at man unngår navnekollisjoner. Man kan også se likheter mellom klasser og strukturer, med den distinkte forskjellen er at i den funksjonelle stilen skal man unngå mutering. Funksjonene i en struktur er heller ikke knyttet til noen bestemt instans av data, og er avhengig av at dataen sendes inn for hvert funksjonskall. Skal man emulere konseptet med å kalle funksjoner på en "instans" kan closures benyttes. De nevnte egenskapene til strukturen gjør at den likner mer på en klasse med bare konstant-felter og der alle metoder er statiske. At man unngår mutering i en struktur har den effekten at den i større grad blir en statisk, isolert og flyttbar enhet. Man trenger ikke å tenke på at strukturen kan endres fra utsiden eller at den er avhengig av endringer på utsiden for å fungere, siden strukturens tilstand aldri vil kunne endres. Feilsøking og forståelse av kildekoden vil derfor kunne bli enklere. De nevnte egenskapene vil i tillegg gjøre testing(spesielt unit-testing) enklere siden en struktur kan testes isolert.

En signatur fungerer som en kontrakt og beskriver typene til deklareringene en struktur må ha, men ikke selve implementeringen. At implementeringen ikke er med gjør signaturen abstrakt. Signaturer kan derfor sammenliknes med grensesnitt i f.eks. Java, men har et noe annerledes bruksområde. En annen måte å se en signatur på er at de representerer typen til en struktur. En struktur kan implementere en signatur og må i det tilfellet følge kontrakten definert i signaturen. I SML finnes det to måter en signatur kan implementeres på. Hvis signaturen implementeres på en gjennomsiktig måte vil signaturen utelukkende fungere som en kontrakt og alle typer og funksjoner definert utenom kontrakten vil være synlige. Dette reduserer abstraksjonen og vil kanskje også åpne opp for integritetsøledeggende operasjoner. Eksempelvis vil en struktur og en signatur for en kø, implementert gjennomsiktig kunne gjøre det tydelig hvilken datastruktur køen er implementert med og siden man har tilgang til denne underliggende strukturen, vil man også kunne ødelegge integriteten, f.eks. ved å hente ut et element fra slutten av køen. En annen ulempe er at siden man har tilgang til den underliggende datastrukturen, vil man også kunne utføre likhetstester. Denne likhetstesten vil fungere på normal måte, noe som i noen tilfeller ikke er intensjonen med strukturen. I en struktur for en samling uordnede elementer vil man f.eks. ikke at [1,2] og [2,1] skal bli sett på som to ulike strukturer. Den ande måten å implementere en signatur på er den ugjennomsiktige måten. Dette vil gjøre de underliggende datatypene abstrakte slik at de ikke kan benyttes utenfor strukturen og dermed heller ikke i likhetstester eller i integritetsøledeggende operasjoner. Den andre effekten man oppnår er at deklarasjoner som ikke er definert i signaturen vil bli skjult fra utsiden, noe som vil gi effekter tilsvarende innkapsulering ved bruk av f.eks. \textit{private} i Java. Strukturer og signaturer kan lages fullstendig uten mutering og er derfor funksjonelle i natur. I SML er signaturer kanskje mest nyttige når de blir brukt i forbindelse med funktorer som vil bli diskutert senere.

Databasen bruker en funksjonell map(aka assosiativ liste) basert på et binærtre for å lagre informasjon om de ulike kolonnene med data som leses inn når en spørring utføres. Denne datastrukturen brukes til å holde på selve dataen definert i datafilen slik at de ulike kolonnene for en rad enkelt kan bli funnet. Det er ønskelig at mapen har funksjoner for å sette inn og hente hente ut en verdi assosiert med en bestemt nøkkel. Dette er operasjoner som er ønskelig at alle maper skal ha, og funksjons-signaturene for dette er derfor definert i signaturen i figur \ref{fig:sigMap}.

Siden mapen er i den funksjonelle stilen vil den ikke kunne muteres. Dermed vil man ikke kunne ta i mot en map, endre den og deretter returnere den slik tilfellet ofte er i imperativ programmering. I stedet vil man ta imot en map og opprette en ny basert på den som ble sendt inn. Det er da den nye mapen som blir returnert. Dette vil ha den positive effekten at man ikke trenger å bekymre seg for om data sendt inn til en funksjon kommer til å bli endret av funksjonen. Dette faktumet fører til at designet av mapen vil bli grunnleggende annerledes enn tilfellet hadde vært i det objektorienterte paradigmet.

Mapen skal støtte nøkler av ulik typer data, også de typene som er av mer kompleks form. Siden mapen egentlig er et binært tre er man avhengig av å kunne finne rekkefølgen på elementene. Dette er for å kunne bestemme plasseringen i treet og senere for å kunne finne frem til en bestemt nøkkel. Med strukturer og signaturer ville løsningen blitt en implementering for hver av typene man ønsker å ha som nøkkel. Selv om strukturer og signaturer tilbyr innkapsulering og abstraksjon, bidrar de lite til å lage  kode som er gjenbrukbar. Ønsker man å implementere 4 nye typer nøkler må man lage 4 strukturer. Enda verre er det hvis man har flere ulike map-implementeringer som alle bruker rekkefølgen til elementene for å sette inn og hente ut elementene. Eksempelvis kan man ha en liste som bruker binærsøk i tillegg. I dette tilfellet hadde antall implementeringer blitt enormt mange. Løsningen med kun signaturer og strukturer skaper i slike tilfeller store mengder duplisert kode og vil være krevende å vedlikeholde.

Funktoren i SML lar deg unngå de nevnte problemene. Den fungerer som en slags funksjon som tar imot en eller flere strukturer av en bestemt type(som oppfyller en bestemt signatur) og som produserer en ny struktur som resultat. For map-implementeringen vil man kunne ønske å lage en funktor for hver enkelt implementering av map, som tar imot en struktur for datatypen som skal brukes som nøkkel. Strukturen som blir tatt imot kan da være av type ORDERED\_TYPE. Denne signaturen finnes i figur \ref{fig:sigOrdered}. To strukturer som implementerer denne signaturen finnes i figur \ref{fig:structOrdered}. Strukturen som sendes inn kan inneholde en funksjon for å bestemme rekkefølgen til to elementer av den aktuelle typen i tillegg til å inneholde selve data-typen. Funktoren til treeMap, i figur \ref{fig:funktorTreeMap} er laget på denne måten. Ved at type element og dets sortering ikke er hardkodet, men heller er abstrahert vekk vil funktoren kunne gjenbrukes med flere ulike datatyper, noe man ser eksempel på i figur \ref{fig:maps}. Når man kaller på funktoren vil en ny struktur tilpasset en bestemt type opprettes. Gjenbruksfaktoren økes også ved at strukturene til datatypene vil kunne bli delt på tvers av ulike implementeringer av map dersom alle tar imot en struktur av samme type.

\begin{figure}[H]
\caption{Signatur for en map (Standard ML)}
\label{fig:sigMap}
\begin{minted}{sml}
signature MAP = 
sig
  type 'a Map 
  type keyType
  val insert: ('a Map*keyType*'a)-> 'a Map 
  val get: ('a Map*keyType) -> 'a option
  val empty:(unit) -> 'a Map 
  val addTwoMaps:('a Map*'a Map)->'a Map 
  val keyList:('a Map) -> keyType list
end;

\end{minted}
\end{figure}

\begin{figure}[H]
\caption{Funktor for treeMap (Standard ML)}
\label{fig:funktorTreeMap}
\begin{minted}{sml}
functor MapTreeOfType (ordered:ORDERED_TYPE):MAP =  
struct 
  type keyType = ordered.t

  datatype 'a MapTree = 
    (*Key*value*left*right*)
    Node of keyType * 'a * 'a MapTree * 'a MapTree |
    EmptyNode
  
  (*Creates a empty map. The map does not yet have a value-type associated. This is set upon the     first insert*)
  fun empty() = EmptyNode

  (*Inserts a value into the given map. If the key already exists, no value is
  inserted*)
  fun insert(mt:'a MapTree, key:keyType, value: 'a):'a MapTree =
    case mt of
      EmptyNode     => Node(key,value,EmptyNode,EmptyNode) 
     |Node(k,v,l,r) => case ordered.compare(k,key) of
                         EQUAL   => mt (*The key already exists- the original tree is returned*)
                        |LESS    => Node(k,v,insert(l,key,value),r)
                        |GREATER => Node(k,v,l,insert(r,key,value))

  (*Retrieves the value associated with the given key. The result is wrapped in
   an option*)
  fun get(mt: 'a MapTree, key:keyType):'a option =
    case mt of 
      EmptyNode     => NONE 
     |Node(k,v,l,r) => case ordered.compare(k,key) of
                         EQUAL   => SOME(v)
                        |LESS    => get(l,key)
                        |GREATER => get(r,key)
end;

\end{minted}
\end{figure}

\begin{figure}[H]
\caption{Strukturer av type ORDERED\_TYPE for streng og tall med rekkefølge-funksjon (Standard ML)}
\label{fig:structOrdered}
\begin{minted}{sml}
structure orderedInt:ORDERED_TYPE = 
struct 
  type  t = int

  fun compare(i1,i2) = 
    if i1 < i2 then LESS 
    else if i1 > i2 then GREATER 
    else EQUAL
end;

structure orderedString:ORDERED_TYPE = 
struct
  type t = string
  fun compare(s1,s2) = 
    String.compare(s1,s2)
end;
\end{minted}
\end{figure}

\begin{figure}[H]
\caption{Signatur for en type med rekkefølge-støtte (Standard ML)}
\label{fig:sigOrdered}
\begin{minted}{sml}
signature ORDERED_TYPE= 
sig
  type t
  val compare: (t*t) -> General.order
end;

\end{minted}
\end{figure}

\begin{figure}[H]
\caption{Strukturer for tree-baserte maper for int og streng. En funktor brukes for å lage strukturene. (Standard ML)}
\label{fig:maps}
\begin{minted}{sml}
structure MapInt = MapTreeOfType(orderedInt)
structure MapString = MapTreeOfType(orderedString)
\end{minted}
\end{figure}

\chapter{Spørrespråkets syntaks}
\section{Syntaks}
For å beskrive databasens syntaks har jeg valgt å bruke kontekstfri grammatikk og Backus-Naur-form, som notasjon.
\subsection*{Beskrivelse av notasjonen}
Tekst mellom vinkelparenteser (< og >) betegner navnet på en ny grammatikkregel hvis den står på venstre side av {\qq}::={\qq}, og henviser til en eksisterende grammatikkregel dersom den står på høyre side. Tekst inne i fnutter({\qq}slik{\qq}), er rene tekststrenger som skal skrives rett ut.  Pipe-symbolet(|) betyr at det finnes flere muligheter for å oppfylle regelen. Regelen kan være rekursiv ved at den henviser til seg selv, men har alltid da flere alternativer slik at rekursjonen vil ta slutt på et tidspunkt. Store bokstaver indikerer at selve verdien angis av brukeren selv.
Elementer omgitt av firkantparanteser ([ og ] betyr at elementet er frivillig.
\subsection{Query}
\label{sec:query}
Lar brukeren hente ut data fra en eller to tabeller og eventuelt behandle dataene før de blir skrevet ut. Syntaksen er laget for å være intuitiv og samtidig ha en naturlig flyt av operasjonene fra begynnelsen til slutten av spørringen: Dataen blir hentet fra fil, satt sammen, filterert og til slutt skrevet ut.\\

<query> ::= <from> [ <merge> ] [ <filter> ] <output> | \\

\subsubsection*{From}
Lar brukeren spesifisere hvilke datafiler som skal benyttes. Bruk av alias vil døpe om tabellen, slik at aliasen vil være den eneste måten å referere til tabellen på. Dette er for å unngå forvirring.
<from> ::= {\qq}from{\qq} <tableList> \\
<tableList> :: =<table> | <table> {\qq},{\qq} <tableList> \\
<table> ::= TABLENAME | TABLENAME {\qq}as{\qq} ALIAS

\subsubsection*{Merge}
Lar brukeren slå sammen to tabeller. Den nye tabellen {\qq}merged{\qq} vil da bli opprettet og det er denne tabellen man skal referere til i de andre delene av spørringen. Merge-tabellen er både for å motvirke forvirring hos bruker i forhold til hvilken av de to tabellene man eventuelt skulle ha referert til og for å gjøre implementeringen mer rett frem. 

<merge> ::= {\qq}merge{\qq} TABLENAME {\qq}and{\qq} TABLENAME {\qq}using{\qq} COLUMNNAME \\

\subsubsection*{Filter}
Lar brukeren bruke en eller flere predikater for å filtrerer hvilke rader som skal bli skrevet ut.
<filter> ::= {\qq}filter{\qq} <predicateList> \\
<predicateList> ::= <predicate> | <predicate> <logicOperator> <predicateList> \\
<logicOperator> ::= {\qq}and{\qq} | {\qq}or{\qq} \\
<predicate> ::= 
\tab {
<expression> <predicateOperator> <expression> | \\
<columnName> <predicateFunction>
}
<expression> ::= [{\qq}({\qq}]<expression> <operator> <expression> [{\qq}){\qq}] | <value> \\
<operator> ::= {\qq}+{\qq} | {\qq}-{\qq} | {\qq}*{\qq} | {\qq}/{\qq} \\
<predicateOperator> ::= {\qq}>{\qq} | {\qq}<{\qq} | {\qq}>={\qq} | {\qq}<={\qq} | {\qq}={\qq} | {\qq}!={\qq} \\
<value> ::= <columnName> | LITTERAL \\
<predicateFunction> ::= <predicateFunctionName> {\qq}({\qq}<valueList>{\qq}){\qq} \\
<valueList> ::= <value> | <value> {\qq},{\qq} <valueList> \\
<predicateFunctionName> ::= {\qq}oneof{\qq} | {\qq}noneof{\qq} \\
<columnName> ::= 
\tab {
COLUMNNAME | \\
TABLENAME {\qq}.{\qq} COLNAME | \\
}

\subsection{Output}
Lar brukeren velge hvilke kolonner/uttrykk som skal skrives ut og eventuelle operasjoner som skal gjøres for hver kolonne. Hvilket kolonnenavn som blir gitt ved utskrift kan endres ved å benytte en alias(nøkkelordet named). En alias kan være spesielt aktuelt ved transformasjon på en kolonne eller ved utskrift av et uttrykk. (Denne funksjonen ble det ikke tid til å implementere.) Output støtter også pipelining av transformasjoner på dataen som skal skrives ut, men bare på en kolonne/uttrykk om gangen. Det er mulig å skrive ut flere kolonner i en enkelt operasjon, men da støttes ikke pipelining av dataene. Pipelining med flere kolonner ville både ha vært utfordrende å løse teknisk i tillegg til at oppførselen ville kunne ha forvirret brukeren. Legg også merke til at dersom to tabeller benyttes i samme spørring, må spesialtabellen {\qq}merged{\qq} benyttes, som nevnt i seksjonen for merge. \\

<output> ::= {\qq}output{\qq} <outputList> \\
<outputList> ::= <output> | <output> {\qq},{\qq} <outputList> \\
<output> ::= <expression> [<alias>][<functionPipeline>]  | <columnOutput> [<alias>] \\
<expression> ::= \textit{Se seksjon\ref{sec:query}: Filter \\}
<functionPipeline> ::= <pipeFunction> | <pipeFunction> {\qq}->{\qq} <functionPipeline> \\
<pipeFunction> ::= {\qq}upper{\qq} | {\qq}lower{\qq} | {\qq}capitalized{\qq} |  {\qq}backwards{\qq} | {\qq}trim{\qq} | {\qq}numSep{\qq}| {\qq}trim{\qq}  \\

<alias> ::= {\qq}named{\qq} CUSTOM\_NAME \\
<columnOutput> ::= TABLENAME{\qq}.{\qq}COLNAME\\
\subsubsection*{Eksempel}
\textit{from Person as P, PersonWork as PW \\
		merge P and PW using personID \\
        filter department oneof({\qq}computers{\qq}, {\qq}phones{\qq}, {\qq}support{\qq}) and \\
        salary > 100000 \\
        output merged.name -> trim -> capitalized as employeename,\\
        merged.adress
        }
\subsection{Insert}
\label{sec:insert}
Lar brukeren sette inn data i form av en eller flere rader i en tabell. Tabellen må være oprettet på forhånd. Dersom en eller flere kolonner ikke spesifiseres vil databasen enten sette kolonneverdien til standardverdien, hvis den ble spesifisert ved opprettelse av tabellen, eller gi en feilmelding dersom kolonnen ikke har noen standardverdi. For spesifisering av kolonner benyttes utelukkende navnet på kolonnen/subkolonnen.\\

<insert> ::= {\qq}insert rows into{\qq} TABLE <rowlist> \\
<rowlist> ::= <row> | row {\qq},{\qq} <rowlist> \\
<row> ::= {\qq}({\qq} <columnValueList> {\qq}){\qq} \\
<columnValueList> ::= 
\tab{
<columnValue> | \\
<columnValue> {\qq},{\qq} <columnValueList>
}
<columnValue> ::= <keyValue> | <subkeyValues> \\
<keyValue> ::= COLNAME {\qq}:{\qq} <expression> \\
<subkeyValues> ::= COLNAME {\qq}:\{{\qq}<keyValueList>{\qq}\}{\qq} \\
<keyValueList> ::= <keyValue> | <keyValue> {\qq},{\qq} <keyValueList> \\


\subsection{Remove}
Lar brukeren slette rader fra en tabell som stemmer med en eller flere predikater.
<remove> ::= {\qq}remove rows from{\qq} TABLENAME {\qq}WHERE{\qq} <predicateList>
<predicateList> ::= \textit{Se seksjon \ref{sec:query}: Filter}


\subsection{Update}
Lar brukeren endre verdi på eksisterende celler. Ved endring settes de kolonner som ønskes å endres på samme måte som nevnt i seksjon \ref{sec:insert} men i tilegg kan den reserverte variabelen OLD benyttes i uttrykkene å henvise til den gjeldende verdien. \\
<update> ::= {\qq}update{\qq} TABLENAME {\qq}where{\qq} <predicateList> {\qq}set{\qq} <columnValueList> \\
<predicateList> ::= \textit{Se seksjon \ref{sec:query}: Filter} \\
<columnValueList> ::= \textit{Se seksjon \ref{sec:insert}}


\subsection{Create}
\label{sec:create}
Lar brukeren opprette en ny tabell. Alle kolonene må ha datatyper spesifisert og det er mulig å la kolonnene ha en standardverdi.
\subsubsection*{Datatyper}
Databasen har tre datatyper:
\begin{itemize}
\item boolean: enten true eller false
\item number: et flyttall-nummer, men kan spesifiseres uten desimaler
\item string: en vilkårlig tekststreng
\end{itemize}
<create> ::= {\qq}create table{\qq}  TABLENAME {\qq}with columns{\qq} <columnList>\\
<columnList> ::= <column> | <column> {\qq},{\qq} <columnList>\\
<column> ::= <nameDatatype> | COLNAME {\qq}:\{{\qq}<nameDatatypeList>{\qq}\}{\qq}\\
<nameDatatype> ::= COLNAME {\qq}of{\qq} <datatype> [{\qq}default{\qq} LITTERAL] \\
<nameDatatypeList> ::= <nameDatatype> | <nameDatatype> {\qq},{\qq} \\
<datatype> ::= {\qq}string{\qq} | {\qq}boolean{\qq} | {\qq}number{\qq}\\

Eksampler på oppbrytning av de ulike delene.


\section{Lagring}
\label{sec:dataOgMetadata}
\subsection{Metadata}
Metadatafilen lagrer informasjon om de ulike kolonnene i en tabell.
Syntaksen til metadatafilen er slik:

<entryList> ::= <entry> | <entry>{\qq};{\qq}<entryList> \\
<entry> ::= COLNAME{\qq}\{{\qq}<datatype> [{\qq},{\qq}<defaultValue>] {\qq}\}{\qq}  \\
<datatype> ::= s | n | b \\
<defaultValue> ::= LITTERAL \\

\subsubsection*{Eksempel}
\textit{Name\{s,{\qq}John Doe{\qq}\};Phone\{n\};Adress\{s\})}

\subsection{Data}
Selve dataen lagres i CSV-format. Formatet er valgt for å være enkelt å lese for både mennesker og maskiner i tillegg til å ta lite plass og være flyttbart. Siden lagringen benytter plassering for å bestemme de ulike kolonnene, er programmet avhengig av metadatafilen for å kunne skille mellom  dem. Et felt kan være tomt ved at det ikke er noen tegn i det. Hvis en standardverdi er satt benyttes denne i stedet ved utskrift. Hvis ikke vil programmet avslutte med en feilmelding. Filen har slik syntaks:\\
<rowList> ::= <row> | <row>{\qq}\escape{n}{\qq}<rowList> \\
<row> ::= <columnList> \\
<columnList> ::= <column> | <column>{\qq};{\qq}<columnList>\\
<column> ::= LITTERAL\\
\subsubsection*{Eksempel}
\textit{{\qq}Per Olsen{\qq};67284771;{\qq}Einerveien 18{\qq}\\
        ;88341821;{\qq} Lierveien 2{\qq}}
        
\chapter{Inplementasjon}
\label{chap:inplementation}
\section{Indtroduksjon}
I utgangpunktet gikk oppgaven ut på å lage en databasemotor. Databasemotoren skulle kunne utføre de normale databaseoperasjonene og benytte et enkelt spørrespråk som brukeren kunne anvende til å kommunisere med databasen. I ettertid har omfanget til oppgaven blitt betydelig redusert, og konsentrerer seg nå om lagring og ut-henting av data ved hjelp av spørrespråket. Siden en stor del av programkoden handler om å tolke spørrespråket og hente ut og presentere relevant data, har oppgaven blitt vridd mer mot utvikling av en minimal interpreter for et domene-spesifikt språk. Denne delen skal presentere hvordan spørrespråket er løst rent teknisk og sette dette opp mot det funksjonelle paradigmet og de fordelene og ulempene det har medført.

\section{Høynivå-design}
For planlegging og dokumentasjon for et større program kan det  være interessant å se på hvordan de ulike delene av programmet er satt sammen i form av funksjonssignaturer  og signaturer(som implementeres av moduler). Funksjonssignaturene gir en oversikt over alle de implementerte funksjonene og er kanskje ekstra nyttig innen funksjonel programmering siden en funksjon utelukkende er en mapping mellom input og output. Signaturene vil gi et mer utenifra-perspektiv ved  at utvikleren eller andre involverte enkelt se hvilken funksjonalitet og data som blir tilbudt. Signaturene vil derfor kunne fungere som en slags form for API-dokumentasjon. Denne teknikken blir ofte benyttet når man ønsker å modellere og planlegge en større funksjonell applikasjon.
 
Iren funksjonell programmering er man ikke interessert i tilstander, men heller flyten til dataen gjennom ulike funksjoner. For å få et overblikk over spørrespråket kan det derfor også være hensiktsmessig å lage en modell som viser nettopp dette. Siden funksjonene er rene, er man sikre på at dataen vil flyte mellom funksjonene, og ikke noe mer. Dette kan gjøre modellering enklere ved at man kan lage funksjonssignaturene som byggeblokker som deretter blir koplet sammen. Legg merke til at funksjoner utenfor signaturen også er med i dette diagrammet. Dette betyr at diagrammet er knyttet til denne spesifikke inplementasjonen. I denne sammenhengen er muligens flyten av data en mer relevant måte å få et helhetsintrykk enn en oversikt over signaturene.

Diagrammet under viser hvordan dataen flyter mellom de ulike funksjonene. En pil indikerer at data(kan være output fra en funksjon) blir brukt i andre funksjoner. Diagrammet viser dermed ikke hvilken funksjon som kaller på de ulike funksjonene. Å vise dette kunne fort ha medført et svært rotete diagram.



\section{Oppdeling i tokens}
Første skrittet for en kompilator eller interpreter er å dele inn kildekoden den mottar opp i ulike deler. Delene blir ofte omtalt som \textit{tokens}. En token tilsvarer én logisk enhet som skal leses og forstås samlet. Eksempler er et tall, en streng, et reservert nøkkelord, eller et syntakssymbol slik som {\qq},{\qq}. Før inndelingen i tokens tar plass blir kommentarer fjernet (se figur \ref{fig:rmComments} for koden) da dette er data som ikke er interessant for interpreteren. Deretter starter selve prosessen med å konvertere kildekoden (i form av en streng) til en liste med tokens.

Det benyttes en egen datatype, aka algebraisk datatype for tokens, se figur \ref{fig:structureToks}. En datatype lar deg definere en type som ved instantiering kan benytte en av flere ulike konstruktører(i denne konteksten ofte kalt en typekonstruktør). Valget av \textit{datatype} for å representere en token gjør det enkelt og elegant å detektere hvilken token-type (typekonstruktør) som ble brukt ved opprettelse i tillegg til at det er enkelt å hente ut de ulike verdiene som ble sendt inn til konstruktøren, altså selve verdien til tokenen. Dette gjøres gjennom pattern-matching, noe som blir diskutert lenger nede i teksten. Et element i en datatype(separert med {\qq}|{\qq}) kan enten representere en enum-aktig konstant eller ha en konstruktør som tar imot en eller flere verdier av bestemte typer. \textit{Identifier} krever f.eks av en streng for å bli opprettet. Enkelte av elementene, slik som \textit{Litteral}, henviser til en annen type som igjen kan benytte en eller flere andre typekonstruktører. På denne måten får man skapt et slags type-hierarki. Eksempelvis kan en token med ett tall representeres som \textit{Litteral(Number(1.0))}. Denne måten å ordne de ulike token-typene skiller også mellom ulike tokens som er av samme type ved å pakke dem inn i egne typer, slik som \textit{Operator} og \textit{SyntaxSymbol}. Man kan trekke en parallell mellom dette og det å lage \textit{wrapper-klasser} i Java. Å dele tokenene inn i de ulike typene gjør det enklere å differensiere mellom typene og  bidrar også til å kunne jobbe på et høyere nivå senere i koden. I tillegg vil oppdelingen i ulike subtyper gi større typesikkerhet. Høy typesikkerhet kombinert med uttrykksfull kode (som man kan argumentere for at koden i figur \ref{fig:structureToks} er) er viktige kjennetegn for en rekke funksjonelle språk slik som Standard ML, Haskell, Ocaml, F\# og Scala . Dette er noe undertegnede har sett fordelene med gjennom utviklingen av programmet.

Strukturen inneholder også en typealias kalt \textit{TokenAtLine}. \textit{TokenAtLine} pakker en token sammen med linjenummeret tokenen ble funnet på. Linjenummeret er avgjørende å ta vare på for å kunne gi fornuftige feilmeldinger dersom en spørring er ugyldig.

Selve prosessen med å konvertere fra en streng til en liste med \textit{TokenAtLine} gjøres i funksjonen \textit{Scanner.scan}. Et utdrag finnes også i figur \ref{fig:scan}. I dette utdraget kan man også se hvordan en type konstrueres gjennom de ulike typekonstruktørene.


\begin{figure}[H]
\caption{Struktur for tokens (Standard ML)}
\label{fig:structureToks}
\begin{minted}{sml}
structure Tok = 
struct

datatype litteral =
   String of string
  | Bool of bool
  | Number of real

datatype symbol =
    Operator of string
  | PredicateOperator of string
  | SyntaxSymbol of string

datatype Token =
    Identifier of string(*Ex: tablename, columname*)
  | Function of string (*Ex: noneof*)
  | PipeFunction of string (*Ex: upper, lower*)
  | Litteral of litteral(*Ex: 123, "text"*)
  | Keyword of string (*Ex: from,Token filter*)
  | Symbol of symbol (*Ex: #, {*)


type TokenAtLine = Token * int;
end;
\end{minted}
\end{figure}

\begin{figure}[H]
\caption{Funksjon for å dele opp en streng med en spørring til en liste med TokenAtLine}
\label{fig:scan}
\begin{minted}{sml}
 fun scan(str:string, lineNo:int):TokenAtLine list =
    let
      val firstChar = String.sub(str, 0)
      ...
    in
      if ParseUtil.isStartOfIdentifier(firstChar) then
        let val (firstId, rest) = ParseUtil.getFirstIdentifier(str)
            val token = determineTokTypeForReserved(firstId)
        in (token, lineNo) :: scan(rest, lineNo)
        end

      else if ParseUtil.isStartOfwhitespace(firstChar) then 
      	scan(Util.rmHeadOfString(str), lineNo)

      else if ParseUtil.isStartOfString(firstChar) then
        let val (firstStr, rest) = ParseUtil.getFirstString(str, stringSep)
        in  (Litteral(String(firstStr)), lineNo) ::
              scan(rest,lineNo)
        end
     ...
      else
        raise ErrorHandler.noSuchSymbol(Char.toString(firstChar),lineNo)
    end
    handle Subscript => []

\end{minted}
\end{figure}

\textit{Funksjonen benytter funksjoner fra strukturen ParseUtil for å sjekke typen som skal leses inn og for å utføre selve oppdelingen. Kun første karakter av den innsendte strengen er nødvendig for å kunne bestemme typen til neste token. De scenariene blir testet en etter en, og hvis ingen av de stemmer  blir en exception kastet. For hver test hentes den delen som tilsvarer en instans av den detekterte typen ut i tillegg til av det som er igjen av strengen. En token lages ved hjelp av strengen som ble hentet ut og linjenummeret den ble funnet på. Dette settes sammen med det rekursive resultatet av resten av strengen, slik at resultatet vil bli en liste med TokenAtLine. Linjenummeret begynner på 0 og økes hver gang et linjeskift blir funnet. Mellomrom mellom tokenene leses ikke inn som en token.}\\


Prosessen for å avgjøre hvilken type de ulike syntaktiske elementene og reserverte ordene er gjøres i funksjonen determineTokTypeForReserved, som finnes i figur \ref{fig:determineTokTypeReserved}. Funksjonen oppretter en token av korrekt type ved å teste om den innsendte strengen finnes i en av listene over de ulike reserverte symbolene.  Listene er definert på toppnivå i Scanner-strukturen. Operasjonen med å teste en streng finnes i en liste gjøres av funksjonen ListUtil.member. Denne funksjonen finnes i figur \ref{fig:listMember}. Legg merke til at funksjonen ikke har en argumentliste definert inne i parenteser, separert av komma, men heller separerer argumentene med mellomrom, uten parenteser. Denne måten å definere parameterlisten på medfører at funksjonen er \textit{curryed}. En funksjon som er curryed vil ta imot ett argument om gangen og produsere en ny funksjon som tar imot resten. Konsekvensen av dette er at den ikke behøver å ta imot alle argumentene samtidig. På linje to i figur \ref{fig:determineTokTypeReserved} kan man se at funksjonen blir kalt på, men bare med ett parameter (elementet man skal undersøke om finnes i listen). Resultatet av dette vil være en ny funksjon som tar imot en liste og deretter kjører funksjons-kroppen , dersom den blir kalt på. Denne funksjonen blir  lagret i variabelen \textit{tComparator}. At man kan ta vare på funksjonen der verdien er gitt og deretter benytte den på ulike lister, gjør graden av gjenbruk større og man vil derfor kunne redusere duplisert kode. Nå trenger ikke verdien som skal testes om finnes i en liste å sendes inn for hvert funksjonskall. Currying er netopp nyttig for situasjoner slik som denne: Å ta en generell funksjon og deretter gjøre den mer spesifikk slik at den kan gjenbrukes i mer spesifikke tilfeller. Funksjoner som er curried blir muliggjort av first-class-functions, siden dette innebærer at en funksjon kan returnere en annen funksjon. 

\begin{figure}[H]
\caption{Funksjon som oppretter en token av en bestemt type basert på hvilken type reservert streng som blir sendt inn. (Standard ML)}
\label{fig:determineTokTypeReserved}
\begin{minted}{sml}
fun determineTokTypeForReserved(s:string):Token =
  let val tComparator = ListUtil.member(s)
  in
    if tComparator keywords then Keyword(s)
    else if tComparator functions then Function(s)
    else if tComparator pipeFunctions then PipeFunction(s)
    else if tComparator operators then Symbol(Operator(s))
    else if tComparator predicateOperators then Symbol(PredicateOperator(s))
    else if tComparator syntaxSymbols then Symbol(SyntaxSymbol(s))
    else Identifier(s)
  end

\end{minted}
\end{figure}

\begin{figure}[H]
\caption{Funksjon som tester om et element finnes i en liste. (Standard ML)}
\label{fig:listMember}
\begin{minted}{sml}
fun member(x) l = List.exists (fn elem => elem = x) l
\end{minted}
\end{figure}

\section{Verktøy-biblioteker}
Gjennom utviklingen har modularitet vært et viktig mål. Ønsket var at så mye som mulig av koden skulle være enkeltstående funksjoner som kunne benyttes i mange ulike sammenhenger. Dette ble muliggjort ved å flytte store deler av det som blir utført til fire ulike verktøy-bibliotek: Ett for generelle funksjoner,  et for listefunksjoner,  et for funksjoner relatert til tokens og et for funksjoner relatert til tolkning av strenger og produksjon av tokens(slik som å hente ut det første tallet fra en streng).

Avhengighetene til verktøy-bibliotekene har blitt holdt på et minimum. Verktøybibliotekene er kun avhengige av hverandre og de to bibliotekene som bruker tokens, strukturen for tokens. Siden avhengighetene er små og funksjonene er forsøkt blitt implementert på en generell måte, vil de kunne bli grenbrukt i mange ulike kontekster. Eksempelvis blir en rekke av listefunksjonene brukt i mange ulike sammenhenger. Flere av listefunksjonene er høyere-ordens-funksjoner ved at de tar imot en operasjon som skal utføres på hvert enkelt element. Et eksempel på en slik funksjon finnes i figur \ref{fig:takeWhile}. Bruken av funksjoner som argument gjør at funksjonen blir mer abstrakt og dermed også mulighetene for gjenbruk større.

Bruken av små funksjoner, gjerne der argumentene er andre funksjoner er svært vanlig innen funksjonell programmering.  Denne typen funksjoner er enkle å arbeide med, både fordi de er generelle og fordi de ofte er enkle å forstå. Undertegnede har også opplevd at det er lett å sette sammen slike funksjoner til større eller mer spesialiserte varianter. Hvis funksjonene  er rene blir det desto enklere. I tillegg kan man argumentere for at bruk av små funksjoner også kan gi koden større semantisk verdi ved at en spesifikk kodeblokk eller fremgangsmåte får et navn og ett sett med definerte parametere. Et annet aspekt er at denne typen funksjoner i mange tilfeller er enkle å teste.

\begin{figure}[H]
\caption{En funksjon for å hente elementer fra en liste over i en ny liste så lenge et predikat for elementet er sant.}
\label{fig:takeWhile}
\begin{minted}{sml}
fun takeWhile(l:'a list, pred:('a->bool)) =
  case l of
      [] => [] 
     |(x::xs) => if pred(x) then x::takeWhile(xs,pred) 
                 else []
\end{minted}
\end{figure}
\textit{Funksjonen er definert slik at en tom innsendt liste vil gi en tom liste. Dersom listen ikke er tom finnes to scenarioer: 
\begin{enumerate}
\item Predikatet stemmer for gjeldende element:   gjeldende element satt sammen med den rekursive løsningen av resten av lista blir returnert 
\item Predikatet stemner ikke: En tom liste blir returnert
\end{enumerate}
}

\section{Data og metadata}
Det har vært et mål med programmet at dataen og spørringene skal basere seg på at kolonnene har statiske typer. For lagringen innebærer dette at typen for hver kolonne er definert i metadatafilen til tabellen og at alle kolonne i alle rader må ha korrekt type. Dette innebærer også at en kolonne alltid må ha verdier av samme type i samme tabell hvis man skal kunne gjennomføre en spørring. For spørringene innebærer det at pipe-funksjonene kun fungerer på kolonner av korrekt type. Det innebærer også at to kolonner av ulik type ikke kan bli merget. Denne typesikkerheten er ment å gjøre systemet mer robust og gjør det også mulig å gi meningsfulle og relevante tilbakemeldinger fremfor at programmet stanser med en feilmelding fra selve runtime-systemet, noe som kunne ha skjedd dersom typen til kolonnene ikke var fastsatt. Dersom data-filen blir korrupt vil dette også være enklere å oppdage når alle kolonnene har en type. Metadatafilen styrer også om en kolonne kan være tom eller ikke. Hvis den er tom blir en gitt standardverdi benyttet.

\subsection*{Metadata}
Informasjon om hver enkelt tabell ligger lagret i en separat fil. Årsaken til at dataen og metadataen ikke ligger i samme fil er at det blir enklere å kun lese inn den informasjonen som er nødvendig. Eksempelvis vil det kun være nødvendig å lese inn metadataen for å sette inn ny data. Metadatafilen inneholder navn på de ulike kolonnene i tillegg til typen for kolonnen og eventuelt en standardverdi. 
Systemet er satt opp slik at hver tabell har en metadatafil med samme navn som tabellen, men med fil-endelsen {\qq}.md{\qq} i stedet for .dat. Se  seksjon \ref{sec:dataOgMetadata} for hvordan syntaksen til metadatafilen ser ut og eksempler på en slik fil.

Den fastsatte syntaksen for metadata gjør det relativt enkelt å hente ut de ulike kolonnene.Metadataen blir parset ved å dele opp innholdet fra metadatafilen i kolonner. Hvert kolonne vil da bli ett element  i en liste. Deretter blir metadataen for hver enkelt kolonne parset separat. Kolonnen blir igjen delt opp i  sub-deler- også her til en liste. Pattern-matching gjør det enkelt å behandle de ulike scenariene med tanke på om sub-delene tyder på en kolonne med standardverdi eller ikke, eller en feilformatert kolonne. Siden elementene i listen tilsvarer de ulike sub-kolonnene kan man undersøke listens struktur for å avgjøre typen. Ved hjelp av pattern-matching kan man både teste for struktur og hente ut ønskede verdier, noe man kan argumentere for at  gir kompakt og lesbar kode. Se figur \ref{fig:parseSingleField} for den aktuelle kodesnutten. For å holde på metadata for en enkelt kolonne benyttes en datatype med to ulike typekonstruktører, en for en kolonne med standardverdi og en for en kolonne uten. Se figur \ref{fig:datatypeFieldInfo} for hvordan denne datatypen er satt sammen. Hver enkelt behandlet kolonne med metadata blir lagt til i en felles liste. I listen vil første element tilsvare den første kolonnen i datafilen, det andre elementet den andre kolonnen, osv.  Avhengig av hva som blir funnet i metadatafilen blir en standardverdi for kolonnen satt. Standardverdien må også være av samme type som kolonnen sin type.

\begin{figure}[H]
\caption{Uttdrag fra funksjon(parseSingleField) for å hente ut metadata for en enkelt kolonne (Standard ML)}
\label{fig:parseSingleField}
\begin{minted}{sml}
val info = Util.splitStr(Util.tlString(rest), #",")
      in  case info of  
          (*Håndterer kolonne med standardverdi*)
          [typeStr,defValStr] =>  
         ...
         
         (*Håndterer kolonne uten standardverdi*)
         |[type_] => 
         ...
           
         (*Håndterer ugyldig syntaks*)
        |other => raise ErrorHandler.malformedMetadata("type OR type,default value", ListUtil.listToStr(other
\end{minted}
\end{figure}
\begin{figure}[H]
\caption{Datatyper for å lagre metadata for én kolonne (Standard ML)}
\label{fig:datatypeFieldInfo}
\begin{minted}{sml}
datatype Type = STRING | NUMBER | BOOL
datatype FieldInfo = fieldInfoNoDefault of string * Type |
                    fieldInfoDefault of string * Type * litteral

\end{minted}
\end{figure}
\textit{Merk: litteral er definert i Token-strukturen og er enten av type String(s), Number(n) eller Bool(b)}

\subsection*{Data}
Hver tabell ligger i en datafil med filnavn tilsvarende tabellnavnet og  filendelsen  {\qq}.dat{\qq}.  Filen har CSV-syntaks. Se seksjon \ref{sec:dataOgMetadata} for hvordan syntaksen er utformet og eksempel på hvordan en datafil kan se ut.

For innlasting av data må metadatafilen ha blitt lastet inn. Dette er for å kunne kople de ulike delene i datafilen til kolonnenavnene og å kunne gjennomføre typesjekk av dataen. Dataen blir først delt opp i rader ved å splitte på linjeskift. Hver enkelt rad blir behandlet for seg i funksjonene i figur \ref{fig:mapFields} og  \ref{fig:mapSingleField}. I den første figuren brukes to lister til å lese inn data: En med datafeltene for raden og en med metadata om de ulike kolonnene. Siden rekkefølgen og antallet på elementene (forhåpentligvis) er likt i begge listene, vil f.eks. element nr. 0 i metadatalisten tilsvare element nr. 0 i datalisten, osv. Denne egenskapen gjør det mulig å gå gjennom begge listene samtidig. For å avgjøre metadatatype(med eller uten standardverdi) og sette verdi til feltet er det ønskelig å kunne teste strukturen  og hente ut data fra begge listene. Til dette benyttes pattern-matching. Pattern-matching lar deg definere en rekke mønstre for struktur og navngi de ulike delene i mønsteret. Når koden kjører vil det første passende mønsteret bli valgt og de ulike delene bli navngitt. Muligheten for testing og uthenting i ett enkelt steg kan man argumentere for at gir kompakt og samtidig lesbar kode. Alternativet hadde kanskje vært å brukt en samling if-tester for å teste struktur og deretter hentet ut de ulike delene ekspisitt ved hjelp av funksjoner, slik som list.get(\textit{index}) i Java. Pattern-matching finnes også i ikke-funksjonelle språk, men blir mer brukt i de funksjonelle. Litt av grunnen til dette kan være at pattern-matching passer godt i den deklarative stilen, der man ikke definerer steg eller programflyt, men heller mønstre/regler, som tidligere nevnt.

Funksjonen i figur \ref{fig:mapSingleField} leser inn ett enkelt felt/celle med data. I denne operasjonen kan man støte på scenarioet der det ikke fantes noe data i det innleste feltet. Det er derfor ønskelig å kunne indikere muligheten for et tomt felt. Til dette benyttes en spesiell innebygget datatype kalt \textit{option}. Denne datatypen har to ulike typekonstruktører som indikerer om en konstant  har en verdi(SOME) eller er tom(NONE). Man kan trekke en parallell til bruken av \textit{null} i språk som Java for å indikere tomhet, men opinion  har en mer definert  semantikk. Dersom en konstant er av type option får man med en gang innsikt i at den muligens kan være tom. At den er pakket inn i en datatype betyr også at verdien ikke kan hentes direkte men at  pattern-matching må benyttes. På den måten kan man unngå en vanlig situasjon som kan oppstå i språk som Java: En variabel har null som verdi og skal benyttes et helt annet sted i programmet enn der verdien ble satt. Siden variabeltypen ikke indikerer muligheten for null kan man risikere at utvikleren forsøker  å bruke den i tro om at den faktisk har en verdi, og dermed krasjer programmet med en NullPointerException. Algebraiske datatyper og pattern-matching er to mekanismer i funksjonell programmering som gjør bruken og utviklingen av typer som option enkelt.

\begin{figure}[H]
\caption{Funksjon for å lese én rad med data (Standard ML)}
\label{fig:mapFields}
\begin{minted}{sml}
fun mapFields(
    fields:string list, metadata:MetadataParser.FieldInfo list,
    map:Tok.litteral StrMap.Map, lineNo:int, filename:string):Tok.litteral StrMap.Map = 
  case (metadata,fields) of 
    (m::ms, f::fs) => 
      mapFields(
        fs,ms,
        parseSingleFieldIntoMap(f, m, map, lineNo, filename),
        lineNo, filename)
    |([],[]) => map
    |other => raise ErrorHandler.dataNotMatchingMetadata(filename)

\end{minted}
\end{figure}
\textit{Funksjonen parser en enkelt rad med data inn i en map. Mappen har en streng som nøkkel-  kolonnenavnet, og Tok.litteral som verdi- den faktiske verdien til feltet(eller standardverdien).  Funksjonen tar imot en map(som er tom i utgangspunktet) i tillegg til en liste med rå data og en liste med metadata. Det blir brukt pattern-matching på begge listene samtidig, noe som også reflekteres på mønstrene. Hvis  begge listene har flere elementer igjen blir første element i begge  i tillegg til map sendt til parseSingleField for å lese inn det aktuelle feltet. Dette funksjonskallet vil returnere mapen med ett nytt felt lagt til. mapFiels kalles rekursivt med denne mappen og resten av de to listene. Hvis det tomt for felter i begge listene er alle kolonner innlest, noe som betyr at funksjonen ferdig. Når dette skjer vil mapen med innlest data bli returnert. Hvis antall felter i de to listene er ulikt vil den ene listen bli tom før den andre. Denne situasjonen blir behandlet i det tredje mønsteret vil resultere i en exception.}
\begin{figure}[H]
\caption{Funksjon for å lese inn ett felt med data (Standard ML)}
\label{fig:mapSingleField}
\begin{minted}{sml}
fun parseSingleFieldIntoMap(
      field:string, metadata:MetadataParser.FieldInfo, 
      map:Tok.litteral StrMap.Map, lineNo:int,filename:string) =

      let val fieldType = MetadataParser.getFieldType(metadata)
          val fieldName = MetadataParser.getFieldName(metadata)
          val fieldValueOption = getLitteralFromType(field,fieldType,lineNo,filename)
      in case metadata of
         fieldInfoNoDefault(_,_)  => (case fieldValueOption of
                                      SOME(value) => StrMap.insert(map, fieldName, value)
                                     |NONE => raise ErrorHandler.missingData(
                                               filename, lineNo))
        |infoDef as fieldInfoDefault(_,_,_) => (case fieldValueOption of
                                      SOME(value) => StrMap.insert(map, fieldName, value)
                                     |NONE =>
                                          StrMap.insert(
                                              map, fieldName,
                                              getDefaultVal(infoDef)))
      end

\end{minted}
\end{figure}

\textit{Funksjonen leser inn et enkelt felt med data inn i en map. Feltets faktiske verdi og en eventuell lagret standardverdi brukes for å bestemme verdien som blir satt inn i mapen. Har feltet verdi, blir denne brukt. Hvis feltet er tomt og det finnes en standardverdi vil denne bli brukt . Dersom feltet er tomt og det ikke finnes en standardverdi vil en exception bli kastet. Siden et felt kan være tomt benyttes en option. Dersom optionen er SOME(val) har feltet fra datafilen innhold, men dersom den er NONE er feltet tomt. Nøkkelordet {\qq}as{\qq} brukes for å fange hele mønsteret det testes for.}
\section{Spørringer}
Koden for spørringer går i grove trekk ut på å skaffe en oversikt over de ulike aspektene i spørringen(hvilke aliaser finnes, hvilke tabeller som skal merges, hvilke kolonner som skal skrives ut, hvilke pipefunksjoner som skal benyttes, osv.) for deretter å benytte denne oversikten til å hente ut ønsket data, transformere den og formatere den, på ønsket måte.

Programmet startes ved at brukeren kjører kommandoen for programmet og sender med et filnavn, som da er den filen spørringen ligger på. Spørrefilen blir lest og matet inn til funksjonen i figur \ref{fig:runQuery} . Denne funksjonen binder de ulike aspektene knyttet til  datauthenting, transformering og formatering sammen og vil produsere resultatet av spørringen i strengformat. Resultatet fra spørringen vil til slutt bli skrevet ut.

\begin{figure}[H]
\caption{Funksjon for å utføre hele spørringen, fra spørringen i strengformat til utputen i strnegformat (Standard ML)}
\label{fig:runQuery}
\begin{minted}{sml}
fun runQuery(q:string):string =
  let
    val queryParts = q |> trimAndScan |> splitToksIntoQueryParts
    val from = #from queryParts
    val merge = #merge queryParts
    val output = #output queryParts
    val filter = #filter queryParts

    (*Gets information about what data should be outputted and how it should be outputted and
    transformed*)
    val mergeInfo = getMergeInfo( (List.map TokUtil.tokAtLineToTok merge),getFirstLineNo(merge))
    val outputToks = TokUtil.listOfTokenAtLineToToks(output)
    val tablesAndAliasesRequested = getTableAndAliasnames(from)
    val outputAndPipeList = getOutputAndPipeList(outputToks,getFirstLineNo(output))

    (*Gets data*)
    val mapOfTablesToData = loadRequestedTables(tablesAndAliasesRequested)
    val mergedData = performMerge(tablesAndAliasesRequested, mapOfTablesToData, mergeInfo)

    (*Outputs data*)
    val output = getOutputAndFormat(outputAndPipeList,mergedData,getFirstLineNo(output))

  in  output
  end

\end{minted}
\end{figure}
Funksjonen over kan sies å gå litt mot prinsippet om at en funksjon kun bør gjøre én ting (et prinsipp som er viktig i flere programmeringsparadigmer). Likevel er det muligens ikke  et stort problem i praksis siden denne delen av databasen antakelig ikke vil bli gjenbrukt eller implementert på ulike måter i fremtiden. Hadde flere implementeringer og gjenbrukbarhet vært viktige mål kunne man med fordel ha gjort funksjonen mer modulær.

På den tredje linjen i funksjonen kan man se at {\qq}|>{\qq} blir brukt. Dette er en egenlaget operator som lar deg benytte funksjoner i en pipeline, og den blir brukt på tvers av databasen for å neste funksjonskall på en ryddigere måte. Siden Standard ML har relativt liberale regler på funksjonsnavn er  {\qq}|>{\qq} egentlig en ordinær funksjon som kan kalles med infix-syntax. . I StandardML skiller man ikke mellom operatorer og funksjoner, noe som f.eks. betyr at operatorer som + og - egentlig er implementert som funksjoner. Likevel vil teksten referere til dette som en operator siden virkemåten er lik. Definisjonen på  {\qq}|>{\qq} finnes i figur \ref{fig:pipeOperator}. Av figuren kan man også se at  operator-predesensen blir satt til 1, men dette tallet er ikke vesentlig i denne sammenhengen. Deretter kan man se at den forventer to argumenter- f og x på hver side av operatoren. Siden funksjonell programmering støtter første-klasses funksjoner er det ikke noe i veien for at f er en  funksjon. Av funksjonssignaturen ser man at f må være en funksjon som tar imot en verdi av type 'a og returnerer en verdi av type 'b.  Merket før a og b innebærer at a og b er typevariabler, noe som betyr at typene er polymorfe. Dette innebærer at de ikke er satt på forhånd, men at de settes dynamisk hver gang funksjonen kalles på. 'a vi da få sin type satt til typen til x. Alle andre verdier satt til type 'a må da ha samme type som typen til x. At funksjonen krever ett argument som også er av type 'a betyr derfor at funksjonen må kunne ta imot x. Typevariabler gir mulighet for svært gjenbrukbar kode og  gjør det samtidig mulig å ha høy typesikkerhet. Man kan trekke en parallell mellom Standard ML sine polymorfiske typer og  generics i Java og C\#, med den forskjellen at typene nødvendigvis ikke trenger å annoteres i Standard ML, men kan utledes av kompilatoren. 

Funksjonens kropp røper at operatoren egentlig kun er syntaktisk sukker og benytter vanlig funksjons-kalling bak kulissene. Likevel kan det argumenteres for at operatoren kan gi mer lesbar kode og at den faktiske dataflyten blir enklere å tyde utifra hvordan koden ser ut. Fordelene kommer spesielt tydelig frem når antall nestede funksjonskall blir høyt. På den andre siden har operatoren en stor begrensning: Funksjonene i pipelinen er nemlig låst til å kun ta imot ett argument.

For tilfellet  i figur \ref{fig:runQuery} vil operatoren sette sammen funksjonskallene på måten illustrert i figur \ref{fig:pipeOperatorUsage}. Under kjøring vil q først bli sendt til \textit{trimAndScan} og deretter vil resultatet fra denne funksjonen sendes med til \textit{splitTokensIntoParts}. Resultatet fra funksjonekallene er at spørringen vil bli delt opp i tokens og  deretter  i de ulike del-spørringene: from, filter, while, merge og output. 


\begin{figure}[H]
\caption{Operator for å bruke funksjoner i en pipeline}
\label{fig:pipeOperator}
\begin{minted}{sml}
infix 3 |>  
fun (x:'a) |> (f:('a->'b)) = f x
\end{minted}
\end{figure}


\begin{figure}[H]
\caption{Virkemåte til |> operatoren}
\label{fig:pipeOperatorUsage}
\begin{minted}{text}
1. q |> trimAndScan |> splitToksIntoQueryParts 
2. (trimAndScan (q)) |> splitToksIntoQueryParts
3. splitToksIntoQueryParts(trimAndScan(q))
\end{minted}
\end{figure}

Etter oppdelingen hentes en oversikt over hvilke tabeller som eventuelt skal merges ved hjelp av funksjonen \textit{getMergeInfo}. Denne funksjonen finnes i figur \ref{fig:getMergeInfo}. Funksjonen er satt til å returnere \textit{mergeInfo option} siden det ikke er sikkert at merge er brukt. \textit{mergeInfo} er en typealias til en assosiativ liste av typen: \textit{{table1:string, table2:string, mergeCol:string} }. En liste med tokens knyttet til merge-delen av spørringen blir tatt imot som parameter. Dersom listen med tokens er tom, altså at brukeren ikke benyttet merge, returneres NONE. Hvis brukeren derimot benyttet merge kan  det f.eks se  slik ut: \textit{merge employee and department using departmentID}. Dette sjekkes i de neste reglene. Regel nr. 2  tester om tokene følger den korrekte syntaksen for merging og henter samtidig ut relevant informasjon, slik som navnene på tabellene. Den tredje regelen blir valgt dersom del-spørringen verken var tom eller hadde korrekt syntaks, noe som betyr at den var ugyldig. Bruk av pattern-maching for å tolke spørringer blir brukt en rekke steder rundt om i programkoden. Undertegnede har  lagt merke til hvor enkelt pattern-matching gjør denne type jobber og gir kode som er kompakt og samtidig lesbar. Muligens er den gode støtten for sofistikert pattern-matching (og algebraiske datatyper som er tett knyttet opp til den) noe av det som gjør funksjonelle språk attraktive  for folk som lager kompilatorer, interpretere og verktøy for semantisk analyse. I det funksjonelle språket Haskell er det eksempelvis laget kompilatorer/interpretere for over 30 språk!\cite{haskellCompilers}. Et eksempel på kommersiell bruk er  i Facebook, der det har blitt utviklet et verktøy for semantisk analyse av Java, C, C++ og Obejctive-C i det funksjonelle språket OCaml\cite{facebookStaticAnalyzer}.
\begin{figure}[H]
\caption{Funksjon for å hente ut informasjon om eventuelle tabeller som skal merges}
\label{fig:getMergeInfo}
\begin{minted}{sml}
fun getMergeInfo(toks:Token list, lineNo:int):mergeInfo option= 
   case toks of
     [] => NONE
    |[Identifier(t1),Keyword("and"),Identifier(t2),Keyword("using"), Identifier(mergeColumn)] =>  
       SOME({table1=t1, table2=t2, mergeCol=mergeColumn})
   |other => raise ErrorHandler.malformedQuery(...)

\end{minted}
\end{figure}
Neste skritt er å hente en oversikt/mapping mellom aliaser og tabellnavn. Funksjonen \textit{getTableAndAliasnames} utfører denne jobben og returnerer en liste med koplinger mellom aliasnavn og den faktiske tabellen. Denne koplingen er definert som en typealias: \textit{string*string}- en tuppel bestående av to strenger. Dataen til de forespurte tabellene blir deretter hentet ut og kontrollert for korrekt type ved hjelp av funksjoner fra DataParser og MetadataParser. Felter uten verdi, men med en definert standardverdi vil få den satt, men ellers blir all dataen lagret ubehandlet i en map. Implementeringen er laget slik at data fra alle kolonnene blir lastet inn. Dette betyr at også data fra kolonner som ikke skal skrives ut blir hentet ut og satt inn i mapen. Ved store datamengder vil dette kunne ha merkbare konsekvenser for ytelsen, men for mindre datafiler er problemet mindre til stedet. En annen effekt av denne måten å hente data på er at all data i de forespurte tabellene vil bli sjekket for korrekt type. Dette kan være en fordel da typefeil er noe man ofte ønsker å oppdage så tidlig som mulig og passer godt med spørrespråket sitt etablerte mål om høy typesikkerhet.

Eter dataen har blitt hentet ut blir denne brukt sammen med merge-informasjonen til å merge tabellene, hvis dett er spesifisert. Selve mergingen foregår i funksjonen matchRows. Denne funksjonen er halerekursiv. En halerekursiv funksjon kan, som omtalt i seksjon \ref{subsec:effektiivitet} bli optimalisert til normal iterasjon av kompilatoren og gi bedre ytelse, sammenliknet med konvensjonell rekursjon. I en situasjon  som denne vil halerekursjon kunne ha betydelige ytelsesfordeler, spesielt siden merging av to tabeller er en svært krevende operasjon.

\subsection{Ytelse}
Hastighet har i lang tid vært et viktig mål når programmvare skal utvikles. Enorm vekst i hardware-kraft har gjort hastighet mindre viktig, men ytelse er likevel fortsatt et viktig poeng i mange situasjoner. Funksjonell programmering har tradisjonelt hatt et rykte på seg for å gi dårligere ytelse enn tradisjonelle imperative språk, slik som f.eks C og C++. Gjennom utvikling i et funksjonelt programmeringsspråk kan man se noe av årsakene til dette. En årsak er det høye nivået av abstraksjon. Minnet blir automatisk håndtert, og de ulike mekanikkene i språket ligger ofte langt unna virkemåten til maskinvaren. Av samme grunn blir også optimalisering mer krevende. En annen årsak kan være mangel av mutering. I funksjonell programmering er løsningen for å skape nye verdier er ofte å lage en ny variant av verdien i stedet for å mutere den opprinnelige. Dette blir gjort gjennom hele programmet. Opprettelse av nye verdier og kopieringen som følger med dette kan påvirke ytelsen negativt. Redusert ytelse kan regnes som en betydelig fordel med funksjonelle språk, men man skal også være oppmerksom på stor variasjon mellom de ulike funksjonelle språkene, og at funksjonell programmering muligens kan gjøre selve utvikleren raskere \cite{fpEffective}.
\subsection*{Pipe funksjonene}



\section{Utrykks-evaluatoren}
\section{}

\chapter{Oppsummering}
Undertegnede forsøkte i dette prosjektet å implementere et spørrespråk ved hjelp av det funksjonelle språket Standard ML. Målet med prosjektet var å få kunnskap om og erfaring med funksjonell programmering. Tidsbegrensninger medførte at omfanget til spørrespråket måtte begrenses, men likevel har læringsutbyttet vært stort og undertegnede føler at prosjektet har gitt mulighet for utforskning av en rekke funksjonelle teknikker. I dette prosjektet har jeg fått kunnskap om og praktisk erfaring med funksjonell programmering, i konteksten av utvikling et større prosjekt. Bruk av funksjonelle språk tilhører unntakene i arbeidslivet, men det kan likevel argumenteres for at erfaring med utvikling i et slikt språk kan gi kunnskap og kjennskap til funksjonelle teknikker som man kan ta med seg inn i språk av andre paradigmer. Mer bruk av uforandelige variabler vil f.eks være en enorm fordel hvis man skal jobbe med systemer der concurrency er viktig. Bruk av rene funksjoner vil gjøre koden mer oversiktelig og gjenbruk enklere. Kunnskap og erfaring om rekursjon vil være en stor fordel hvis man skal arbeide med trær.  Man kan derfor mene at funksjonelle språk kan være en god erfaring som kan bidra til å utvikle programmeringsferdigheter.

Dette er et prosjekt som kan sies å ha stort potensiale for videre utvikling. Man kunne ha brukt tid på å optimalisere spørringene og lagringen av dataen, muligens kunne en form for komprimering for lagringen ha vært brukt. Selve spørrespråket kunne ha blitt rikere, f.eks med støtte for regulære uttrykk for å filtrere data. Både komprimering og implementering av en motor for tolkning av regulærutrykk kunne ha vært svært interessant å utvikle, siden dette er områder undertegnede ikke har arbeidet med tidligere. Likevel ville antakeligvis filter-delen med ordinære logiske uttrykk ha blitt implementert først, siden den er såpass essensiell for et spørrespråk.Her skulle også uttrykksevaluatoren ha blitt brukt. For bredere bruksområde kunne det vært stilig med valg om hvordan outputen skulle ha blitt formatert, f.eks. kunne den også ha vært skrevet ut på  csv-format eller i form av en HTML-tabell.

Ikke sikkert man vil bruke et funksjonelt språk i arbeidslivet, men man kan ta med seg funksjonelle teknikker og oppnå fordeler. Immutability-enklere for concurrency. Rene funksjoner- enklere for gjenbruk. Rekursjon- enklere å arbeide med trær.

Kunnskap av mer praktisk karakter.
hva jeg prøvde på i prodsjektet
hvordan er det jeg har gjort knyttet opp mot målet 
vidre arbeid, hva rakk du ikke, ting som virker intreesannt å utforske

\chapter*{Bibiografi}
\addcontentsline{toc}{chapter}{\protect\numberline{}Bibiografi}%
\printbibliography[heading=none,sorting=none]
\end{document}
