\documentclass{report}
\input{sml.tex}
\title{En database skrevet i sml}
\author{Erlend \O
stlie}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{changepage}
\definecolor{lightGray}{rgb}{0.90, 0.90, 0.90}

\usepackage[a4paper, total={6in, 8in}]{geometry}
\usepackage{graphicx}
\usepackage{minitoc}
\usepackage{minted}
\usepackage{geometry}
\usepackage{float}
\usepackage{color, colortbl}
\usepackage{parskip}
\usepackage[norsk]{babel}
\usepackage[font=small,skip=5pt]{caption}
\newcommand*{\escape}[1]{\texttt{\textbackslash#1}}
\usepackage[format=plain,
            labelfont={it},
            textfont=it]{caption}
\captionsetup{justification=raggedright,singlelinecheck=false}
\date{\today}
\newcommand{\qq}{\symbol{34}}
\def \tabX {20pt}
\def \tabY {0pt}
\newcommand{\tab}[1]{
	\begin{adjustwidth}{\tabX}{\tabY}
	#1
	\end{adjustwidth}
}
\newcommand{\keyword}[1]{\colorbox{lightGray}{#1}}

\begin{document}

\maketitle
\dominitoc
\tableofcontents 

\chapter{Databasen}
\section{Syntaks}
For å beskrive databasens syntaks har jeg valgt å bruke kontekstfri grammatikk og Backus-Naur Form, heretter BNF, som notasjon.
\subsection*{Beskrivelse av notasjonen}
Tekst mellom vinkelparenteser (< og >) betegner navnet på en grammatikkregel hvis de står på venstre side av "::=", og henviser til en eksisterende grammatikkregel dersom den står på høyre side. Tekst inne i fnutter(" og "), er rene tekststrenger som skal skrives rett ut. Merk at tekststrengene vil bli skrevet med små bokstaver i syntaksoversikten, men at alle bokstaver endres til lower-case når spørringen leses inn, slik at hvorvidt bokstavene er store eller små ikke vil ha betydning. Pipe-symbolet(|) betyr at det finnes flere muligheter for å oppfylle regelen. Store bokstaver indikerer at selve verdien angis av brukeren selv.
Elementer omgitt av firkantparanteser ([ og ] betyr at elementet er frivillig.
\subsection{Query}
\label{sec:query}
Lar brukeren hente ut data fra en eller flere tabeller og eventuelt behandle dataene. \\

<query> ::= <from> [ <merge> ] [ <filter> ] <output> | \\

\subsubsection*{From}
<from> ::= "from" <tableList> \\
<tableList> :: =<table> | <table> "," <tableList> \\
<table> ::= TABLENAME | TABLENAME "as" ALIAS
\subsubsection*{Merge}
<merge> ::= "merge" <mergeTableList> "using" COLUMNNAME \\
<mergeTableList> ::= 
\tab{
<tablename> "and" <tablename> |  \\
<tablename> "and" <mergeTableList>
}
<tablename> ::= NAME | ALIAS
\subsubsection*{Filter}
<filter> ::= "filter" <predicateList> \\
<predicateList> ::= <predicate> | <predicate> <logicOperator> <predicateList> \\
<logicOperator> ::= "and" | "or" \\
<predicate> ::= 
\tab {
<expression> <predicateOperator> <expression> | \\
<columnName> <predicateFunction>
}
<expression> ::= ["("]<expression> <operator> <expression> [")"] | <value> \\
<operator> ::= "+" | "-" | "*" | "/" \\
<predicateOperator> ::= ">" | "<" | ">=" | "<=" | "=" | "!=" \\
<value> ::= <columnName> | LITTERAL \\
<predicateFunction> ::= <predicateFunctionName> "("<valueList>")" \\
<valueList> ::= <value> | <value> "," <valueList> \\
<predicateFunctionName> ::= "oneof" | "noneof" \\
<columnName> ::= 
\tab {
COLUMNNAME | \\
TABLENAME "." COLNAME | \\
TABLENAME "." COLNAME "." SUBCOLNAME \\
}

\subsection{Output}
Lar brukeren velge hvilke kolonner/uttrykk som skal skrives ut og eventuelle operasjoner som skal gjøres i hvert tilfelle. Hvilket kolonnenavn som blir gitt ved utskrift kan endres ved å benytte en alias(nøkkelordet named). En alias kan være spesielt aktuelt ved transformasjon på en kolonne eller ved utskrift av et uttrykk. Output støtter også pipelining av transformasjoner på dataen som skal skrives ut, men bare på en kolonne/uttrykk om gangen. Det er mulig å skrive ut flere kolonner i en enkelt operasjon, men da støttes ikke pipelining av dataene. Pipelining med flere kolonner ville både ha vært utfordrende å løse teknisk i tillegg til at oppførselen ville kunne ha forvirret brukeren. \\
\\
<output> ::= "output" <outputList> \\
<outputList> ::= <outputColumn> | <outputColumn> "," <outputList> \\
<outputColumn> ::= <expression> [<functionPipeline>] [<alias>] | <multiColumn> [<alias>] \\
<expression> ::= \textit{Se seksjon\ref{sec:query}: Filter \\}
<functionPipeline> ::= <function> | <function> "->" <functionPipeline> \\
<function> ::= "upper" | "lower" | "trimWhitespace" | "rmChar" \\
<alias> ::= "named" COLNAME \\
<multicolumn> ::= [TABLENAME"."]COLNAME".*" | [TABLENAME"."]COLNAME".{"<subcolList>}" \\
<subcolList> ::= SUBCOLNAME | SUBCOLNAME "," <subcolList> \\
\subsubsection*{Eksempel}
\textit{from Person as P, PersonWork as PW \\
		merge P and PW using personID \\
        filter department oneof("computers", "phones", "support") and \\
        salary > 100000 \\
        output name -> trimWhitespace -> capitalized,\\
        adress.\{streetName, streetNo\}
        }
\subsection{Insert}
\label{sec:insert}
Lar brukeren sette inn data i form av en eller flere rader i en tabell. Tabellen må være oprettet på forhånd. Dersom en eller flere kolonner ikke spesifiseres vil databasen enten sette kolonneverdien til standardverdien, hvis den ble spesifisert ved opprettelse av tabellen, eller gi en feilmelding dersom kolonnen ikke har noen standardverdi. For spesifisering av kolonner benyttes utelukkende navnet på kolonnen/subkolonnen.\\

<insert> ::= "insert rows into" TABLE <rowlist> \\
<rowlist> ::= <row> | row "," <rowlist> \\
<row> ::= "(" <columnValueList> ")" \\
<columnValueList> ::= 
\tab{
<columnValue> | \\
<columnValue> "," <columnValueList>
}
<columnValue> ::= <keyValue> | <subkeyValues> \\
<keyValue> ::= COLNAME ":" <expression> \\
<subkeyValues> ::= COLNAME ":\{"<keyValueList>"\}" \\
<keyValueList> ::= <keyValue> | <keyValue> "," <keyValueList> \\


\subsection{Remove}
Lar brukeren slette rader fra en tabell som stemmer med en eller flere predikater.
<remove> ::= "remove rows from" TABLENAME "WHERE" <predicateList>
<predicateList> ::= \textit{Se seksjon \ref{sec:query}: Filter}


\subsection{Update}
Lar brukeren endre verdi på eksisterende celler. Ved endring settes de kolonner som ønskes å endres på samme måte som nevnt i seksjon \ref{sec:insert} men i tilegg kan den reserverte variabelen OLD benyttes i uttrykkene å henvise til den gjeldende verdien. \\
<update> ::= "update" TABLENAME "where" <predicateList> "set" <columnValueList> \\
<predicateList> ::= \textit{Se seksjon \ref{sec:query}: Filter} \\
<columnValueList> ::= \textit{Se seksjon \ref{sec:insert}}



\subsection{Create}
\label{sec:create}
Lar brukeren opprette en ny tabell. Alle kolonene må ha datatyper spesifisert og det er mulig å la kolonnene ha en standardverdi.
\subsubsection*{Datatyper}
Databasen har tre datatyper:
\begin{itemize}
\item boolean: enten true eller false
\item number: et flyttall-nummer, men kan spesifiseres uten desimaler
\item string: en vilkårlig tekststreng
\end{itemize}
<create> ::= "create table"  TABLENAME "with columns" <columnList>\\
<columnList> ::= <column> | <column> "," <columnList>\\
<column> ::= <nameDatatype> | COLNAME ":\{"<nameDatatypeList>"\}"\\
<nameDatatype> ::= COLNAME "of" <datatype> ["default" LITTERAL] \\
<nameDatatypeList> ::= <nameDatatype> | <nameDatatype> "," \\
<datatype> ::= "string" | "boolean" | "number"\\

Eksampler på oppbrytning av de ulike delene.


\section{Lagring}
\subsection{Metadata}
Informasjon om hver enkelt tabell ligger lagret i en separat fil. Årsaken til at dataen og metadataen ikke ligger i samme fil er at det blir enklere å kun lese inn den informasjonen som er nødvendig. Eksempelvis vil det kun være nødvendig å lese inn metadataen for å sette inn ny data. Metadatafilen inneholder navn på de ulike feltene i tillegg til typen for feltet og eventuelt en standardverdi. Filen har slik syntax:

<entryList> ::= <entry> | <entry><entryList> \\
<entry> ::=  <singleEntry> | <nestedEntry> \\
<singleEntry> ::= COLNAME{\qq}\{<datatype>[,<defaultValue>]\}{\qq}  \\
<nestedEntry> ::= COLNAME{\qq}(<singleEntryList>){\qq} \\
<singleEntryList> ::= 
\tab{
<singleEntry> | \\
<singleEntry><singleEntryList> 
}
<datatype> ::= \textit{Se seksjon \ref{sec:create} }\\
<defaultValue> ::= LITTERAL \\

\subsubsection*{Eksempel}
\textit{Name\{string,"John Doe"\}Phone\{number\}Adress(StreetName\{string\}StreetNo\{number\})}

\subsection{Data}
Selve dataen lagres på et enkelt, CSV-linkende format. Formatet er valgt for å være enkelt å lese for både mennesker og maskiner i tillegg til å ta lite plass og være flyttbart. Siden lagringen benytter plassering for å bestemme de ulike feltene, er programmet avhengig av metadatafilen for å kunne skille mellom de ulike feltene. Et felt kan være tomt. Hvis en standardverdi er satt benyttes denne. Hvis ikke vil programmet avslutte med en feilmelding. Filen har slik syntax:\\
<rowList> ::= <row> | <row>{\qq}\escape{n}{\qq}<rowList> \\
<row> ::= <columnList> \\
<columnList> ::= <column> | <column>{\qq};{\qq}<columnList>\\
<column> ::= <flat> | <nested>\\
<flat> ::= LITTERAL\\
<nested> ::= "(<flatList>)"\\
<flatList> ::= <flat> | <flat>{\qq};{\qq}<flatList>\\

\subsubsection*{Eksempel}
\textit{{\qq}Per Olsen{\qq};67284771;({\qq}Einerveien{\qq};18)\\
        ;88341821;({\qq}Lierveien{\qq};2)}
\chapter{Funskjonell Progammering}
\minitoc
\section{Hva er funksjonell programmering?}
Si noe om hva man legger i imperativ/objektorientert
en teknikk, ikke et språk. Muligheten for funksjonell programmering i imperative språk, eksemplifisere med c.
\section{Konstanter fremfor variabler}
\section{Rekursjon}
\subsection*{Hva er rekursjon?}
Rekursjon går ut på at en funksjon kaller seg selv, noe som innebærer at funksjonen bruker seg selv som et steg på veien til løsningen av et problem. I noen tilfeller vil rekursjonen oppføre seg litt som en konvensjonell løkke, men i andre tilfeller vil rekursjonens virkemåte være grunnleggende ulik. Spesielt den siste måten kan man argumentere for at lar deg løse problemer på en mye mer elegant måte enn tilfellet hadde vært uten rekursjon, selv om problemet fortsatt kan løses iterativt. Rapporten kommer tilbake til de to nevnte virkemåtene seinere.\\ \\
Rekursjon er en teknikk som er tilgjengelig i så godt som alle moderne programmeringsspråk. Grunnen er at de fleste språk har en kall-stack og at det i prinsipp ikke spiller noen rolle hvilken funksjon som blir kalt på. Språk som FORTRAN, støtter for eksempel ikke rekursjon av denne grunnen[FIKSE]. På tross av at tilgjengeligheten til teknikken blir den ofte mye mer brukt i forbindelse med funksjonell programmering enn den gjør i imperativ. Årsakene til dette er flere men blant annet er rekursjon i enkelte språk er eneste mulighet for å gjenta kode på en organisert måte(løkker) i tillegg til at rekursjon er et uvurderlig verktøy i den funksjonelle verktøykassen. Rekursjon og funksjonell programmering går på mange måter hånd i hånd.
\subsection*{Hvorfor rekursjon i funksjonell programmering?}
En måte å angripe problemet på er å heller spørre: Hvorfor ikke løkker i funksjonell programmering? Mange av grunnene til dette kommer fra løkkenes natur og virkemåte. En løkke består som regel av en kodeblokk og en betingelse som sjekkes for hver gang kodeblokken eventuelt blir gjentatt. De fleste språkene har også en løkkevariant der initialisering av løkkevariabler, mutering av variabler og løkke-betingelsen er kombinert. Uavhengig av hvilken løkke-variant man benytter så er det gitt at uttrykket i betingelsen må få verdien endret på en eller annen måte, hvis man vil unngå at løkken kjører ut i det uendelige. Eneste mulighetene for dette blir enten at uttrykket bruker en ikke-deterministisk funksjon (f.eks en randomfunskjon) eller mer vanlig, at en eller flere variabler muteres inne i kodeblokken, eller i betingelseblokken hvis man bruker for-løkker. Løkkenes muterende natur innebærer at løkker strider mot grunnleggende prinsipper i funksjonell programmering. Alternativet blir derfor rekursjon. Det må også legges til at mange moderne språk tilbyr iterator-baserte løkker, f.eks ved bruk av \textit{for(Type navn: liste) }i Java, som er mye mer funksjonelle i natur.
\subsection*{Fordeler og ulemper}
\subsubsection*{Lesbarhet og forståelse av koden}
Denne seksjonen skal ta for seg en algoritme for å finne det n-te Fibonacci-tallet (der n > 0) og se hvordan iterasjon og rekursjon vil kunne påvirke lesbarheten og semantikken til den tilhørende koden.

\label{fig:fibIterJava}
\begin{figure}[H]
\begin{minted}{java}
  public static int fib(int n){
          int prev, curr;
          prev = curr = 1;

          if(n <= 1) return 1;

          for(int no = 3; no <= n; no++){
              int tmp = curr;
              curr += prev;
              prev = tmp;
          }

          return curr;
      }
\end{minted} 
\caption{Fibonacci, iterativ (Java)}
\end{figure}

\begin{figure}[H]

\begin{minted}{java}
public static int fib(int n){
	if (n <= 1) return 1;
    
    return fib(n-1) + fib(n-2);
}
\end{minted}
\caption{Fibonacci, rekursiv (Java)}
\end{figure}


Ikke bare er den rekursive varianten kortere med tanke på antall linjer kode, men den angriper også problemet på en grunnleggende annerledes måte. I stedet for å eksplisitt definere de ulike stegene i algoritmen, bruker man en mer deklarativ stil. I deklarativ programmering kan utvikleren konsentrere seg om \textit{hva} som skal bli beregnet, uten nødvendigvis å måtte tenke på eller definere \textit{hvordan} dette skal gjøres(Torgersson, 1996, s. 1). Sagt på en annen måte- deklarativ programmering innebærer at utvikleren definerer logikken, men ikke programflyten. Dette medfører at elementer som if-tester, løkker, og nøkkelord som \textit{continue} og \textit{break} ikke benyttes. SQL er kanskje det mest kjente eksempelet på deklarativ programmering. Regulæruttrykk, selv om det ikke er et programmeringsspråk men heller et domespesifikt språk, er også et godt eksempel. Den deklarative programmeringen lar utvikleren operere på et høyere nivå av abstraksjon, noe som kan bidra til kode som både er enklere å lese og forstå fordi tekniske implementerings-detaljer blir utelatt. Pattern-macthing er også en mekanisme som kan sies å tilhøre denne stilen, og vil bli diskutert senere i rapporten. Knyttet opp mot rekursjon vil den deklarative stilen innebære at utvikleren ikke trenger å definere hvordan kodeblokkene blir gjentatt(gjennom løkker og logikken som styrer løkken). I mindre trivielle eksempler slik som traversering av rekursive strukturer som binær- og filtrær og divide-and-qonqeur algoritmer(slik som quicksort) vil fordelene komme enda tydeligere frem. Dette er fordi den rekursiv løsningen vil abstrahere bort konseptet med en stack som utvikleren eksplisitt må håndtere og dermed også øke lesbarheten betraktelig.\\
\\
På den andre siden kan deklarativ programmering også gi utvikleren et mer utydelig inntrykk av hva som faktisk foregår. Dette er fordi den faktiske logikken og programflyten blir gjemt bort under mange lag med abstraksjon. Mulighetene for optimalisering og spesialtilpassing blir også mindre av samme grunn. Et annet aspekt er at høytnivåkonseptene som følger med deklarativ programmering kan være utfordrende å forstå siden mange av begrepene er svært abstrakte og fordi det kan være vanskelig å finne en konkret parallell i den virkelige verden. For eksempel kan en løkke være enklere å forstå enn rekursjon og en iterativ variant som finner summen av elementene i en liste være mer intuitiv enn å bruke \textit{reduce/fold}.\\
\\
Den deklarative stilen i det første eksempelet gjør at funksjonen vil kunne være både enklere å skrive og lese, spesielt hvis den implementeres i et mer funksjonelt språk som SML som også støtter pattern-matching på funksjoner(se figur 3) og der funksjoner også er uttrykk. Likevel krever den rekursive løsningen at utvikleren har kjennskap til og erfaring med rekursive algoritmer. Uten dette kan rekursive funksjoner være svært krevende å forstå, og ikke minst å feilsøke, spesielt rekursjon som ikke er halerekursiv eller multirekursjon. En av grunnene til dette er måten utvikleren kan få en forståelse for virkemåten til algoritmen. Ved en iterativ variant kan vedkommende gå gjennom algoritmen på en lineær eller endimensjonal måte og holde styr på tilstanden til programmet. Denne varianten vil for mange være mer naturlig og har også den fordelen at den vil kunne være enklere å feilsøke med en konvensjonell debugger. Den rekursive varianten er mer todimensjonal av natur ved at programflyten ikke bar går nedover, men også innover og utover. Dette medfører at for å gå gjennom og få en forståelse for algoritmen må man danne seg en fysisk eller mental stack og bevege seg nedover og oppover kalltreet. Det skal sies at dersom man har kjennskap til rekursjon, vil antakelig ikke dette være nødvendig. Når det kommer til debugging vil en konvensjonell debugger kunne være en dårlig kombinasjon, mens en debugger som skrive ut kalltreet antakelig vil være mer aktuell. \\
\label{fig:fibRecML}
\begin{figure}
\begin{minted}{sml}
fun fib 0 = 1
   |fib 1 = 1
   |fib n = fib(n-1) + fib(n-2)
\end{minted}
\caption{Fibbonaci, rekursiv (Standard ML)}
\end{figure}

\subsection*{Effektivitet}
Rekursjon blir ofte foretrukket fremfor løkker i en rekke funksjonelle språk, mens teknikken ofte er reservert til spesielle tilfeller slik som traversering av trær i mer imperative språk. En betydelig grunn  til dette er måten de ulike kompilatorene og interpreterne implementerer rekursjonen, spesifikt om de tilbyr hale-rekursjon-optimalisering eller ikke.

\label{fig:sumSML}
\begin{figure}[H]
\begin{minted}{sml}
fun sum [] = 0
   |sum(x::xs) = x + sum(xs)
\end{minted}
\caption{Sum av elementene i en liste (Standard ML)}
\end{figure}
Funksjonen legger rekursivt sammen verdien til første element(x) pluss summen til resten av lista(xs). Dersom lista er tom er summen 0.
Et kalltre for listen \textit{[1,2,3,4]} vil se slik ut:

\label{fig:sumSMLKalltre}
\begin{figure}[H]
\begin{minted}{sml}
sum([1,2,3,4])
	1 + sum([2,3,4])
    	2 + sum([3,4])
        	3 + sum([4])
            	4 + sum([])
                	0
                 4
            7
        9
    10
\end{minted}
\caption{Kalltre for figur \ref{fig:sumSML} }
\end{figure}

For hvert rekursive kall opprettes en stackframe som lagres på kallstacken. Inne i hver stackframe lagres blant annet parameterverdier, lokale variabler(ikke i dette tilfellet) og posisjonen i koden det skal fortsettes fra etter at funksjonen har returnert. På grunn av plusstegnet vil programmet måtte lagre alle stackframene slik at det kan returnere til det ved et senere tidspunkt og deretter summere verdiene. I dette tilfellet vil man da få laget 5 stackframes før rekursjonen trekker seg opp igjen, noe som vil medføre ekstra  minnebruk og ekstra operasjoner med å legge til og fjerne frames fra kallstacken. Dersom listen hadde vært svært lang hadde man fått svært mange stackframes, noe som potensielt kunne ha fylt opp kallstacken og i verste tilfelle medført en stack-owerflow exception. Hale-kall optimalisering vil kunne eliminere de nevnte ulempene ved å transformere enkelte former for rekursjon til vanlig iterasjon.
\\
\begin{minted}{sml}
fun sumTail(l) = 
let fun sumFrom([], summed) = summed
	   |sumFrom(x::xs, summed) = sumFrom(xs,summed + x)
in
	sumFrom(l, 0)
end
\end{minted}
For å kunne utføre hale-rekursjons-optimalisering må rekursjonen være implementert på en bestemt måte- det rekursive kallet må være det siste som utføres i funksjonen. Dette innebærer at den rekursive funksjonen kun har ett rekursivt kall, og at det ikke akkumuleres verdier ved å kalle på rekursive funksjoner slik som \textit{x + sum(xs)} i figur \ref{fig:sumSML}. Det første poenget medfører at algoritmer som naturlig implementeres med multi-rekursjon slik som traversering av trær, må bli skrevet om og få ganske annerledes logikk i forhold til løsningen med multi-rekursjon. \\

\begin{figure}[H]
\caption{Fibbonaci, halerekursiv(Standard ML)}
\label{fig:fibTailRecSML}
\begin{minted}{sml}
fun fibTail(n)= 
  let fun fibInner(n1, n2, remain) = 
      if remain <= 1 then n2  
      else fibInner(n2, n1 + n2, remain-1)
  in  
    fibInner(1, 1, n)
  end
\end{minted}
\end{figure}
Funksjonen i figur \ref{fig:fibTailRecSML} er transformert til å være halerekursiv. Den utfører samme oppgaven som i figur \ref{fig:sumSML}, men for at den skal oppfylle kravene for halerekursivitet er den blitt refaktorert til å benytte en indre funksjon og et akkumulator-parameter i stedet for plusstegnet for summering. Refaktoreringen var lite krevende, men dette er ikke alltid tilfellet. Eksempelvis måtte den refaktorerte Fibonacci-funksjonen i figur \ref{fig:fibRecML} skrives om med helt ny logikk som resulterte i figur \ref{fig:fibTailRecSML}. Hvis man sammenlikner den hale-rekursive varianten med den iterative i figur \ref{fig:fibIterJava} kan man også dessuten se tydelige likheter i logikken mellom de to variantene. \\

Siden det rekursive kallet er det siste som blir utført i en halerekursiv funksjon, trenger ikke lokale variabler eller posisjon for returnering å bli lagret.  Fordi rekursjonen aldri kommer til å trekke seg opp igjen, men kun kalle seg selv med endrede parameterverdier vil det nemlig ikke være noen grunn for at rekursjonen skal måtte gå "tilbake". På grunnlag av dette kan kompilatoren optimalisere bak kulissene slik at flere stackframes ikke opprettes og at rekursjonen i stedet blir omgjort til normal iterasjon, med de hastighetsforbedringene dette medfører. Hvis man har en kompilator som genererer Assembly vil hale-rekursjonen kunne bli konvertert til en goto, noe som vil gi svært god ytelse. Uoptimalisert rekursjon i Assembly innebærer at  stackframes må pushes og poppes i tillegg til at parameterne må kopieres(hvis man har pass-by-value slik som StandardML). Flere operasjoner medfører mer jobb for CPU-en og dermed lavere ytelse. Dersom koden blir omgjort til iterasjon vil man unngå de ekstra operasjonene og i stedet bruke ett sett med løkkevariabler som blir mutert. Standard ML er et språk der de mest populære kompilatorene har halekall-optimalisering, noe man vil kunne se tydelig utsalg for på ytelsestester.


\subsubsection*{Hastighetstester}
\begin{center}
\begin{tabular}{|r | r| r| r|}
\hline
\rowcolor{lightGray} Funksjon & Vanlig & Hale-rekursjon & Forbedring \\
\hline
sum: 100 000 & 16.6 msek & 13.3 msek & 24.8\% \\
\hline
sum: 1 million & 30.3 msek & 21.6 msek & 40\% \\
\hline
sum: 100 millioner & 182 msek & 3336 msek & 1732\% \\
\hline 
\end{tabular}
\end{center}
Vi ser av resultatene ovenfor at hale-rekursjon-optimalisering gir betydelige forbedringer med tanke på effektivitet, spesielt når problemstørrelsen øker.

\subsection*{Rekursjon i databasen}
\label{fig:skrivUtUtrykkstre}
\begin{figure}[H]
\caption{Funksjon for å lage en streng-representasjon av et uttrykkstre (Standard ML)}
\begin{minted}{sml}
 fun exprTreeToStr(exprTree: ExprTree) = 
   let fun getValue(v:TreeLitteral) = 
         case v of  
           TreeNum(n)     => Real.toString(n)
          |TreeOper(oper) => oper 
   in  
    case exprTree of
        Node(left,value,right) =>  
          format("Tree( [$], L( $ ), R( $  )", 
            [treeLitToStr(value), exprTreeToStr(left),exprTreeToStr(right)])
       |EmptyNode => ""
       |treeLit(lit) => getValue(lit) 
   end 

\end{minted}
\end{figure}
I databasen blir rekursjon benyttet hyppig. Dette har flere effekter blant annet kode som er mer kompakt og i mange tilfeller også som kan oppleves som mer lesbar. Det er forbundet en viss lærignskurve med den rekursive stilen, men etter å ha mestret teknikken føles rekursjon i mange tilfeller mer naturlig. Noen av årsaken til dette kan være at man får kode på et høyere nivå som også er mer deklarativ. Andre årsaker kan være at man deler opp problemet i stadig mindre biter og deretter løser problemet når det er svært enkelt(typisk for f.feks mergesort). I databasekoden kan man eksempelvis trekke frem en funksjon for å skrive ut et utrykkstre i denne stilen(treet til 1+2*3): \textit{ Tree( [+], L( 1.0 ), R( Tree( [*], L( 2.0 ), R( 3.0  )  )
}. Denne funksjonen benyttes til feilsøking og bruker multi-rekursjon for å traversere treet med preorder-traversering. Den rekursive delen der en streng-representasjon av treet lages gir en deklarativ definisjon av hvordan strengen skal formateres(\$ benyttes som en placeholder for der strengen skal settes inn, slik som \%s i Java og C sin \textit{printf}. Leser man koden får man en tydelig indikasjon på hvordan strengen blir: Først verdien i noden, og deretter strengrepresentasjonen rekursivt til venstre og høyre tre. Hvis samme kode skulle ha vært utført med iterasjon måtte man ha benyttet en manuell stack for å traversere treet. Effekten av dette kunne ha vært at koden hadde blitt lenger og mindre abstrakt. Som konsekvens vil dette ha kunne ført til kode som hadde vært mer krevende å skrive, lese og feilsøke. Den iterative versjonen hadde nødvendigvis heller ikke blitt mer effektiv siden man også her hadde fått en stack(riktignok styrt av programmereren).

\begin{thebibliography}{9}
\bibitem{dekRep}
http://www.cse.chalmers.se/~oloft/Papers/wm96.pdf 
\end{thebibliography}
\end{document}

