\documentclass{report}
\input{sml.tex}
\title{Funksjonell programmering gjennom utvikling av et spørrespråk}
\author{Erlend \O
stlie}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{changepage}

\usepackage[backend=biber]{biblatex}
\addbibresource{refs.bib}

\usepackage{url}
\definecolor{lightGray}{rgb}{0.90, 0.90, 0.90}

\usepackage[a4paper, total={6in, 8in}]{geometry}
\usepackage{graphicx}
\usepackage{minitoc}
\usepackage{minted}
\usepackage{geometry}
\usepackage{float}
\usepackage{color, colortbl}
\usepackage{parskip}
\usepackage[norsk]{babel}
\usepackage[font=small,skip=5pt]{caption}
\newcommand*{\escape}[1]{\texttt{\textbackslash#1}}
\usepackage[format=plain,
            labelfont={it},
            textfont=it]{caption}
\captionsetup{justification=raggedright,singlelinecheck=false}
\date{\today}
\newcommand{\qq}{\symbol{34}}
\def \tabX {20pt}
\def \tabY {0pt}
\newcommand{\tab}[1]{
	\begin{adjustwidth}{\tabX}{\tabY}
	#1
	\end{adjustwidth}
}
\newcommand{\keyword}[1]{\colorbox{lightGray}{#1}}

\begin{document}

\maketitle
\dominitoc
\tableofcontents 

\chapter*{Introduksjon}
\addcontentsline{toc}{chapter}{\protect\numberline{}Introduksjon}%
\chapter{Spørrespråkets syntax}
\section{Syntaks}
For å beskrive databasens syntaks har jeg valgt å bruke kontekstfri grammatikk og Backus-Naur Form, heretter BNF, som notasjon.
\subsection*{Beskrivelse av notasjonen}
Tekst mellom vinkelparenteser (< og >) betegner navnet på en grammatikkregel hvis de står på venstre side av {\qq}::={\qq}, og henviser til en eksisterende grammatikkregel dersom den står på høyre side. Tekst inne i fnutter({\qq} og {\qq}), er rene tekststrenger som skal skrives rett ut. Merk at tekststrengene vil bli skrevet med små bokstaver i syntaksoversikten, men at alle bokstaver endres til lower-case når spørringen leses inn, slik at hvorvidt bokstavene er store eller små ikke vil ha betydning. Pipe-symbolet(|) betyr at det finnes flere muligheter for å oppfylle regelen. Store bokstaver indikerer at selve verdien angis av brukeren selv.
Elementer omgitt av firkantparanteser ([ og ] betyr at elementet er frivillig.
\subsection{Query}
\label{sec:query}
Lar brukeren hente ut data fra en eller flere tabeller og eventuelt behandle dataene. \\

<query> ::= <from> [ <merge> ] [ <filter> ] <output> | \\

\subsubsection*{From}
<from> ::= {\qq}from{\qq} <tableList> \\
<tableList> :: =<table> | <table> {\qq},{\qq} <tableList> \\
<table> ::= TABLENAME | TABLENAME {\qq}as{\qq} ALIAS

\subsubsection*{Merge}
Lar bruker slå sammen to tabeller. Den nye tabellen {\qq}merged{\qq} vil da bli opprettet og det er denne tabellen man skal referere til i de andre delene av spørringen. Merge-tabellen er både for å motvirke forvirring hos bruker og for å gjøre inplementeringen mer rett frem.
<merge> ::= {\qq}merge{\qq} TABLENAME {\qq}and{\qq} TABLENAME {\qq}using{\qq} COLUMNNAME \\

\subsubsection*{Filter}
<filter> ::= {\qq}filter{\qq} <predicateList> \\
<predicateList> ::= <predicate> | <predicate> <logicOperator> <predicateList> \\
<logicOperator> ::= {\qq}and{\qq} | {\qq}or{\qq} \\
<predicate> ::= 
\tab {
<expression> <predicateOperator> <expression> | \\
<columnName> <predicateFunction>
}
<expression> ::= [{\qq}({\qq}]<expression> <operator> <expression> [{\qq}){\qq}] | <value> \\
<operator> ::= {\qq}+{\qq} | {\qq}-{\qq} | {\qq}*{\qq} | {\qq}/{\qq} \\
<predicateOperator> ::= {\qq}>{\qq} | {\qq}<{\qq} | {\qq}>={\qq} | {\qq}<={\qq} | {\qq}={\qq} | {\qq}!={\qq} \\
<value> ::= <columnName> | LITTERAL \\
<predicateFunction> ::= <predicateFunctionName> {\qq}({\qq}<valueList>{\qq}){\qq} \\
<valueList> ::= <value> | <value> {\qq},{\qq} <valueList> \\
<predicateFunctionName> ::= {\qq}oneof{\qq} | {\qq}noneof{\qq} \\
<columnName> ::= 
\tab {
COLUMNNAME | \\
TABLENAME {\qq}.{\qq} COLNAME | \\
}

\subsection{Output}
Lar brukeren velge hvilke kolonner/uttrykk som skal skrives ut og eventuelle operasjoner som skal gjøres i hvert tilfelle. Hvilket kolonnenavn som blir gitt ved utskrift kan endres ved å benytte en alias(nøkkelordet named). En alias kan være spesielt aktuelt ved transformasjon på en kolonne eller ved utskrift av et uttrykk. (Denne funksjonen ble det ikke tid til å implementere.) Output støtter også pipelining av transformasjoner på dataen som skal skrives ut, men bare på en kolonne/uttrykk om gangen. Det er mulig å skrive ut flere kolonner i en enkelt operasjon, men da støttes ikke pipelining av dataene. Pipelining med flere kolonner ville både ha vært utfordrende å løse teknisk i tillegg til at oppførselen ville kunne ha forvirret brukeren. Legg også merke til at dersom to tabeller benyttes i samme spørring, må spesialtabellen {\qq}merged{\qq} benyttes, som nevnt i seksjonen for merge. \\

<output> ::= {\qq}output{\qq} <outputList> \\
<outputList> ::= <output> | <output> {\qq},{\qq} <outputList> \\
<output> ::= <expression> [<functionPipeline>] [<alias>] | <columnOutput> [<alias>] \\
<expression> ::= \textit{Se seksjon\ref{sec:query}: Filter \\}
<functionPipeline> ::= <function> | <function> {\qq}->{\qq} <functionPipeline> \\
<function> ::= {\qq}upper{\qq} | {\qq}lower{\qq} | {\qq}trimWhitespace{\qq} | {\qq}rmChar{\qq} \\
<alias> ::= {\qq}named{\qq} COLNAME \\
<columnOutput> ::= [TABLENAME{\qq}.{\qq}]COLNAME{\qq}.*{\qq} | [TABLENAME{\qq}.{\qq}]COLNAME{\qq}\\
\subsubsection*{Eksempel}
\textit{from Person as P, PersonWork as PW \\
		merge P and PW using personID \\
        filter department oneof({\qq}computers{\qq}, {\qq}phones{\qq}, {\qq}support{\qq}) and \\
        salary > 100000 \\
        output merged.name -> trimWhitespace -> capitalized,\\
        merged.adress.\{streetName, streetNo\}
        }
\subsection{Insert}
\label{sec:insert}
Lar brukeren sette inn data i form av en eller flere rader i en tabell. Tabellen må være oprettet på forhånd. Dersom en eller flere kolonner ikke spesifiseres vil databasen enten sette kolonneverdien til standardverdien, hvis den ble spesifisert ved opprettelse av tabellen, eller gi en feilmelding dersom kolonnen ikke har noen standardverdi. For spesifisering av kolonner benyttes utelukkende navnet på kolonnen/subkolonnen.\\

<insert> ::= {\qq}insert rows into{\qq} TABLE <rowlist> \\
<rowlist> ::= <row> | row {\qq},{\qq} <rowlist> \\
<row> ::= {\qq}({\qq} <columnValueList> {\qq}){\qq} \\
<columnValueList> ::= 
\tab{
<columnValue> | \\
<columnValue> {\qq},{\qq} <columnValueList>
}
<columnValue> ::= <keyValue> | <subkeyValues> \\
<keyValue> ::= COLNAME {\qq}:{\qq} <expression> \\
<subkeyValues> ::= COLNAME {\qq}:\{{\qq}<keyValueList>{\qq}\}{\qq} \\
<keyValueList> ::= <keyValue> | <keyValue> {\qq},{\qq} <keyValueList> \\


\subsection{Remove}
Lar brukeren slette rader fra en tabell som stemmer med en eller flere predikater.
<remove> ::= {\qq}remove rows from{\qq} TABLENAME {\qq}WHERE{\qq} <predicateList>
<predicateList> ::= \textit{Se seksjon \ref{sec:query}: Filter}


\subsection{Update}
Lar brukeren endre verdi på eksisterende celler. Ved endring settes de kolonner som ønskes å endres på samme måte som nevnt i seksjon \ref{sec:insert} men i tilegg kan den reserverte variabelen OLD benyttes i uttrykkene å henvise til den gjeldende verdien. \\
<update> ::= {\qq}update{\qq} TABLENAME {\qq}where{\qq} <predicateList> {\qq}set{\qq} <columnValueList> \\
<predicateList> ::= \textit{Se seksjon \ref{sec:query}: Filter} \\
<columnValueList> ::= \textit{Se seksjon \ref{sec:insert}}


\subsection{Create}
\label{sec:create}
Lar brukeren opprette en ny tabell. Alle kolonene må ha datatyper spesifisert og det er mulig å la kolonnene ha en standardverdi.
\subsubsection*{Datatyper}
Databasen har tre datatyper:
\begin{itemize}
\item boolean: enten true eller false
\item number: et flyttall-nummer, men kan spesifiseres uten desimaler
\item string: en vilkårlig tekststreng
\end{itemize}
<create> ::= {\qq}create table{\qq}  TABLENAME {\qq}with columns{\qq} <columnList>\\
<columnList> ::= <column> | <column> {\qq},{\qq} <columnList>\\
<column> ::= <nameDatatype> | COLNAME {\qq}:\{{\qq}<nameDatatypeList>{\qq}\}{\qq}\\
<nameDatatype> ::= COLNAME {\qq}of{\qq} <datatype> [{\qq}default{\qq} LITTERAL] \\
<nameDatatypeList> ::= <nameDatatype> | <nameDatatype> {\qq},{\qq} \\
<datatype> ::= {\qq}string{\qq} | {\qq}boolean{\qq} | {\qq}number{\qq}\\

Eksampler på oppbrytning av de ulike delene.


\section{Lagring}
\subsection{Metadata}
Informasjon om hver enkelt tabell ligger lagret i en separat fil. Årsaken til at dataen og metadataen ikke ligger i samme fil er at det blir enklere å kun lese inn den informasjonen som er nødvendig. Eksempelvis vil det kun være nødvendig å lese inn metadataen for å sette inn ny data. Metadatafilen inneholder navn på de ulike feltene i tillegg til typen for feltet og eventuelt en standardverdi. Filen har slik syntax:

<entryList> ::= <entry> | <entry>{\qq};{\qq}<entryList> \\
<entry> ::= COLNAME{\qq}\{<datatype>[,<defaultValue>]\}{\qq}  \\
<datatype> ::= s | i | b
<defaultValue> ::= LITTERAL \\

\subsubsection*{Eksempel}
\textit{Name\{s,{\qq}John Doe{\qq}\};Phone\{i\};Adress\{s\})}

\subsection{Data}
Selve dataen lagres på et enkelt, CSV-linkende format. Formatet er valgt for å være enkelt å lese for både mennesker og maskiner i tillegg til å ta lite plass og være flyttbart. Siden lagringen benytter plassering for å bestemme de ulike feltene, er programmet avhengig av metadatafilen for å kunne skille mellom de ulike feltene. Et felt kan være tomt. Hvis en standardverdi er satt benyttes denne. Hvis ikke vil programmet avslutte med en feilmelding. Filen har slik syntax:\\
<rowList> ::= <row> | <row>{\qq}\escape{n}{\qq}<rowList> \\
<row> ::= <columnList> \\
<columnList> ::= <column> | <column>{\qq};{\qq}<columnList>\\
<column> ::= LITTERAL\\
\subsubsection*{Eksempel}
\textit{{\qq}Per Olsen{\qq};67284771;{\qq}Einerveien 18{\qq}\\
        ;88341821;{\qq} Lierveien 2{\qq}}
\chapter{Funskjonell Progammering}
\section{Hva er funksjonell programmering?}
Funksjonell programmering er et programmeringsparadigme. Et programmeringsparadigme kan defineres på ulike måter, men én definisjon er at det er stil eller måte koden blir skrevet på og organisert på. Det er viktig å legge vekt på at funksjonell programmering kun er en stil, og at denne stilen ikke er begrenset til en bestemt gruppe med språk. Likevel snakker man gjerne om funksjonelle språk, og da vil dette være språk som er designet for å programmere i den funksjonelle stilen. Likevel er det fullt mulig å bedrive funksjonell programmering i språk ikke regnes som funksjonelle, slik som C, men opplevelsen vil ofte bli bedre dersom man benytter språk spesielt laget for funksjonell programmering. Eksempler på slike språk er Standard ML, Haskell og Scala. 

Imperativ programmering og paradigmets populære underkategorier objektorientert og prosedyrisk programmering er de dominerende paradigmene i dag. En abstrakt definisjon på forskjellen mellom det imperative og det funksjonelle paradigmet kan være at det imperative er basert på turingmaskinen, mens det funksjonelle er basert på lambda-kalkylen. Denne forskjellen gjør funksjonell programmering til et på mange måter grunnleggende annerledes paradigme - i det funksjonelle paradigmet skapes resultatene ved å la dataen flyte og transformeres gjennom funksjoner(funksjoner i matematisk forstand), fremfor at  tilstanden til programmet stegvis blir mutert inntil resultatet er skapt. At man unngår å endre tilstanden til programmet er en essensiell og karakteristisk egenskap ved funksjonell programmering, og rapporten vil komme tilbake til hvilke implikasjoner dette vil ha på koden og på utviklingsprosessen. Funksjonell programmering regnes i tillegg som en underkategori av deklarativ programmering, noe rapporten også vil nevne. Paradigmet sin deklarative natur og det faktum at man unngår mutering, baner i tillegg vei for rekursjon, som også vil bli drøftet. Sist vil rapporten se på hvordan funksjonell programmering fungerer i større skala, med tanke på gjenbruk og abstraksjon, utvidbarhet og organisering av koden. Hensikten med rapporten er å se hvordan de ulike aspektene til funksjonell programmering kommer til uttrykk i praktisk programvareutvikling, og i dette tilfellet, utvikling av et spørrespråk for en database.\\

\section{Uforanderlighet og rene funksjoner}
Mest sannsynlig er uforanderlighet den mest definerende egenskapen med funksjonell programmering. Prinsippet går ut på at man ikke har variabler, kun konstanter. Rene funksjoner kan sies å være en konsekvens av uforanderlighet og går ut på at en funksjon må være skrevet som en matematisk funksjon: Som en direkte og absolutt kopling mellom input og output. Funksjonen produserer en verdi, og gjør ikke noe annet. Selv om prinsippene bak uforanderlighet og rene funksjoner er enkle, har det store konsekvenser for hvordan kode blir skrevet og hvilke teknikker som blir brukt i koden.  Objekter i tradisjonell forstand, tradisjonelle løkker og statements blir utelukket til fordel for andre teknikker. Denne seksjonen skal diskutere effektene man får som følge av uforanderlighet.

\section{Uforanderlighet}
Funksjonell programmering har en grunleggede anderledes modell for hva et program/en algoritme er i forhold til imperativ programmering. I inperativ programmering er en algoritme vanligvis en samling av statements og variabeldeklarasjoner. Når den kjører blir variablene mutert intill programmet er ferdig og det ønskede resultatet er produsert. Hvis man bestemmer seg for å stoppe å bruke variabler, men kun konstanter, vil man høyest sansynlig måtte endre måten man skriver koden på.  Derfor kommer også et behov for andre teknikker inn. Løkker blir for eksempel erstattet av rekursjon, mens funksjoner for å endre en struktur vil returnere en ny struktur fremfor å endre den som ble sendt inn som parameter. I funksjonell programmering kan man se på en algoritme som ett enkelt uttrykk som blir evaluert. Uttrykket kan godt ha mange del-uttrykk og benytte funksjoner for å abstrahere bort deler av koden, men det er fortsatt ett enkelt uttrykk. Den funksjonelle stilen gjør det derfor nødvendig å utvikle kode på en grunnleggende annerledes måte. Seksjonene\ref{sec:rec} og \ref{sec:organisering} går nærmere inn på hvordan dette kan fungere i praksis. Seksjon 3 {\qq} \ref{chap:inplementation}{\qq} eksemplifiserer den funksjonelle stilen i en større skala. 

Den imperative modellen er for mange naturlig å bruke fordi den etterlikner den virkelige verden. Likevel skaper variabler voldsomt mye problemer, blant annet knyttet til hvordan man forstår koden. Kodeforståelse er kritisk når man kommer over en kodebit andre har skrevet eller når man driver med feilsøking. I den imperative modellen må man holde styr på tilstanden til programmet til en hver tid og legge merke til alle endringene av variablene. I et imperativt program må man ofte skape seg et mentalt bilde av tilstanden til en rekke objekter, tellervariabler i løkker og globale variabler.  Denne oversikten blir enda mer utfordrende å skaffe seg når dataen blir brukt av ulike deler av programmet og til og med kanskje ulike tråder. Forskning fra 2001 tyder på at mennesket som regel kun kan ha 4 ting i arbeidsminnet samtidig \cite{forskningArbeidsminne}. Dette betyr at utviklerne ofte ikke kan ha hele oversikten i holdet samtidig. Når man mislykkes å forstå virkemåten til programmet fullstendig,  er faren for bugs høyst tilstedeværende. Også feilsøking blir mer krevende.Med konstanter fremfor variabler trenger man ikke holde styr på tilstanden, siden den ikke kan endres. Man kan derfor argumentere for at forståelse av koden og feilsøking blir enklere. Eksempel på en algoritme løst med uforandelighet og med tradisjonelle variabler finnes i figur \ref{fig:fibImperative} og \ref{fig:fibConstant}. Her er Java benyttet i begge tilfellene for å understreke at uforanderlighet også kan benyttes i språk som tradisjonelt regnes som imperative.
\begin{figure}[H]
\caption{Funksjon for å regne ut det n-te Fibonacci-tallet (Java)}
\label{fig:fibImperative}
\begin{minted}{java}
public static int fib(int n){
        int prev,curr;
        prev = curr = 1;

        if(n <= 1) return 1;

        for(int no = 3; no <= n; no++){
            int tmp = curr;
            curr += prev;
            prev = tmp;
        }

        return curr;
    }
\end{minted}
\end{figure}
\textit{Funksjonen finner det n-te Fibonacci-tallet ved å holde styr på gjenende og forige fibbonacci-tall og oppdatere de for hver iterasjon av løkken.}
\begin{figure}
\caption{Funksjon for å regne ut det n-te Fibonacci-tallet, uten variabler (Java)}
\label{fig:fibConstant}
\begin{minted}{java}
 public static int fib2(int n){
        if(n <= 1) return 1;
        return fib(n -1) + fib(n-2);
    }
\end{minted}
\end{figure}
\textit{Funksjonen finner det n-te Fibbonacci tallet ved å definere fib av n <= 1 som 1 og fib av et hvilket som helst annet tall som den rekursive løsingen av det forige Fibonacci-tallet og det forige-forige Fibbonacci-tallet.}

Hvis man sammenlikner de to funksjonene kan man se at den første funksjonen har mange flere bevegelige deler. Flere bevegelige deler betyr mer informasjon å holde i arbeidsminnet for utvikleren. Muligheten for å gjøre feil vil derfor bli større. Spesielt i forhold til feilsøking kan den første varianten være mer krevende. Likevel vil en del foretrekke den første varianten ved at den mer eksplisitt definerer de ulike stegene.

\subsection{Rene funksjoner}
Rene funksjoner er som nevnt tidligere funksjoner som kun kopler input til outpt, og ikke noe mer. Dette faktumet innebærer også att en ren funksjon ikke har side-effekter, altså at den ikke påvirker \textit{verdenen} utenfor funksjonen. Man finner derfor ikke noe tilsvarende det man kaller \textit{void} i Java og C\# i rene funksjonelle språk. Side-effekter innebærer mutering av variabler eller parametre, men også IO-operasjoner slik som å skrive ut i konsollen og å skrive til en fil eller en database. I tillegg vil naturligvis også handlingen å kalle på urene funksjoner  gjøre funksjonen uren. Siden en ren funksjon ikke vil avhenge av ekstern kontekst vil den rene funksjonen alltid produsere samme svar med en bestemt input. Effekten av dette er at man kan  bytte ut funksjonskallet med verdien det produserer uten å endre programmets virkemåte. Dette prinsippet kalles ofte \textit{referential-transparency}. På bakgrunn av de nevnte egenskapene vil  rene funksjoner fungere som isolerte enheter og vil ikke være avhengig av tillstanden til programmet. Det vil derfor være enkelt å flytte eller bytte ut rene funksjoner, og de kan dessuten testes hver for seg. Det siste poenget vil kunne være tidbesparende da man ofte må emulere en programtillstand når man skal gjennomføre testing i mer komplekse programmer. Også kodeforståelsen og dermed også feilsøkingen vil bli enklere med rene funksjoner fordi man ikke trenger å ha kunnskap om programmets kontekst og hva som har blitt utført tidligere. Det skal legges til at et program helt uten sideffekter i praksis er et program uten nytteverdi. Det er derfor nødvendig å ty til visse sideeffekter og dermed ende opp med et lite antall urene funksjoner, men man ønsker da å isolere bruken av dette. Enkelte språk, slik som Haskell og Elm benytter dessuten et konsept kalt monader for å løse interaktering med \textit{verdenen på utsiden} på en funksjonell måte.




\textit{Hvoran kan man indikere at kun en enkelt setning er hentet fra en ekstern kilde og ikke hele avsnittet?}


\subsection{Parallell kjøring og flertrådede programmer}
Nå som prosessorer leveres med stadig flere kjerner blir det mer viktig å utnytte så mange av de som mulig for å oppnå god ytelse. Korrekt håndtering av tråder parallellisering regnes av mange som en utfordrende aktivitet innen utvikling. Noe av det som gjør flertrådkjøring ekstra utfordrende er når flere tråder deler på samme data, og dataen har mulighet til å bli endret. Eksempel på en slik situasjon: En tråd tester først integriteten til et objekt og utfører deretter arbeid på objektet, dersom det er gyldig. Hvis en annen tråd gjør objektet ugyldig etter at tråd nr. 1 har sjekket gyldigheten slik at det er ugyldig før eler mens arbeidet blir utført, kan det by på problemer. Løsningen på denne utfordringen er ofte ulike låsemekanismer eller ulike former for synkronisering. I funksjonell programmering forsvinner mange av utfordringene knyttet til flertrådkjøring på grunn av uforandelighet.

I et imperativt språk er det fullt mulig å utviklet et program der dataen som deles mellom trådene er uforandelig. På denne måten vil mange av utfordringene knyttet til flertrådkjøring forsvinne. Likevel vil dette være enklere i et funksjonelt språk siden dataen der er uforanderlig som standard. I et funksjonelt språk kan dataen fritt deles mellom et vilkårlig antall tråder og man vil ikke måtte bekymre seg for om en av trådene endrer dataen på et uønsket tidspunkt. Gyldigheten til dataen trenger bare å testes én gang; er den gyldig i den første testen vil den alltid være gyldig. På denne måten vil hyppige gyldighetstester, låsemekanismer og synkronisering i mange tilfeller bli overflødig. Låsemekanismer som avhenger av tidsavbrudd vil også bli mindre relevant fordi dataen ikke kan bli endret og det dermed ikke gir mening for en tråd å vente et vist antall sekunder på at data blir endret. Tidsavbrudd for tråder som produserer data vil likevel være relevant. 

Også parallell kjøring- der en algoritme sitt arbeid blir delt opp og de ulike delene utført separat, vil være mye enklere å håndtere i et funksjonelt språk. Igjen sørger uforanderligheten for at en av trådene ikke kan endre data, noe som betyr at arbeidet til de ulike trådene vil bli gjort på en isolert måte. Et eksempel der parallellisering vil kunne bli brukt er f.eks i mergesort eller quicksort.

\section{Rekursive funksjoner og deklarativ programmering}
\label{sec:rec}
\subsection{Hva er rekursjon?}
På et abstrakt nivå er noe rekursivt dersom navnet til det som blir definert er en del av selve definisjonen \cite{elements_of_func}. Av dette kan man tyde at rekursjon ikke nødvendigvis er koplet opp mot funksjoner, men denne rapporten vil konsentrere seg om rekursive funksjonsdefinisjoner. Rekursive funksjoner går ut på at en funksjon kaller seg selv, noe som innebærer at funksjonen bruker seg selv som et steg på veien til løsningen av et problem. I noen tilfeller vil rekursjonen ha semantikk og oppførsel med likhetstrekk til konvensjonelle løkker, men i andre tilfeller vil rekursjonens virkemåte være grunnleggende annerledes. Spesielt i det siste tilfellet kan man argumentere for at rekursjon lar deg løse problemer på en mye mer elegant måte enn tilfellet hadde vært uten rekursjon. Rapporten kommer tilbake til dette senere. Deklarativ programmering er et annet tema som er tett knyttet opp mot funksjonell programmering og også på noen måter, rekursjon. Denne seksjonen skal ta for seg begge prinsippene og hvordan de relaterer til funksjonell programmering.\\

Rekursjon er en teknikk som er tilgjengelig i så godt som alle moderne programmeringsspråk. Grunnen er at de fleste språk bruker en kall-stack for funksjonskall og at det i prinsipp ikke spiller noen rolle hvilken funksjon som blir kalt på. En funksjon som kaller seg vil det derfor bli behandlet som et hvilket som helst funksjonskall. På tross av den nesten universelle tilgjengeligheten blir teknikken ofte mye mer brukt i forbindelse med funksjonell programmering enn det den gjør i imperativ. Årsakene til dette er flere men blant annet er rekursjon enste mulighet i enkelte språk til å gjenta kode på en organisert måte(som en form for løkke) i tillegg til at rekursjon er et uvurderlig verktøy i den funksjonelle verktøykassen når det kommer til å skrive programmer i funksjonell stil. Rekursjon og funksjonell programmering går på mange måter hånd i hånd.
\subsection*{Hvorfor rekursjon i funksjonell programmering?}
En måte å angripe problemet på er å heller spørre: Hvorfor ikke løkker i funksjonell programmering? Mange av grunnene til dette kommer fra løkkenes natur og virkemåte. En løkke består som regel av en kodeblokk og en betingelse som sjekkes for hver gang kodeblokken eventuelt blir gjentatt. For at løkken ikke skal bli gjentatt ut i det uendelige er det gitt at uttrykket i betingelsen må endres. Eneste muligheten for dette er enten at uttrykket aldri er sant, at det er et ikke-deterministisk funksjonskall (f.eks. en randomfunskjon), et uttrykk som avhenger av eksterne kilder, eller mer vanlig, at en eller flere variabler muteres inne i kodeblokken. De fleste språkene har også en løkkevariant der initialisering og mutering av teller/løkkevariabler og løkke-betingelsen er kombinert. Uansett varianten vil løkken i de fleste tilfeller være avhengig av mutering i en eller annen form for å ta slutt, men også for å få gjort nyttig arbeid inne i selve løkkekroppen. Løkkenes muterende natur medfører at løkker strider mot grunnleggende prinsipper i funksjonell programmering omtalt i kapitlet {\qq}Konstanter fremfor variabler{\qq}. Alternativet til løkker i funksjonelle språk er ofte funksjoner av høyere orden eller rekursjon. Det må også legges til at mange moderne språk tilbyr iterator-baserte løkker, f.eks. ved bruk av \textit{for(Type navn: liste) }i Java, som er mer funksjonelle i natur.
\subsection{Fordeler og ulemper}
\subsubsection*{Lesbarhet og semantikk}
Denne seksjonen skal ta for seg en algoritme for å skrive ut en tekstlig representasjon av et binært tre i både funksjonell og imperativ stil, for deretter å sammenlikne semantikk og lesbarhet til kodesnuttene.

\begin{figure}[H]
\caption{Funksjon for å lage en tekstlig versjon av et tre (Standard ML)}
\label{fig:treeToStrSML}
\begin{minted}{sml}
 fun treeToStr(exprTree: ExprTree) = 
     case exprTree of
         Node(left,value,right) =>  
           Util.format("Tree( Val:$ L:$ R:$ )", 
             [getValue(value), exprTreeToStr(left),exprTreeToStr(right)])
        |EmptyNode => ""
        |treeLit(lit) => getValue(lit) 
\end{minted}
\end{figure}
\textit{Funksjonen bruker preorder-traverering til å rekursivt lage en tekstlig representasjon av et tre. Util.format er en funksjon for tekstformatering, på samme måte som System.out.printf i Java der dollartegnet i Util.format er analogt til \%s i Java-varianten. Denne funksjonen benyttes til feilsøking i databasen for å skrive ut uttrykks-trær. Eksempelvis vil uttrykket 1+2+3 få denne tekstlig reprsetntasjonen:Tree( Val:+ L:1.0 R:Tree( Val:+ L:2.0 R:3.0 ) ).
}

\begin{figure}[H]
\caption{Funksjon for å lage en tekstlig versjon av et tre (Java)}
\begin{minted}{java}
   public static String treeToStr (Tree treeRoot){
        Stack<Tree> treeStack = new Stack<>();
        treeStack.add(treeRoot);

        String str = "";
        while (!treeStack.isEmpty()){
            Tree curr = treeStack.pop();
            if(curr != null){
                str += (String.format("%s (Val: %s ",curr.getType(), curr.value));

                treeStack.push(curr.right);
                treeStack.push(curr.left);
            }
            else{
                str += (")");
            }
        }
        return  str;
    }
\end{minted}
\end{figure}
\textit{Funksjonen bruker en stack for å lage en tekstlig versjon av treet. For hver node legges verdien til noden til i strengen og høyre og venstre tre legges til i stacken. Dette gjentas inntil stacken er tom, noe som indikerer at vi har nådd bunnen av treet. Funksjonen getType henter typen til noden (om noden er en rotnode, venstre- eller høyrenode)}

Hvis man studerer de to kodesnuttene kan man legge merke til at den funksjonelle er mer kompakt med tanke på antall linjer kode, men kanskje mer tydelig: Den angriper problemet på en grunnleggende annerledes måte enn den imperative varianten. I stedet for å eksplisitt definere de ulike stegene i algoritmen, benyttes en mer deklarativ stil. I deklarativ programmering kan utvikleren konsentrere seg om \textit{hva} som skal bli beregnet, uten nødvendigvis å måtte tenke på eller definere \textit{hvordan} dette skal gjøres \cite{declarative_programming}. Sagt på en annen måte- deklarativ programmering innebærer at utvikleren definerer logikken, men ikke programflyten. Dette medfører at elementer som if-setninger, løkker, og nøkkelord som \textit{continue} og \textit{break} ikke benyttes. Både funksjonell programmering og logisk programmering regnes for å tilhøre den deklarative stilen. SQL er kanskje det mest kjente  deklarative programmeringsspråket, selv om dette hverken er funksjonelt eller logisk. Regulæruttrykk, selv om det ikke er et programmeringsspråk men heller et domespesifikt språk, er også et kjent eksempel. I kodesnutten i figur \ref{fig:treeToStrSML} kan man se dette i praksis ved at algoritmen har minimalt med styring av kontrollflyt, men heller definerer {\qq}regler{\qq}  for ulike scenarioer av input. Dessuten vil man enklere kunne få et inntrykk av hvordan den endelige strengen vil kunne se ut, kun ved å se på linjen for strengformateringen. Deklarativ programmering har som effekt at utvikleren opererer på et høyere nivå av abstraksjon. Dette er noe som kan bidra til kode som både er enklere å lese og forstå fordi tekniske implementerings-detaljer blir utelatt. Pattern-macthing er også en mekanisme som kan sies å tilhøre denne stilen, og blir brukt i den funksjonelle versjonen av tre-til-streng algoritmen. Pattern-matching vil bli diskutert i større detalj senere i rapporten. 

Knyttet opp mot rekursjon vil den deklarative stilen innebære at utvikleren ikke trenger å definere hvordan kodeblokkene blir gjentatt(gjennom løkker og logikken som styrer løkken) og at {\qq}stacken{\qq} som håndteres manuelt i den imperative varianten abstraheres bort. Dette vil kunne påvirke lesbarheten betraktelig. Traversering av rekursive datastrukturer som binær- og filtrær er derfor problemer som egner seg godt for rekursjon. Det samme er tilfellet for splitt-og-hersk algoritmer(slik som quicksort). I andre tilfeller er muligens ikke fordelene like åpenbare.\\
\\
På den andre siden kan deklarativ programmering gi utvikleren et mer utydelig inntrykk av hva som faktisk foregår. Dette er fordi den faktiske logikken og programflyten blir gjemt bort under flere lag med abstraksjon. Mulighetene for optimalisering og spesialtilpassing blir også mindre av samme grunn. Et annet aspekt er at høytnivåkonseptene som følger med deklarativ programmering kan være utfordrende å forstå siden mange av begrepene er svært abstrakte og fordi det kan være vanskelig å finne en konkret parallell i den virkelige verden. For eksempel kan en løkke være enklere å forstå enn rekursjon og en imperativ variant som finner summen av elementene i en liste være mer intuitiv enn å bruke \textit{reduce/fold}.\\
\\
Den deklarative stilen i det første eksempelet vil kunne gjøre funksjonen enklere å lese og skrive. Likevel krever den rekursive løsningen at utvikleren har kjennskap til og erfaring med rekursive algoritmer. Uten dette kan rekursive funksjoner være svært krevende å forstå, og ikke minst feilsøke, spesielt rekursjon som ikke er halerekursiv eller rekursjon som er av den multirekursive typen. En av grunnene til dette angår semantikken til koden og måten utvikleren kan få en forståelse for virkemåten til algoritmen. Ved en imperativ variant kan vedkommende gå gjennom algoritmen på en lineær måte og holde styr på tilstanden til programmet. Denne stilen vil for mange være mer naturlig og har også den fordelen at den vil kunne være enklere å feilsøke med en konvensjonell debugger. Den rekursive varianten er mer todimensjonal av natur ved at programflyten ikke bare går nedover, men også innover og oppover. Dette medfører at for å gå gjennom og få en forståelse for algoritmen må man danne seg en mental stack og bevege seg nedover og oppover kalltreet eller eventuelt skrible ned kallstacken på et papir. Det skal sies at dersom man har kjennskap til rekursjon, vil denne oppgaven bli enklere, men det vil fremdeles kreve en viss mental kapasitet når man skal lese og forstå mer komplekse rekursive algoritmer, spesielt når det ikke er deg selv som er forfatteren.\\


\begin{figure}[H]
\caption{Funksjon for å fjerne kommentarer fra kildekode(Standard ML)}
\label{fig:rmComments}
\begin{minted}{sml}
fun rmComments(lines: string list):string list =
  case lines of
      (x::xs) =>
          let
             val substr = strToSs(x)
             val (noComment, comment) = Substring.splitl (fn c => c <> #"#") substr
       in
           ssToStr(noComment) :: rmComments(xs)
       end
    |[] => []
\end{minted}
\end{figure}
\textit{Funksjonen fjerner alle tegn fra og med \#-tegnet for hver streng i listen blir sendt inn. splitl deler opp en streng ved hjelp av en predikatfunksjon som blir kjørt på hvert enkelt tegn. Delen uten kommentarer konkatineres med den rekursive løsningen til resten av lista.}
\label{fig:kalltreRmComments}
\begin{figure}[H]
Strengen som sendes inn: \\
\textit{from Person as P \#P er en alias \\
		filter department = {\qq}IT{\qq} \#Bare datafolkene \\
        output name,salary \#Grunnleggende info \\
        }
 \caption{Kalltre for funksjonen i figur \ref{fig:rmComments}}
\begin{minted}{text}
"from Person as P" :: rmComments("filter department = IT #Bare datafolkene 
        			  output name,salary #Grunnleggende info")
	"filter department = IT" :: rmComments("output name,salary #Grunnleggende info")
    	"output name, salary"

\end{minted}
\end{figure}


\subsection{Effektivitet}
\label{subsec:effektiivitet}
Rekursive funksjoner blir i mange tilfeller foretrukket fremfor løkker i en rekke funksjonelle språk, mens teknikken ofte er reservert til spesielle tilfeller slik som traversering av trær i språk som er mer imperative. En viktig årsak til dette er måten de ulike kompilatorene og interpreterne implementerer rekursjonen, spesifikt om de tilbyr hale-rekursjon-optimalisering eller ikke.


For hvert funksjonskall, inklusive rekursive funksjonskall, opprettes en stackframe som lagres på kallstacken. Inne i hver stackframe lagres blant annet parameterverdier, lokale variabler(ikke i dette tilfellet) og posisjonen i koden det skal fortsettes fra etter at funksjonen har returnert. I figur \ref{fig:kalltreRmComments} kan man se at måten den rekursive funksjonen i figur \ref{fig:rmComments} kjører på medfører at tilstanden til funksjonen(i dette tilfellet strengen før ::) må lagres. Den må lagres slik at strengen kan bli konkatinert på et senere tidspunkt når rekursjonen trekker seg oppover. I dette tilfellet vil man da få laget 3 stackframes før rekursjonen trekker seg opp igjen, noe som vil medføre ekstra  minnebruk og ekstra operasjoner med å legge til og fjerne frames fra kallstacken. Hale-kall optimalisering vil kunne eliminere de nevnte ulempene ved å transformere enkelte former for rekursjon til vanlig iterasjon. Funksjonen for å fjerne kommentarer er et trivielt eksempel som ikke hadde dratt nevneverdig effekt av en slik optimalisering, men hvis rekursjonen hadde vært svært dyp, hadde antallet stackframes blitt svært høyt, noe som potensielt kunne ha fylt opp kallstacken og i verste tilfelle medført en stack-owerflow exception. Dette er i tillegg til at algoritmen blir mer ressurskrevende å kjøre. I seksjon \ref{sec:hastighetestester} demonstreres slik dyp rekursjon der en funksjon testes med 100 000, 1 million og 100 millioner rekursive funksjonskall, med og uten halekall-optimalisering. 
\\


For at en kompilator skal kunne utføre hale-kall-optimalisering må rekursjonen være implementert på en bestemt måte - det kan kun forekomme ett rekursivt kall som må komme helt til sist og det kan ikke akkumuleres verdier rekursivt. Dette innebærer at det rekursive kallet \textit{ssToStr(noComment) :: rmComments(xs)} i figur \ref{fig:rmComments} ikke oppfyller krav nr. 2 og dermed ikke er halerekursivt. Hvis de to egenskapene er oppfylt vil det ikke være noen grunn til å opprette stackframes, siden det ikke vil være noen grunn til å gå tilbake til tidligere rekursive kall. Rapporten går mer i dybden på denne erkjennelsen senere. Kravet om ett rekursivt kall helt til slutt medfører at algoritmer som naturlig implementeres med multi-rekursjon slik som traversering av trær, må bli skrevet om og vil få ganske annerledes logikk. For mer konvensjonell rekursjon er det ofte enklere å refaktorere koden til å være halerekursiv. \\

\begin{figure}[H]
\caption{Funksjon for å fjerne kommentarer fra kildekode, halerekursiv (Standard ML)}
\label{fig:rmCommentsTailrec}
\begin{minted}{sml}
 fun rmCommentsTailrec(inpLines: string list):string list =
   let fun rmTailRec(inpLines:string list, result:string list) = 
    case inpLines of
      (x::xs) =>
     let 
        val substr = Util.strToSs(x)
        val (noComment, comment) = Substring.splitl (fn c => c <> #"#") substr
      in  
        rmTailRec(xs, Util.ssToStr(noComment) :: result)
      end 
      |[] => rev(result)
    in
      rmTailRec(inpLines,[])
   end

\end{minted}
\end{figure}
Funksjonen i figur \ref{fig:rmCommentsTailrec} er transformert til å være halerekursiv. Den utfører samme oppgaven som i figur \ref{fig:rmComments}, men for at den skal oppfylle kravene for halerekursivitet er den blitt refaktorert til å benytte en indre funksjon og et akkumulator-parameter i stedet for å akkumulere rekursivt. Den nye implementeringen medførte også et par andre små endringer slik som reversering av listen når den returneres, men totalt sett var endringen relativt triviell. At refaktoreringen var lite krevende er ikke alltid tilfellet. Eksempelvis benytter den halerekursive varianten av funksjonen for å beregne det n-te Fibonacci tallet en helt annerledes algoritme enn varianten med ordinær rekursjon.

Siden det rekursive kallet er det siste og eneste som blir utført i en halerekursiv funksjon, trenger ikke lokale variabler eller posisjon for returnering å bli lagret.  Fordi rekursjonen aldri kommer til å trekke seg opp igjen, men kun kalle seg selv med endrede parameterverdier vil det som nevnt tidligere ikke være noen grunn for at rekursjonen skal måtte gå {\qq}tilbake{\qq}. På grunnlag av denne kunnskapen kan kompilatoren optimalisere bak kulissene slik at nye stackframes ikke opprettes, men heller at én gjenbrukes. Rekursjonen blir omgjort til normal iterasjon, med de hastighetsforbedringene dette medfører. Hvis man har en kompilator som genererer Assembly vil hale-rekursjonen kunne bli konvertert til å bruke goto og mutering av registre, noe som vil gi svært god ytelse. Uoptimalisert rekursjon i Assembly innebærer at  stackframes må dyttes av og på stacken i tillegg til at parameterne må kopieres(hvis man har pass-by-value slik som i Standard ML) for hvert enkelt funksjonskall. Flere operasjoner medfører mer jobb for CPU-en og dermed lavere ytelse. Flere stackframes medfører også større minnebruk. Standard ML er et språk der de mest populære kompilatorene har halekall-optimalisering, noe man vil kunne se tydelig utsalg for i hastighetstester.


\subsubsection{Hastighetstester}
\label{sec:hastighetestester}
For å teste forskjeller i effektivitet mellom ordinær rekursjon og halerekursjon benyttes en funksjon for å summere elementene i en liste.

\begin{figure}[H]
\caption{Sum av elementene i en liste, ordinær rekursjon (Standard ML)}
\label{fig:sumSML}
\begin{minted}{sml}
fun sum [] = 0
   |sum(x::xs) = x + sum(xs)
\end{minted}

\end{figure}
\textit{Funksjonen legger rekursivt sammen verdien til første element(x) pluss summen til resten av lista(xs). Dersom lista er tom er summen 0.}

\begin{figure}[H]
\caption{Sum av elementene i en liste, halerekursiv (Standard ML)}
\label{fig:sumSMLTailRec}
\begin{minted}{sml}
fun sumTail(li) = 
let fun sumFrom([], summed) = summed
	   |sumFrom(x::xs, summed) = sumFrom(xs,summed + x)
in
	sumFrom(li, 0)
end
\end{minted}
\end{figure}
\textit{Funksjonen funger nesten som den med ordinær rekursjon, men benytter en indre funksjon og en akkumulator-variabel for summen.}
\begin{figure}[H]
\caption{Oversikt over resultater ved kjøring av sum og sumTail}
\begin{center}
\begin{tabular}{|r | r| r| r|}
\hline
\rowcolor{lightGray} Funksjon & Ordninær rekursjon & Hale-rekursjon & Forbedring \\
\hline
sum: 100 000 & 16.6 msek & 13.3 msek & 24.8\% \\
\hline
sum: 1 million & 30.3 msek & 21.6 msek & 40\% \\
\hline
sum: 100 millioner & 182 msek & 3336 msek & 1732\% \\
\hline 
\end{tabular}
\end{center}
\end{figure}
Vi ser av resultatene ovenfor at hale-rekursjon-optimalisering gir betydelige forbedringer med tanke på effektivitet, spesielt når problemstørrelsen øker.

\subsection*{Oppsummering}
I databasen blir rekursjon benyttet hyppig. Dette har flere positive effekter - blant annet kode som er mer konsis og kompakt og i mange tilfeller som også kan oppleves som mer lesbar. Det er forbundet en viss lærigskurve med den rekursive stilen, men etter å ha blitt komfortabel med teknikken føles rekursjon i mange tilfeller mer naturlig. Noen av årsaken til dette kan være at man ender opp med kode på et høyere nivå som også er mer deklarativ. Andre årsaker kan være at man deler opp problemet i stadig mindre biter og ender opp med å løse problemet når det er svært enkelt(typisk for algoritmer slik som mergesort). Å dele opp et problem i mindre deler er en svært kjent taktikk i dagliglivet(tenk f.eks. matlaging) og dette kan være ett av elementene som gjør rekursjon intuitivt for visse problemer. Til slutt skal det også legges til at selv om rekursjon i mange tilfeller vil gi store fordeler, vil en rekursiv løsning på et problem alltid kunne skrives imperativt ved å bruke løkker. Dette kan eksemplifiseres med at alle programmer skrevet i et funksjonelt programmeringsspråk til slutt vil ende opp som maskinkode kjørende på den grunnleggende imperative CPU-en. \\ \\

\section{Abstraksjon, organisering og gjenbruk av kode}
Når programstørrelsen øker og kompleksiteten til programmet vokser, blir det stadig viktigere å organisere koden på en hensiktsmessig måte. Det vil også være avgjørende å bruke hensiktsmessige abstraksjoner for å lage kode som enkelt kan gjenbrukes og tilpasses nye krav. Objektorientert programmering innehar flere mekanismer for å oppnå nettopp dette og disse egenskapene kan muligens tillegges noe av grunnen til paradigmets store suksess. På tross av at funksjonell programmering er grunnleggende annerledes fra objektorientert, kan man likevel få mange av de samme gode egenskapene i dette paradigmet. Denne delen skal se på mekanismer og teknikker for å organisere kode og hvordan man kan få abstrakt og gjenbrukbar kode i det funksjonelle paradigmet og samtidig trekke paralleller til objektorientert programmering.

\subsection{Abstraksjon med first-class-functions}
I funksjonell programmering har funksjoner en viktig og spesiell plass - noe navnet antyder. I funksjonell programmering sidestilles nemlig funksjoner med de andre datatypene slik som tall og strenger, og kan dermed brukes på de samme stedene. Sagt på en annen måte regnes funksjoner som en hvilken som helst annen datatype og ikke en spesiell, annenrangs type slik tilfellet er i en del imperative språk. Dette medfører at funksjoner kan bli lagret i datastrukturer som f.eks. lister, at de kan bli sendt som argumenter, at en funksjon kan returnere en annen funksjon, og at en funksjon kan bli definert inne i en annen funksjon. Dette er en kraftfull mekanisme som lar deg skrive mer abstrakt og gjenbrukbar kode. At funksjoner kan defineres inne i andre skaper et hierki og kan gi en bedre organisering og struktur på koden.

\subsubsection*{Funksjoner som argumenter}
I imperativ programmering er man kjent med funksjoner som en viktig abstraksjons-enhet. En  funksjon kan ta imot argumenter , noe som gjør at brukeren kan bestemme deler av oppførselen til algoritmen. Denne muligheten gjør funksjonen mer generell og abstrakt og dermed også mer gjenbrukbar. I imperativ programmering pleier som regel parameterne å være data slik som strenger, tall eller lister. På denne måten blir dataen funksjonen jobber med abstrahert bort. I en funksjon for å beregne verdiutviklingen til penger i banken  kan man f.eks. ha et parameter for rente-verdi, ett for antall år pengene er i banken og ett for opprinnelig beløp. Ved å ha de tre argumentene kan man benytte funksjonen til å regne verdiutviklingen med ulike kombinasjoner av rentebeløp,  opprinnelige beløp og  antall år. Selv om data som parametre kan bidra til abstraksjon på et rimelig høyt nivå,  tar funksjonell programmering abstraksjonen enda høyere ved å også la utvikleren abstrahere bort kodeblokker, altså det funksjonen \textit{gjør}. En funksjon som gjennomfører en kompleks beregning, kan ta imot funksjoner for å utføre deler av beregningen. Andre vanlige bruksområder er i forhold til lister, der man ofte ønsker å utføre en bestemt operasjon på hvert enkelt listeelement. Konseptet med funksjoner som tar imot eller returnerer funksjoner kalles i høyere-nivå-funksjoner i funksjonell programmering. Funksjoner slik som map, reduce, filter og takewhile er eksempler av denne typen som blir mye brukt i den funksjonelle stilen.

En funksjon som benyttes hyppig i spørrespråket er en funksjon for å konvertere en liste til en streng. Funksjonen benyttes  til feilsøking og for å produsere deler av feilmeldingene brukeren møter dersom spørringen eller dataen som blir forespurt er ugyldig.

\begin{figure}[H]
\label{fig:listToStr}
\caption{Funksjon for å konvertere en liste til en streng (Standard ML)}
\begin{minted}{sml}
fun listToStr ([], toStr:('a->string), sep:string):string = ""
  | listToStr([x], toStr, sep) = toStr x
  | listToStr(x::xs, toStr, sep) = toStr x ^ sep ^ listToStr(xs,toStr,sep)

\end{minted}
\end{figure}
\textit{Funksjonen lager en streng-representasjon av listen. toStr blir brukt til å 
konvertere hvert enkelt listeelement  til en streng og sep blir satt inn mellom elementene. Streng-representasjonen er definert som en tom streng for en tom liste og listefunksjonen brukt på ett element hvis listen bare har ett element. Dersom listen har mer enn ett element er definisjonen strengen bestående av  første element, separatoren og den rekursive løsningen til resten av elementene. }

I funksjonen over er fremgangsmåten for å konvertere et listeelement abstrahert bort i parameteret toStr. På denne måten vil funksjonen  fungere for lister av vilkårlig type. Funksjonen som sendes inn, har i likhet med de andre parameterne og elementer generelt i SML, en type. Av funksjonens signatur kan vi lese at den  må ta imot et element av type 'a(samme type som listeelementene skal ha) og produsere en verdi av type streng. Utenom dette står brukeren av funksjonen fritt til å lage en egen implementering. Denne funksjonen vil bli brukt på hvert element i listen for å lage den endelige strengen. Når man kaller på listToStr kan man enten sende med en predefinert funksjon, eller man kan definere funksjonen navnløst og på stedet, ved å lage en såkalt lambdafunksjon. Se figur \ref{fig:listToStrCalling} for eksempel på de to variantene.

\begin{figure}[H]
\caption{Kall på listToStr med predefinert funksjon og lambdafunksjon(Standard ML)}
\label{fig:listToStrCalling}
\begin{minted}{sml}
val intList =  [1,2,3,4,5]
val strList1 = listToStr(intList, Int.toString, " ")
val strList2 = listToStr(intList, (fn e => "num: " ^ Int.toString(e)),  " ") 
\end{minted}
\end{figure}

Her er Int.toString en bibliotekfunksjon som konverterer ett tall til én streng. Siden funksjoner som nevnt er første-klasses-typer i SML kan de sendes som et vanlig argument. Variant nr. to benytter en lambdafunksjon som setter sammen "num:" med strengrepresentasjonen av tallet. Predefinerte funksjoner har en enklere syntaks og er mest hensiktsmessige hvis du har en funksjon du ønsker å bruke flere ganger. Lambda-funksjoner er mest hensiktsmessig for en funksjon som kun blir brukt én gang  og som er mer ad-hoc.

\subsubsection*{Funksjoner inne i funksjoner}
På samme måte som en funksjon eller et uttrykk kan ha lokale konstanter av de tradisjonelle datatypene kan de også ha lokale funksjoner.  En lokal funksjon defineres inne i en annen funksjon eller uttrykk(vil ikke bli omtalt i denne rapporten), og vil dermed ha tilgang til parameterne til den omsluttende funksjonen. Med dette kan man si at den lokale funksjonen dermed blir en del av den omsluttende, på samme måte som en lokal variabel blir en del av den omsluttende funksjonen. Å flytte kode ut i lokale funksjoner gir tydeligere oppdeling av koden, og siden lokale funksjoner kan defineres vilkårlig dypt får man også en teknikk for å skape et hierarki. Med lokale funksjoner kan man skape mer modulær kode og ved å flytte noen av operasjonene til en lokal funksjon også gjøre funksjonen mer lesbar. Lesbarheten kommer av at at man navn til selve operasjonen som utføres og på parameterne som sendes inn. Dette er fordeler man også kjenner til fra funksjoner på topp-nivå. Samtidig unngår man problemene som ofte er knyttet til denne typen funksjoner slik som navnekollisjoner og nødvendigheten av å sende rundt mange parametre.  Et eksempel på bruk av lokale funksjoner finnes i figur \ref{fig:getLitteralFromType}. Et annet bruksområde er i forhold til halerekursive funksjoner (også omtalt i seksjon \ref{sec:rec}) under overskriften {\qq}\ref{subsec:effektiivitet}{\qq}. Man kan da benytte en lokal funksjon med et akkumulator-parameter i tillegg til de andre nødvendige parameterne. Den omsluttende funksjonen kan da kalle på den indre og sette en fornuftig start-verdi på akkumulatorparameteret. Et eksempel på dette er funksjonen i figur \ref{fig:sumSMLTailRec}. 

\begin{figure}[H]
\caption{Funksjon for å hente en litteral fra en streng. En type blir sendt med for å teste om typen i strengen er korrekt}
\label{fig:getLitteralFromType}
\begin{minted}{sml}

fun getLitteralFromType(
      source:string,  type_:MetadataParser.Type,  lineNo:int,
      filename:string):Tok.litteral option = 

  let fun raiseWrongDataExn(expected, found) = 
        raise ErrorHandler.typeErrorStoredData(
                expected, MetadataParser.typeToStr(found),lineNo,filename)

      val firstCharOpt = Util.hdStringOpt(source)
  in  
      case firstCharOpt of
           SOME(firstChar)  =>  
              (case type_ of
               STRING => if ParseUtil.isStartOfString(firstChar) then
                        ...
                         else 
                            raiseWrongDataExn("string", type_)
              |NUMBER => if ParseUtil.isStartOfDigit(firstChar) then
                       ...
                         else
                           raiseWrongDataExn("integer", type_)
              |BOOL  => if ParseUtil.isStrBoolean(source) then
                         ...
                        else 
                          raiseWrongDataExn("boolean", type_) )
          |NONE => NONE 
  end 

\end{minted}
\end{figure}

\textit{Funksjonen henter ut en streng, et tall eller en boolsk verdi fra en streng. Basert på typen som blir sendt med forsøker funksjonen å lage en verdi av en av de tre nevnte typene basert på det den finner i strengen. Hvis typene ikke stemmer overens skal en bestemt exception bli kastet.  {\qq}...{\qq} innebærer at en del av koden er utelatt.}

Man kan se av funksjonen over at den lokale funksjonen reduserer duplisering av kode og samtidig er fleksibel nok til å  fungere for de ulike typene som skal sjekkes. Siden denne funksjonen omfatter en relativt spesifikk situasjon, gir det mening å ha den som en lokal funksjon og ikke blant de andre top-nivå funksjonene som en generell funksjon. Funksjonen tar også nytte av å ha direkte tilgang på parameterne til den omsluttende funksjonen, i dette tilfellet \textit{lineNo} og \textit{filename}. 
\subsection{Organisering av kode med strukturer, signaturer og funktorer}
\label{sec:organisering}
Standard ML inkluderer et sett med mekanikker for å organisere kode og skape abstraksjon. I SML kalles de \textit{structure}, \textit{signature} og \textit{functor}.


Strukturer går ut på å pakke ett sett med deklareringer sammen. Deklareringer kan være konstanter, funksjoner, datatyper, typealiaser, exceptions, strukturer, funktorer eller signaturer. Alene fungerer en struktur litt som et namespace ved at man må referere til en bestemt struktur når man vil benytte seg av et av elementene inne i strukturen. Dette sørger for at man unngår navnekollisjoner. Man kan også se likheter mellom klasser og strukturer, med den distinkte forskjellen er at i den funksjonelle stilen skal man unngå mutering. Funksjonene i en struktur er heller ikke knyttet til noen bestemt instans av data, og er avhengig av at dataen sendes inn for hvert funksjonskall. Skal man emulere konseptet med å kalle funksjoner på en "instans" kan closures benyttes. De nevnte egenskapene til strukturen gjør at den likner mer på en klasse med bare konstant-felter og der alle metoder er statiske. At man unngår mutering i en struktur har den effekten at den i større grad blir en statisk, isolert og flyttbar enhet. Man trenger ikke å tenke på at strukturen kan endres fra utsiden eller at den er avhengig av endringer på utsiden for å fungere, siden strukturens tilstand aldri vil kunne endres. Feilsøking og forståelse av kildekoden vil derfor kunne bli enklere. De nevnte egenskapene vil i tillegg gjøre testing(spesielt unit-testing) enklere siden en struktur kan testes isolert.

En signatur fungerer som en kontrakt og beskriver typene til deklareringene en struktur må ha, men ikke selve implementeringen. At implementeringen ikke er med gjør signaturen abstrakt. Signaturer kan derfor sammenliknes med grensesnitt i f.eks. Java, men har et noe annerledes bruksområde. En annen måte å se en signatur på er at de representerer typen til en struktur. En struktur kan implementere en signatur og må i det tilfellet følge kontrakten definert i signaturen. I SML finnes det to måter en signatur kan implementeres på. Hvis signaturen implementeres på en gjennomsiktig måte vil signaturen utelukkende fungere som en kontrakt og alle typer og funksjoner definert utenom kontrakten vil være synlige. Dette reduserer abstraksjonen og vil kanskje også åpne opp for integritetsøledeggende operasjoner. Eksempelvis vil en struktur og en signatur for en kø, implementert gjennomsiktig kunne gjøre det tydelig hvilken datastruktur køen er implementert med og siden man har tilgang til denne underliggende strukturen, vil man også kunne ødelegge integriteten, f.eks. ved å hente ut et element fra slutten av køen. En annen ulempe er at siden man har tilgang til den underliggende datastrukturen, vil man også kunne utføre likhetstester. Denne likhetstesten vil fungere på normal måte, noe som i noen tilfeller ikke er intensjonen med strukturen. I en struktur for en samling uordnede elementer vil man f.eks. ikke at [1,2] og [2,1] skal bli sett på som to ulike strukturer. Den ugjennomsiktige måten å implementere en signatur på vil gjøre den underliggende datatypen abstrakt slik at den ikke kan benyttes utenfor strukturen og dermed heller ikke i likhetstester eller i integritetsøledeggende operasjoner. Den andre effekten man oppnår er at deklarasjoner som ikke er definert i signaturen vil bli skjult fra utsiden, noe som vil gi effekter tilsvarende innkapsulering ved bruk av f.eks. \textit{private} i Java. Strukturer og signaturer kan lages fullstendig uten mutering og er derfor funksjonelle i natur. I SML er signaturer kanskje mest nyttige når de blir brukt i forbindelse med funktorer som vil bli diskutert senere.

Databasen bruker en funksjonell map(aka assosiativ liste) basert på et binærtre for å lagre informasjon om de ulike kolonnene med data som leses inn når en spørring utføres. Denne datastrukturen brukes til å holde på selve dataen definert i datafilen slik at de ulike datafeltene for en rad enkelt kan bli funnet. Det er ønskelig at mapen har funksjoner for å sette inn og hente hente ut en verdi assosiert med en bestemt nøkkel. Dette er operasjoner som er ønskelig at alle maper skal ha, og funksjons-signaturene for dette er derfor definert i signaturen i figur \ref{fig:sigMap}.

Siden mapen er i den funksjonelle stilen vil den ikke kunne muteres. Dermed vil man ikke kunne ta i mot en map, endre den og deretter returnere den slik tilfellet ofte er i imperativ programmering. I stedet vil man ta imot en map og opprette en ny basert på den som ble sendt inn. Det er da den nye mapen som blir returnert. Dette vil ha den positive effekten at man ikke trenger å bekymre seg for om data sendt inn til en funksjon kommer til å bli endret av funksjonen. Dette faktumet fører til at designet av mapen vil bli grunnleggende annerledes enn tilfellet hadde vært i det objektorienterte paradigmet.

Mapen skal støtte nøkler av ulik typer data, også de typene som er av mer kompleks form. Siden mapen egentlig er et binært tre er man avhengig av å kunne finne rekkefølgen på elementene. Dette er for å kunne bestemme plasseringen i treet og senere for å kunne finne frem til en bestemt nøkkel. Med strukturer og signaturer ville løsningen blitt en implementering for hver av typene man ønsker å ha som nøkkel. Selv om strukturer og signaturer tilbyr innkapsulering og abstraksjon, bidrar de lite til å lage  kode som er gjenbrukbar. Ønsker man å implementere 4 nye typer nøkler må man lage 4 strukturer. Enda verre er det hvis man har flere ulike map-implementeringer som alle bruker rekkefølgen til elementene for å sette inn og hente ut elementene. Eksempelvis kan man ha en liste som bruker binærsøk i tillegg. I dette tilfellet hadde antall implementeringer blitt enormt mange. Løsningen med kun signaturer og strukturer skaper i slike tilfeller store mengder duplisert kode og vil være krevende å vedlikeholde.

Funktoren i SML lar deg unngå de nevnte problemene. Den fungerer som en slags funksjon som tar imot en eller flere strukturer av en bestemt type(som oppfyller en bestemt signatur) og som produserer en ny struktur som resultat. For map-implementeringen vil man kunne ønske å lage en funktor for hver enkelt implementering av map, som tar imot en struktur for datatypen som skal brukes som nøkkel. Strukturen som blir tatt imot kan da være av type ORDERED\_TYPE. Denne signaturen finnes i figur \ref{fig:sigOrdered}. To strukturer som implementerer denne signaturen finnes i figur \ref{fig:structOrdered}. Strukturen som sendes inn kan inneholde en funksjon for å bestemme rekkefølgen til to elementer av den aktuelle typen i tillegg til å inneholde selve data-typen. Funktoren til treeMap, i figur \ref{fig:funktorTreeMap} er laget på denne måten. Ved at type element og dets sortering ikke er hardkodet, men heller er abstrahert vekk vil funktoren kunne gjenbrukes med flere ulike datatyper, noe man ser eksempel på i figur \ref{fig:maps}. Når man kaller på funktoren vil en ny struktur tilpasset en bestemt type opprettes. Gjenbruksfaktoren økes også ved at strukturene til datatypene vil kunne bli delt på tvers av ulike implementeringer av map dersom alle tar imot en struktur av samme type.

\begin{figure}[H]
\caption{Signatur for en map (Standard ML)}
\label{fig:sigMap}
\begin{minted}{sml}
signature MAP = 
sig
  type 'a MapTree
  type keyType
  val insert: ('a MapTree*keyType*'a)-> 'a MapTree
  val get: ('a MapTree*keyType) -> 'a option
  val empty:(unit) -> 'a MapTree
end;

\end{minted}
\end{figure}

\begin{figure}[H]
\caption{Funktor for treeMap (Standard ML)}
\label{fig:funktorTreeMap}
\begin{minted}{sml}
functor MapTreeOfType (ordered:ORDERED_TYPE):MAP =  
struct 
  type keyType = ordered.t

  datatype 'a MapTree = 
    (*Key*value*left*right*)
    Node of keyType * 'a * 'a MapTree * 'a MapTree |
    EmptyNode
  
  (*Creates a empty map. The map does not yet have a value-type associated. This is set upon the     first insert*)
  fun empty() = EmptyNode

  (*Inserts a value into the given map. If the key already exists, no value is
  inserted*)
  fun insert(mt:'a MapTree, key:keyType, value: 'a):'a MapTree =
    case mt of
      EmptyNode     => Node(key,value,EmptyNode,EmptyNode) 
     |Node(k,v,l,r) => case ordered.compare(k,key) of
                         EQUAL   => mt (*The key already exists- the original tree is returned*)
                        |LESS    => Node(k,v,insert(l,key,value),r)
                        |GREATER => Node(k,v,l,insert(r,key,value))

  (*Retrieves the value associated with the given key. The result is wrapped in
   an option*)
  fun get(mt: 'a MapTree, key:keyType):'a option =
    case mt of 
      EmptyNode     => NONE 
     |Node(k,v,l,r) => case ordered.compare(k,key) of
                         EQUAL   => SOME(v)
                        |LESS    => get(l,key)
                        |GREATER => get(r,key)
end;

\end{minted}
\end{figure}

\begin{figure}[H]
\caption{Strukturer av type ORDERED\_TYPE for streng og tall med rekkefølge-funksjon (Standard ML)}
\label{fig:structOrdered}
\begin{minted}{sml}
structure orderedInt:ORDERED_TYPE = 
struct 
  type  t = int

  fun compare(i1,i2) = 
    if i1 < i2 then LESS 
    else if i1 > i2 then GREATER 
    else EQUAL
end;

structure orderedString:ORDERED_TYPE = 
struct
  type t = string
  fun compare(s1,s2) = 
    String.compare(s1,s2)
end;
\end{minted}
\end{figure}

\begin{figure}[H]
\caption{Signatur for en type med rekkefølge-støtte (Standard ML)}
\label{fig:sigOrdered}
\begin{minted}{sml}
signature ORDERED_TYPE= 
sig
  type t
  val compare: (t*t) -> General.order
end;

\end{minted}
\end{figure}

\begin{figure}[H]
\caption{Strukturer for tree-baserte maper for int og streng. En funktor brukes for å lage strukturene. (Standard ML)}
\label{fig:maps}
\begin{minted}{sml}
structure MapInt = MapTreeOfType(orderedInt)
structure MapString = MapTreeOfType(orderedString)
\end{minted}
\end{figure}
\chapter{Inplementasjon}
\label{chap:inplementation}
\chapter*{Bibiografi}
\addcontentsline{toc}{chapter}{\protect\numberline{}Bibiografi}%
\printbibliography[heading=none]
\end{document}
