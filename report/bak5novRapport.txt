\documentclass{report}
\input{sml.tex}
\title{En database skrevet i sml}
\author{Erlend \O
stlie}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{changepage}
\definecolor{lightGray}{rgb}{0.90, 0.90, 0.90}

\usepackage[a4paper, total={6in, 8in}]{geometry}
\usepackage{graphicx}
\usepackage{minitoc}
\usepackage{minted}
\usepackage{geometry}
\usepackage{float}
\usepackage{color, colortbl}
\usepackage{parskip}
\usepackage[norsk]{babel}
\usepackage[font=small,skip=5pt]{caption}
\newcommand*{\escape}[1]{\texttt{\textbackslash#1}}
\usepackage[format=plain,
            labelfont={it},
            textfont=it]{caption}
\captionsetup{justification=raggedright,singlelinecheck=false}
\date{\today}
\newcommand{\qq}{\symbol{34}}
\def \tabX {20pt}
\def \tabY {0pt}
\newcommand{\tab}[1]{
	\begin{adjustwidth}{\tabX}{\tabY}
	#1
	\end{adjustwidth}
}
\newcommand{\keyword}[1]{\colorbox{lightGray}{#1}}

\begin{document}

\maketitle
\dominitoc
\tableofcontents 

\chapter{Databasen}
\section{Syntaks}
For å beskrive databasens syntaks har jeg valgt å bruke kontekstfri grammatikk og Backus-Naur Form, heretter BNF, som notasjon.
\subsection*{Beskrivelse av notasjonen}
Tekst mellom vinkelparenteser (< og >) betegner navnet på en grammatikkregel hvis de står på venstre side av "::=", og henviser til en eksisterende grammatikkregel dersom den står på høyre side. Tekst inne i fnutter(" og "), er rene tekststrenger som skal skrives rett ut. Merk at tekststrengene vil bli skrevet med små bokstaver i syntaksoversikten, men at alle bokstaver endres til lower-case når spørringen leses inn, slik at hvorvidt bokstavene er store eller små ikke vil ha betydning. Pipe-symbolet(|) betyr at det finnes flere muligheter for å oppfylle regelen. Store bokstaver indikerer at selve verdien angis av brukeren selv.
Elementer omgitt av firkantparanteser ([ og ] betyr at elementet er frivillig.
\subsection{Query}
\label{sec:query}
Lar brukeren hente ut data fra en eller flere tabeller og eventuelt behandle dataene. \\

<query> ::= <from> [ <merge> ] [ <filter> ] <output> | \\

\subsubsection*{From}
<from> ::= "from" <tableList> \\
<tableList> :: =<table> | <table> "," <tableList> \\
<table> ::= TABLENAME | TABLENAME "as" ALIAS
\subsubsection*{Merge}
<merge> ::= "merge" <mergeTableList> "using" COLUMNNAME \\
<mergeTableList> ::= 
\tab{
<tablename> "and" <tablename> |  \\
<tablename> "and" <mergeTableList>
}
<tablename> ::= NAME | ALIAS
\subsubsection*{Filter}
<filter> ::= "filter" <predicateList> \\
<predicateList> ::= <predicate> | <predicate> <logicOperator> <predicateList> \\
<logicOperator> ::= "and" | "or" \\
<predicate> ::= 
\tab {
<expression> <predicateOperator> <expression> | \\
<columnName> <predicateFunction>
}
<expression> ::= ["("]<expression> <operator> <expression> [")"] | <value> \\
<operator> ::= "+" | "-" | "*" | "/" \\
<predicateOperator> ::= ">" | "<" | ">=" | "<=" | "=" | "!=" \\
<value> ::= <columnName> | LITTERAL \\
<predicateFunction> ::= <predicateFunctionName> "("<valueList>")" \\
<valueList> ::= <value> | <value> "," <valueList> \\
<predicateFunctionName> ::= "oneof" | "noneof" \\
<columnName> ::= 
\tab {
COLUMNNAME | \\
TABLENAME "." COLNAME | \\
TABLENAME "." COLNAME "." SUBCOLNAME \\
}

\subsection{Output}
Lar brukeren velge hvilke kolonner/uttrykk som skal skrives ut og eventuelle operasjoner som skal gjøres i hvert tilfelle. Hvilket kolonnenavn som blir gitt ved utskrift kan endres ved å benytte en alias(nøkkelordet named). En alias kan være spesielt aktuelt ved transformasjon på en kolonne eller ved utskrift av et uttrykk. Output støtter også pipelining av transformasjoner på dataen som skal skrives ut, men bare på en kolonne/uttrykk om gangen. Det er mulig å skrive ut flere kolonner i en enkelt operasjon, men da støttes ikke pipelining av dataene. Pipelining med flere kolonner ville både ha vært utfordrende å løse teknisk i tillegg til at oppførselen ville kunne ha forvirret brukeren. \\
\\
<output> ::= "output" <outputList> \\
<outputList> ::= <outputColumn> | <outputColumn> "," <outputList> \\
<outputColumn> ::= <expression> [<functionPipeline>] [<alias>] | <multiColumn> [<alias>] \\
<expression> ::= \textit{Se seksjon\ref{sec:query}: Filter \\}
<functionPipeline> ::= <function> | <function> "->" <functionPipeline> \\
<function> ::= "upper" | "lower" | "trimWhitespace" | "rmChar" \\
<alias> ::= "named" COLNAME \\
<multicolumn> ::= [TABLENAME"."]COLNAME".*" | [TABLENAME"."]COLNAME".{"<subcolList>}" \\
<subcolList> ::= SUBCOLNAME | SUBCOLNAME "," <subcolList> \\
\subsubsection*{Eksempel}
\textit{from Person as P, PersonWork as PW \\
		merge P and PW using personID \\
        filter department oneof("computers", "phones", "support") and \\
        salary > 100000 \\
        output name -> trimWhitespace -> capitalized,\\
        adress.\{streetName, streetNo\}
        }
\subsection{Insert}
\label{sec:insert}
Lar brukeren sette inn data i form av en eller flere rader i en tabell. Tabellen må være oprettet på forhånd. Dersom en eller flere kolonner ikke spesifiseres vil databasen enten sette kolonneverdien til standardverdien, hvis den ble spesifisert ved opprettelse av tabellen, eller gi en feilmelding dersom kolonnen ikke har noen standardverdi. For spesifisering av kolonner benyttes utelukkende navnet på kolonnen/subkolonnen.\\

<insert> ::= "insert rows into" TABLE <rowlist> \\
<rowlist> ::= <row> | row "," <rowlist> \\
<row> ::= "(" <columnValueList> ")" \\
<columnValueList> ::= 
\tab{
<columnValue> | \\
<columnValue> "," <columnValueList>
}
<columnValue> ::= <keyValue> | <subkeyValues> \\
<keyValue> ::= COLNAME ":" <expression> \\
<subkeyValues> ::= COLNAME ":\{"<keyValueList>"\}" \\
<keyValueList> ::= <keyValue> | <keyValue> "," <keyValueList> \\


\subsection{Remove}
Lar brukeren slette rader fra en tabell som stemmer med en eller flere predikater.
<remove> ::= "remove rows from" TABLENAME "WHERE" <predicateList>
<predicateList> ::= \textit{Se seksjon \ref{sec:query}: Filter}


\subsection{Update}
Lar brukeren endre verdi på eksisterende celler. Ved endring settes de kolonner som ønskes å endres på samme måte som nevnt i seksjon \ref{sec:insert} men i tilegg kan den reserverte variabelen OLD benyttes i uttrykkene å henvise til den gjeldende verdien. \\
<update> ::= "update" TABLENAME "where" <predicateList> "set" <columnValueList> \\
<predicateList> ::= \textit{Se seksjon \ref{sec:query}: Filter} \\
<columnValueList> ::= \textit{Se seksjon \ref{sec:insert}}



\subsection{Create}
\label{sec:create}
Lar brukeren opprette en ny tabell. Alle kolonene må ha datatyper spesifisert og det er mulig å la kolonnene ha en standardverdi.
\subsubsection*{Datatyper}
Databasen har tre datatyper:
\begin{itemize}
\item boolean: enten true eller false
\item number: et flyttall-nummer, men kan spesifiseres uten desimaler
\item string: en vilkårlig tekststreng
\end{itemize}
<create> ::= "create table"  TABLENAME "with columns" <columnList>\\
<columnList> ::= <column> | <column> "," <columnList>\\
<column> ::= <nameDatatype> | COLNAME ":\{"<nameDatatypeList>"\}"\\
<nameDatatype> ::= COLNAME "of" <datatype> ["default" LITTERAL] \\
<nameDatatypeList> ::= <nameDatatype> | <nameDatatype> "," \\
<datatype> ::= "string" | "boolean" | "number"\\

Eksampler på oppbrytning av de ulike delene.


\section{Lagring}
\subsection{Metadata}
Informasjon om hver enkelt tabell ligger lagret i en separat fil. Årsaken til at dataen og metadataen ikke ligger i samme fil er at det blir enklere å kun lese inn den informasjonen som er nødvendig. Eksempelvis vil det kun være nødvendig å lese inn metadataen for å sette inn ny data. Metadatafilen inneholder navn på de ulike feltene i tillegg til typen for feltet og eventuelt en standardverdi. Filen har slik syntax:

<entryList> ::= <entry> | <entry>";"<entryList> \\
<entry> ::=  <singleEntry> | <nestedEntry> \\
<singleEntry> ::= COLNAME{\qq}\{<datatype>[,<defaultValue>]\}{\qq}  \\
<nestedEntry> ::= COLNAME{\qq}(<singleEntryList>){\qq} \\
<singleEntryList> ::= 
\tab{
<singleEntry> | \\
<singleEntry><singleEntryList> 
}
<datatype> ::= s | i | b
<defaultValue> ::= LITTERAL \\

\subsubsection*{Eksempel}
\textit{Name\{s,"John Doe"\};Phone\{i\};Adress(StreetName\{s\}StreetNo\{i\})}

\subsection{Data}
Selve dataen lagres på et enkelt, CSV-linkende format. Formatet er valgt for å være enkelt å lese for både mennesker og maskiner i tillegg til å ta lite plass og være flyttbart. Siden lagringen benytter plassering for å bestemme de ulike feltene, er programmet avhengig av metadatafilen for å kunne skille mellom de ulike feltene. Et felt kan være tomt. Hvis en standardverdi er satt benyttes denne. Hvis ikke vil programmet avslutte med en feilmelding. Filen har slik syntax:\\
<rowList> ::= <row> | <row>{\qq}\escape{n}{\qq}<rowList> \\
<row> ::= <columnList> \\
<columnList> ::= <column> | <column>{\qq};{\qq}<columnList>\\
<column> ::= <flat> | <nested>\\
<flat> ::= LITTERAL\\
<nested> ::= "(<flatList>)"\\
<flatList> ::= <flat> | <flat>{\qq};{\qq}<flatList>\\

\subsubsection*{Eksempel}
\textit{{\qq}Per Olsen{\qq};67284771;({\qq}Einerveien{\qq};18)\\
        ;88341821;({\qq}Lierveien{\qq};2)}
\chapter{Funskjonell Progammering}
\section{Hva er funksjonell programmering?}
Si noe om hva man legger i imperativ/objektorientert
en teknikk, ikke et språk. Muligheten for funksjonell programmering i imperative språk, eksemplifisere med c.
\section{Konstanter fremfor variabler}
\section{Rekursjon og deklarativ programmering}
\subsection*{Hva er rekursjon?}
Rekursjon går ut på at en funksjon kaller seg selv, noe som innebærer at funksjonen bruker seg selv som et steg på veien til løsningen av et problem. I noen tilfeller vil rekursjonen oppføre seg litt som en konvensjonell løkke, men i andre tilfeller vil rekursjonens virkemåte være grunnleggende anderledes. Spesielt den siste måten kan man argumentere for at lar deg løse problemer på en mye mer elegant måte enn tilfellet hadde vært uten rekursjon, selv om problemet fortsatt kan løses iterativt. Rapporten kommer tilbake til de to nevnte virkemåtene seinere.\\ \\
Rekursjon er en teknikk som er tilgjengelig i så godt som alle moderne programmeringsspråk. Grunnen er at de fleste språk har en kall-stack og at det i prinsipp ikke spiller noen rolle hvilken funksjon som blir kalt på.På tross av at tilgjengeligheten til teknikken blir den ofte mye mer brukt i forbindelse med funksjonell programmering enn den gjør i imperativ. Årsakene til dette er flere men blant annet er rekursjon i enkelte språk er eneste mulighet for å gjenta kode på en organisert måte(løkker) i tillegg til at rekursjon er et uvurderlig verktøy i den funksjonelle verktøykassen. Rekursjon og funksjonell programmering går på mange måter hånd i hånd.
\subsection*{Hvorfor rekursjon i funksjonell programmering?}
En måte å angripe problemet på er å heller spørre: Hvorfor ikke løkker i funksjonell programmering? Mange av grunnene til dette kommer fra løkkenes natur og virkemåte. En løkke består som regel av en kodeblokk og en betingelse som sjekkes for hver gang kodeblokken eventuelt blir gjentatt. De fleste språkene har også en løkkevariant der initialisering av løkkevariabler, mutering av variabler og løkke-betingelsen er kombinert. Uavhengig av hvilken løkke-variant man benytter så er det gitt at uttrykket i betingelsen må få verdien endret på en eller annen måte, hvis man vil unngå at løkken kjører ut i det uendelige. Eneste mulighetene for dette blir enten at uttrykket bruker en ikke-deterministisk funksjon (f.eks en randomfunskjon) eller mer vanlig, at en eller flere variabler muteres inne i kodeblokken, eller i betingelseblokken hvis man bruker for-løkker. Løkkenes muterende natur innebærer at løkker strider mot grunnleggende prinsipper i funksjonell programmering. Alternativet blir derfor rekursjon. Det må også legges til at mange moderne språk tilbyr iterator-baserte løkker, f.eks ved bruk av \textit{for(Type navn: liste) }i Java, som er mye mer funksjonelle i natur.
\subsection*{Fordeler og ulemper}
\subsubsection*{Lesbarhet og forståelse av koden}
Denne seksjonen skal ta for seg en algoritme for å skrive ut en tekstelig repsetantasjon av et binært tre i funksjonell og iterativ stil for deretter å sammenlikne semantikk og lesbarheten til koden.

\begin{minted}{sml}
 fun treeToStr(exprTree: ExprTree) = 
    case exprTree of
        Node(left,value,right) =>  
          Util.format("Tree( Val:$ L:$ R:$ )", 
            [getValue(value), exprTreeToStr(left),exprTreeToStr(right)])
       |EmptyNode => ""
       |treeLit(lit) => getValue(lit) 
   end 
\end{minted}
\textit{Funksjonen bruker preorder-traverering til å rekursivt lage en tekstelig representasjon av et tre. Util.format er en funksjon for tekstformatering, på samme måte som System.out.printf i Java. Dollartegnet henviser til en tekstbit som skal byttes ut med samsvarende element i listen gitt som argument. Denne funksjonen benyttes til feilsøking i databasen for å skrive ut uttrykkstrær. Eksempelvis vil uttrykket 1+2+3 få denne tekstlig reprsetntasjonen:Tree( Val:+ L:1.0 R:Tree( Val:+ L:2.0 R:3.0 ) ). Legg merke til at visse deler av uttrykket vil bli regnet ut før det blir lagt til i treet(Dette er tilfellet for deler med høy predesens slik som divisjon og multiplikasjon).
}

\begin{minted}{java}
   public static String treeToStr (Tree treeRoot){
        Stack<Tree> treeStack = new Stack<>();
        treeStack.add(treeRoot);

        String str = "";
        while (!treeStack.isEmpty()){
            Tree curr = treeStack.pop();
            if(curr != null){
                str += (String.format("%s (Val: %s ",curr.getType(), curr.value));

                treeStack.push(curr.right);
                treeStack.push(curr.left);
            }
            else{
                str += (")");
            }
        }
        return  str;
    }
\end{minted}
\textit{Funksjonen bruker en stack for å skrive ut treet. For hver node skrives verdien tio noden ut og høyre og venstre tre legges til i stacken. Dette holder på intill stacken er tom, noe som medfører at vi har nådd bånn av treet. Funksjonen getType finner ut om noen som skries ut er en rotnode,venstrenode eller høyrenode}

Hvis man studerer de to kodesnuttene kan man legge merke til at den funksjonelle er mer konsis med tanke på antall linjer kode, men kanskje mer tydelig: Den angriper problemet på en grunnleggende annerledes måte. I stedet for å eksplisitt definere de ulike stegene i algoritmen, bruker man en mer deklarativ stil. I deklarativ programmering kan utvikleren konsentrere seg om \textit{hva} som skal bli beregnet, uten nødvendigvis å måtte tenke på eller definere \textit{hvordan} dette skal gjøres\cite{declarative_programming}. Sagt på en annen måte- deklarativ programmering innebærer at utvikleren definerer logikken, men ikke programflyten. Dette medfører at elementer som if-setninger, løkker, og nøkkelord som \textit{continue} og \textit{break} ikke benyttes. SQL er kanskje det mest kjente eksempelet på deklarativ programmering. Regulæruttrykk, selv om det ikke er et programmeringsspråk men heller et domespesifikt språk, er også et godt eksempel. I den funksjonelle kodesnutten kan man se dette i praksis ved at algoritmen ikke har elementer av kontrollflyt, men heller definerer "regler" for ulike scenarioer av input. Dessuten vil man enklere kunne få et inntrykk av hvordan den endelige strengen vil kunne se ut, kun ved å se på linjen for strengformateringen. Deklarative programmering har som effekt at utvikleren opererer på et høyere nivå av abstraksjon. Dette er noe som kan bidra til kode som både er enklere å lese og forstå fordi tekniske implementerings-detaljer blir utelatt. Pattern-macthing er også en mekanisme som kan sies å tilhøre denne stilen, og man ser eksempel på denne mekanismen i den funksjonelle versjonen av tre-til-streng algoritmen. Pattern-matching vil bli diskutert i større detalj senere i rapporten. 

Knyttet opp mot rekursjon vil den deklarative stilen innebære at utvikleren ikke trenger å definere hvordan kodeblokkene blir gjentatt(gjennom løkker og logikken som styrer løkken). I algortimer for  traversering av rekursive strukturer slik som binær og filtrær og divide-and-qonqeur algoritmer(slik som quicksort) kommer fordelene tydeligst frem. Dette er fordi den rekursiv løsningen vil abstrahere bort konseptet med en stack som utvikleren eksplisitt må håndtere og dermed også øke lesbarheten betraktelig. I andre tilfeller er muligens ikke fordelene like åpenbare.\\
\\
På den andre siden kan deklarativ programmering gi utvikleren et mer utydelig inntrykk av hva som faktisk foregår. Dette er fordi den faktiske logikken og programflyten blir gjemt bort under mange lag med abstraksjon. Mulighetene for optimalisering og spesialtilpassing blir også mindre av samme grunn. Et annet aspekt er at høytnivåkonseptene som følger med deklarativ programmering kan være utfordrende å forstå siden mange av begrepene er svært abstrakte og fordi det kan være vanskelig å finne en konkret parallell i den virkelige verden. For eksempel kan en løkke være enklere å forstå enn rekursjon og en iterativ variant som finner summen av elementene i en liste være mer intuitiv enn å bruke \textit{reduce/fold}.\\
\\
Den deklarative stilen i det første eksempelet gjør at funksjonen vil kunne være både enklere å skrive og lese. Likevel krever den rekursive løsningen at utvikleren har kjennskap til og erfaring med rekursive algoritmer. Uten dette kan rekursive funksjoner være svært krevende å forstå, og ikke minst feilsøke, spesielt rekursjon som ikke er halerekursiv eller multirekursjon. En av grunnene til dette er måten utvikleren kan få en forståelse for virkemåten til algoritmen. Ved en iterativ variant kan vedkommende gå gjennom algoritmen på en lineær måte og holde styr på tilstanden til programmet. Denne varianten vil for mange være mer naturlig og har også den fordelen at den vil kunne være enklere å feilsøke med en konvensjonell debugger. Den rekursive varianten er mer todimensjonal av natur ved at programflyten ikke bar går nedover, men også innover og utover. Dette medfører at for å gå gjennom og få en forståelse for algoritmen må man danne seg en fysisk eller mental stack og bevege seg nedover og oppover kalltreet, eventuelt skrible ned kallstacken på et papir. Det skal sies at dersom man har kjennskap til rekursjon, vil denne oppgaven bli enklere, men det vil fremdeles kreve en viss mental kapasitet med å lese og forstå mer komplekse rekursive algoritmer, spesielt når det ikke er deg selv som er forfatter.\\


\begin{figure}[H]
\caption{Funksjon for å fjerne kommentarer fra kildekode(Standard ML)}
\label{fig:rmComments}
\begin{minted}{sml}
fun rmComments(lines: string list):string list =
  case lines of
    (x::xs) =>
    let
      val substr = strToSs(x)
      val (noComment, comment) = Substring.splitl (fn c => c <> #"#") substr
    in
      ssToStr(noComment) :: rmComments(xs)
    end
    |[] => []
\end{minted}
\end{figure}
\textit{Funksjonen fjerner alle karakterer fra og med \#-tegnet for første streng i listen som sendes inn. splitl deler opp en streng ved hjelp av en predikatfunksjon som blir kjørt på hver enkelt karakter.  Delen uten kommentarer konkatineres med resultatet av å kalle funksjonen rekursivt på resten av listen}
\label{fig:kalltreRmComments}
\begin{figure}[H]
Strengen som sendes inn: \\
\textit{from Person as P \#P er en alias \\
		filter department = "IT" \#Bare datafolkene \\
        output name,salary \#Grunnleggende info \\
        }
 \caption{Kalltre for funksjonen i figur \ref{fig:rmComments}}
\begin{minted}{sml}
"from Person as P" :: rmComments("filter department = IT #Bare datafolkene 
        			  output name,salary #Grunnleggende info")
	"filter department = IT" :: rmComments("output name,salary #Grunnleggende info")
    	"output name, salary"

\end{minted}
\end{figure}


\subsection*{Effektivitet}
Rekursjon blir i mange tilfeller foretrukket fremfor løkker i en rekke funksjonelle språk, mens teknikken ofte er reservert til spesielle tilfeller slik som traversering av trær i mer imperative språk. En betydelig grunn til dette er måten de ulike kompilatorene og interpreterne implementerer rekursjonen, spesifikt om de tilbyr hale-rekursjon-optimalisering eller ikke.


For hvert rekursive kall opprettes en stackframe som lagres på kallstacken. Inne i hver stackframe lagres blant annet parameterverdier, lokale variabler(ikke i dette tilfellet) og posisjonen i koden det skal fortsettes fra etter at funksjonen har returnert. I figur \ref{fig:kalltreRmComments} kan man se at måten den rekursive funksjonen kjører på medfører at tillstanden til funksjonen(i dette tilfellet strengen før ::) må lagres slik at denne strengen kan bli konkatinert på et senere tidspunkt når rekursjonen trekker seg oppover. I dette tilfellet vil man da få laget 3 stackframes før rekursjonen trekker seg opp igjen, noe som vil medføre ekstra  minnebruk og ekstra operasjoner med å legge til og fjerne frames fra kallstacken. Hale-kall optimalisering vil kunne eliminere de nevnte ulempene ved å transformere enkelte former for rekursjon til vanlig iterasjon. Funksjonen for å fjerne kommentarer er et trivielt eksempel som ikke drar nevneverdig effekt av en slik optimalisering, men hvis rekursjonen hadde vært svært dyp hadde man fått veldig mange stackframes, noe som potensielt kunne ha fylt opp kallstacken og i verste tilfelle medført en stack-owerflow exception i tillegg til å gjort algoritmen mer ressurskrevende å kjøre. I seksjon \ref{sec:hastighetestester} demonstreres slik dyp rekursjon der en funksjon testes med 100 000 til 100 millioner rekursive funksjonskall, med og uten halekall-optimalisering. 
\\


For at en komplilator skal kunne utføre hale-kall-optimalisering må rekursjonen være implementert på en bestemt måte- det rekursive kallet må være det siste som utføres i funksjonen. Dette innebærer at den rekursive funksjonen kun har ett rekursivt kall, og at det ikke akkumuleres verdier ved å kalle på rekursive funksjoner slik som \textit{ssToStr(noComment) :: rmComments(xs)} i figur \ref{fig:rmComments}.Poenget med at den rekursive delen er den siste medfører at algoritmer som naturlig implementeres med multi-rekursjon slik som traversering av trær, må bli skrevet om og få ganske annerledes logikk i forhold til løsningen med multi-rekursjon. \\

\begin{figure}[H]
\caption{Funksjon for å fjerne kommentarer fra kildekode, halerekursiv(Standard ML)}
\label{fig:rmCommentsTailrec}
\begin{minted}{sml}
 fun rmCommentsTailrec(inpLines: string list):string list =
   let fun rmTailRec(inpLines:string list, result:string list) = 
    case inpLines of
      (x::xs) =>
     let 
        val substr = Util.strToSs(x)
        val (noComment, comment) = Substring.splitl (fn c => c <> #"#") substr
      in  
        rmTailRec(xs, Util.ssToStr(noComment) :: result)
      end 
      |[] => rev(result)
    in
      rmTailRec(inpLines,[])
   end

\end{minted}
\end{figure}
Funksjonen i figur \ref{fig:rmComments} er transformert til å være halerekursiv. Den utfører samme oppgaven som tidligere, men for at den skal oppfylle kravene for halerekursivitet er den blitt refaktorert til å benytte en indre funksjon og et akkumulator-parameter i stedet for å akkumulere rekursivt. Den nye implementeringen medførte også et par andre små endringer, men totalt sett var endringen relativt fort gjort. At refaktoreingen var lite krevende er ikke alltid tilfellet. Eksempelvis benytter den halerekursive varianten av funksjonen for å beregne det n-te fibbonacci tallet en helt anderledes logikk enn varianten med ordinær rekursjon.

Siden det rekursive kallet er det siste som blir utført i en halerekursiv funksjon, trenger ikke lokale variabler eller posisjon for returnering å bli lagret.  Fordi rekursjonen aldri kommer til å trekke seg opp igjen, men kun kalle seg selv med endrede parameterverdier vil det nemlig ikke være noen grunn for at rekursjonen skal måtte gå "tilbake". På grunnlag av dette kan kompilatoren optimalisere bak kulissene slik at flere stackframes ikke opprettes og at rekursjonen i stedet blir omgjort til normal iterasjon, med de hastighetsforbedringene dette medfører. Hvis man har en kompilator som genererer Assembly vil hale-rekursjonen kunne bli konvertert til en goto, noe som vil gi svært god ytelse. Uoptimalisert rekursjon i Assembly innebærer at  stackframes må pushes og poppes i tillegg til at parameterne må kopieres(hvis man har pass-by-value slik som StandardML). Flere operasjoner medfører mer jobb for CPU-en og dermed lavere ytelse. Dersom koden blir omgjort til iterasjon vil man unngå de ekstra operasjonene og i stedet bruke ett sett med løkkevariabler som blir mutert. Standard ML er et språk der de mest populære kompilatorene har halekall-optimalisering, noe man vil kunne se tydelig utsalg for på ytelsestester.


\subsubsection{Hastighetstester}
\label{sec:hastighetestester}
For å teste forskjeller i effektivitet mellom ordinær rekursjon og halerekursjon benyttes en funksjon til å summere elementene i en liste.
\label{fig:sumSML}
\begin{figure}[H]
\begin{minted}{sml}
fun sum [] = 0
   |sum(x::xs) = x + sum(xs)
\end{minted}
\caption{Sum av elementene i en liste (Standard ML)}
\end{figure}
Funksjonen legger rekursivt sammen verdien til første element(x) pluss summen til resten av lista(xs). Dersom lista er tom er summen 0.

\begin{minted}{sml}
fun sumTail(l) = 
let fun sumFrom([], summed) = summed
	   |sumFrom(x::xs, summed) = sumFrom(xs,summed + x)
in
	sumFrom(l, 0)
end
\end{minted}
\begin{center}
\begin{tabular}{|r | r| r| r|}
\hline
\rowcolor{lightGray} Funksjon & Vanlig & Hale-rekursjon & Forbedring \\
\hline
sum: 100 000 & 16.6 msek & 13.3 msek & 24.8\% \\
\hline
sum: 1 million & 30.3 msek & 21.6 msek & 40\% \\
\hline
sum: 100 millioner & 182 msek & 3336 msek & 1732\% \\
\hline 
\end{tabular}
\end{center}
Vi ser av resultatene ovenfor at hale-rekursjon-optimalisering gir betydelige forbedringer med tanke på effektivitet, spesielt når problemstørrelsen øker.

\subsection*{Oppsummering}
I databasen blir rekursjon benyttet hyppig. Dette har flere effekter- blant annet kode som er mer kompakt og i mange tilfeller også som kan oppleves som mer lesbar. Det er forbundet en viss lærignskurve med den rekursive stilen, men etter å ha mestret teknikken føles rekursjon i mange tilfeller mer naturlig. Noen av årsaken til dette kan være at man får kode på et høyere nivå som også er mer deklarativ. Andre årsaker kan være at man deler opp problemet i stadig mindre biter og ender opp med å løse problemet når det er svært enkelt(typisk for f.feks mergesort). Å delete opp et problem i mindre deler er en svært kjent taktikk i dagliglivet(tenk feks matlaging) og dette kan være ett av elementene som gjør rekursjon intuitivt for visse problemer.
\bibliographystyle{plain}

\section{Funksjonelle datastrukturer og organisering av kode}
algebraiske datatyper og deres bruk i pattern matching
hvordan strukturer, signaturer og functors relaterer til oop
\bibliography{refs}
\end{document}
