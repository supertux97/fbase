\documentclass{report}
\input{sml.tex}
\title{Funksjonell programmering gjennom utvikling av et spørrespråk}
\author{Erlend \O
stlie}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{changepage}

\usepackage[backend=biber]{biblatex}
\addbibresource{refs.bib}

\usepackage{url}
\definecolor{lightGray}{rgb}{0.90, 0.90, 0.90}

\usepackage[a4paper, total={6in, 8in}]{geometry}
\usepackage{graphicx}
\usepackage{minitoc}
\usepackage{minted}
\usepackage{geometry}
\usepackage{float}
\usepackage{color, colortbl}
\usepackage{parskip}
\usepackage[norsk]{babel}
\usepackage[font=small,skip=5pt]{caption}
\newcommand*{\escape}[1]{\texttt{\textbackslash#1}}
\usepackage[format=plain,
            labelfont={it},
            textfont=it]{caption}
\captionsetup{justification=raggedright,singlelinecheck=false}
\date{\today}
\newcommand{\qq}{\symbol{34}}
\def \tabX {20pt}
\def \tabY {0pt}
\newcommand{\tab}[1]{
	\begin{adjustwidth}{\tabX}{\tabY}
	#1
	\end{adjustwidth}
}
\newcommand{\keyword}[1]{\colorbox{lightGray}{#1}}

\begin{document}

\maketitle
\dominitoc
\tableofcontents 

\chapter{Databasen}
\section{Syntaks}
For å beskrive databasens syntaks har jeg valgt å bruke kontekstfri grammatikk og Backus-Naur Form, heretter BNF, som notasjon.
\subsection*{Beskrivelse av notasjonen}
Tekst mellom vinkelparenteser (< og >) betegner navnet på en grammatikkregel hvis de står på venstre side av "::=", og henviser til en eksisterende grammatikkregel dersom den står på høyre side. Tekst inne i fnutter(" og "), er rene tekststrenger som skal skrives rett ut. Merk at tekststrengene vil bli skrevet med små bokstaver i syntaksoversikten, men at alle bokstaver endres til lower-case når spørringen leses inn, slik at hvorvidt bokstavene er store eller små ikke vil ha betydning. Pipe-symbolet(|) betyr at det finnes flere muligheter for å oppfylle regelen. Store bokstaver indikerer at selve verdien angis av brukeren selv.
Elementer omgitt av firkantparanteser ([ og ] betyr at elementet er frivillig.
\subsection{Query}
\label{sec:query}
Lar brukeren hente ut data fra en eller flere tabeller og eventuelt behandle dataene. \\

<query> ::= <from> [ <merge> ] [ <filter> ] <output> | \\

\subsubsection*{From}
<from> ::= "from" <tableList> \\
<tableList> :: =<table> | <table> "," <tableList> \\
<table> ::= TABLENAME | TABLENAME "as" ALIAS
\subsubsection*{Merge}
<merge> ::= "merge" <mergeTableList> "using" COLUMNNAME \\
<mergeTableList> ::= 
\tab{
<tablename> "and" <tablename> |  \\
<tablename> "and" <mergeTableList>
}
<tablename> ::= NAME | ALIAS
\subsubsection*{Filter}
<filter> ::= "filter" <predicateList> \\
<predicateList> ::= <predicate> | <predicate> <logicOperator> <predicateList> \\
<logicOperator> ::= "and" | "or" \\
<predicate> ::= 
\tab {
<expression> <predicateOperator> <expression> | \\
<columnName> <predicateFunction>
}
<expression> ::= ["("]<expression> <operator> <expression> [")"] | <value> \\
<operator> ::= "+" | "-" | "*" | "/" \\
<predicateOperator> ::= ">" | "<" | ">=" | "<=" | "=" | "!=" \\
<value> ::= <columnName> | LITTERAL \\
<predicateFunction> ::= <predicateFunctionName> "("<valueList>")" \\
<valueList> ::= <value> | <value> "," <valueList> \\
<predicateFunctionName> ::= "oneof" | "noneof" \\
<columnName> ::= 
\tab {
COLUMNNAME | \\
TABLENAME "." COLNAME | \\
TABLENAME "." COLNAME "." SUBCOLNAME \\
}

\subsection{Output}
Lar brukeren velge hvilke kolonner/uttrykk som skal skrives ut og eventuelle operasjoner som skal gjøres i hvert tilfelle. Hvilket kolonnenavn som blir gitt ved utskrift kan endres ved å benytte en alias(nøkkelordet named). En alias kan være spesielt aktuelt ved transformasjon på en kolonne eller ved utskrift av et uttrykk. Output støtter også pipelining av transformasjoner på dataen som skal skrives ut, men bare på en kolonne/uttrykk om gangen. Det er mulig å skrive ut flere kolonner i en enkelt operasjon, men da støttes ikke pipelining av dataene. Pipelining med flere kolonner ville både ha vært utfordrende å løse teknisk i tillegg til at oppførselen ville kunne ha forvirret brukeren. \\
\\
<output> ::= "output" <outputList> \\
<outputList> ::= <outputColumn> | <outputColumn> "," <outputList> \\
<outputColumn> ::= <expression> [<functionPipeline>] [<alias>] | <multiColumn> [<alias>] \\
<expression> ::= \textit{Se seksjon\ref{sec:query}: Filter \\}
<functionPipeline> ::= <function> | <function> "->" <functionPipeline> \\
<function> ::= "upper" | "lower" | "trimWhitespace" | "rmChar" \\
<alias> ::= "named" COLNAME \\
<multicolumn> ::= [TABLENAME"."]COLNAME".*" | [TABLENAME"."]COLNAME".{"<subcolList>}" \\
<subcolList> ::= SUBCOLNAME | SUBCOLNAME "," <subcolList> \\
\subsubsection*{Eksempel}
\textit{from Person as P, PersonWork as PW \\
		merge P and PW using personID \\
        filter department oneof("computers", "phones", "support") and \\
        salary > 100000 \\
        output name -> trimWhitespace -> capitalized,\\
        adress.\{streetName, streetNo\}
        }
\subsection{Insert}
\label{sec:insert}
Lar brukeren sette inn data i form av en eller flere rader i en tabell. Tabellen må være oprettet på forhånd. Dersom en eller flere kolonner ikke spesifiseres vil databasen enten sette kolonneverdien til standardverdien, hvis den ble spesifisert ved opprettelse av tabellen, eller gi en feilmelding dersom kolonnen ikke har noen standardverdi. For spesifisering av kolonner benyttes utelukkende navnet på kolonnen/subkolonnen.\\

<insert> ::= "insert rows into" TABLE <rowlist> \\
<rowlist> ::= <row> | row "," <rowlist> \\
<row> ::= "(" <columnValueList> ")" \\
<columnValueList> ::= 
\tab{
<columnValue> | \\
<columnValue> "," <columnValueList>
}
<columnValue> ::= <keyValue> | <subkeyValues> \\
<keyValue> ::= COLNAME ":" <expression> \\
<subkeyValues> ::= COLNAME ":\{"<keyValueList>"\}" \\
<keyValueList> ::= <keyValue> | <keyValue> "," <keyValueList> \\


\subsection{Remove}
Lar brukeren slette rader fra en tabell som stemmer med en eller flere predikater.
<remove> ::= "remove rows from" TABLENAME "WHERE" <predicateList>
<predicateList> ::= \textit{Se seksjon \ref{sec:query}: Filter}


\subsection{Update}
Lar brukeren endre verdi på eksisterende celler. Ved endring settes de kolonner som ønskes å endres på samme måte som nevnt i seksjon \ref{sec:insert} men i tilegg kan den reserverte variabelen OLD benyttes i uttrykkene å henvise til den gjeldende verdien. \\
<update> ::= "update" TABLENAME "where" <predicateList> "set" <columnValueList> \\
<predicateList> ::= \textit{Se seksjon \ref{sec:query}: Filter} \\
<columnValueList> ::= \textit{Se seksjon \ref{sec:insert}}



\subsection{Create}
\label{sec:create}
Lar brukeren opprette en ny tabell. Alle kolonene må ha datatyper spesifisert og det er mulig å la kolonnene ha en standardverdi.
\subsubsection*{Datatyper}
Databasen har tre datatyper:
\begin{itemize}
\item boolean: enten true eller false
\item number: et flyttall-nummer, men kan spesifiseres uten desimaler
\item string: en vilkårlig tekststreng
\end{itemize}
<create> ::= "create table"  TABLENAME "with columns" <columnList>\\
<columnList> ::= <column> | <column> "," <columnList>\\
<column> ::= <nameDatatype> | COLNAME ":\{"<nameDatatypeList>"\}"\\
<nameDatatype> ::= COLNAME "of" <datatype> ["default" LITTERAL] \\
<nameDatatypeList> ::= <nameDatatype> | <nameDatatype> "," \\
<datatype> ::= "string" | "boolean" | "number"\\

Eksampler på oppbrytning av de ulike delene.


\section{Lagring}
\subsection{Metadata}
Informasjon om hver enkelt tabell ligger lagret i en separat fil. Årsaken til at dataen og metadataen ikke ligger i samme fil er at det blir enklere å kun lese inn den informasjonen som er nødvendig. Eksempelvis vil det kun være nødvendig å lese inn metadataen for å sette inn ny data. Metadatafilen inneholder navn på de ulike feltene i tillegg til typen for feltet og eventuelt en standardverdi. Filen har slik syntax:

<entryList> ::= <entry> | <entry>";"<entryList> \\
<entry> ::=  <singleEntry> | <nestedEntry> \\
<singleEntry> ::= COLNAME{\qq}\{<datatype>[,<defaultValue>]\}{\qq}  \\
<nestedEntry> ::= COLNAME{\qq}(<singleEntryList>){\qq} \\
<singleEntryList> ::= 
\tab{
<singleEntry> | \\
<singleEntry><singleEntryList> 
}
<datatype> ::= s | i | b
<defaultValue> ::= LITTERAL \\

\subsubsection*{Eksempel}
\textit{Name\{s,"John Doe"\};Phone\{i\};Adress(StreetName\{s\}StreetNo\{i\})}

\subsection{Data}
Selve dataen lagres på et enkelt, CSV-linkende format. Formatet er valgt for å være enkelt å lese for både mennesker og maskiner i tillegg til å ta lite plass og være flyttbart. Siden lagringen benytter plassering for å bestemme de ulike feltene, er programmet avhengig av metadatafilen for å kunne skille mellom de ulike feltene. Et felt kan være tomt. Hvis en standardverdi er satt benyttes denne. Hvis ikke vil programmet avslutte med en feilmelding. Filen har slik syntax:\\
<rowList> ::= <row> | <row>{\qq}\escape{n}{\qq}<rowList> \\
<row> ::= <columnList> \\
<columnList> ::= <column> | <column>{\qq};{\qq}<columnList>\\
<column> ::= <flat> | <nested>\\
<flat> ::= LITTERAL\\
<nested> ::= "(<flatList>)"\\
<flatList> ::= <flat> | <flat>{\qq};{\qq}<flatList>\\

\subsubsection*{Eksempel}
\textit{{\qq}Per Olsen{\qq};67284771;({\qq}Einerveien{\qq};18)\\
        ;88341821;({\qq}Lierveien{\qq};2)}
\chapter{Funskjonell Progammering}
\section{Hva er funksjonell programmering?}
Si noe om hva man legger i imperativ/objektorientert
en teknikk, ikke et språk. Muligheten for funksjonell programmering i imperative språk, eksemplifisere med c.

Funksjonell programmering, er et programmeringsparadigme. Et programmeringsparadigme kan defineres på ulike måter, men én definisjon er at det er en måte eller stil koden blir skrevet på og organisert på. Det er viktig å legge vekt på at funksjonell programmering kun er en stil, og ikke en bestemt gruppe med språk. Det er fullt mulig å skrive i den funksjonelle stilen i språk som ofte ikke regnes som funksjonelle, slik som C, men opplevelsen vil ofte bli bedre dersom man benytter språk spesielt laget for funksjonell programmering, slik som Standard ML. 

Imperativ programmering og paradigmets populære underkategorier objektorientert og prosedyrisk programmering er de dominerende paradigmene i dag. En abstrakt definisjon på forskjellen mellom det imperative og det funksjonelle paradigmet kan være at det imperative er basert på turingmaskiner, mens det funksjonelle er basert på lambda-calculus. Denne forskjellen gjør funksjonell programmering til et på mange måter grunnleggende annerledes paradigme; i det funksjonelle paradigmet skapes resultatene ved å la dataen flyte og transformeres gjennom funksjoner(funksjoner i matematisk forstand), fremfor at  tilstanden til programmet stegvis blir mutert inntil resultatet er skapt. At man unngår å endre tilstanden til programmet er en essensiell og avgjørende egenskap ved funksjonell programmering, og rapporten vil komme tilbake til hvilke implikasjoner dette vil ha på koden og på utviklingsprosessen. Funksjonell programmering regnes i tillegg som en underkategori av deklarativ programmering, noe rapporten også vil nevne. Paradigmet sin deklarative natur og det faktum at man unngår mutering, baner i tillegg vei for rekursjon, noe som også vil bli drøftet. Sist vil rapporten se på hvordan funksjonell programmering fungerer i større skala, med tanke på gjenbruk og abstraksjon, utvidbarhet og organisering av koden. Hensikten med rapporten er å se hvordan de ulike aspektene med funksjonell programmering kommer til uttrykk i praktisk programvareutvikling, og i dette tilfellet, utvikling av et spørrespråk for en database.\\

\section{Konstanter fremfor variabler}
\textit{NB! avsnitt ikke ferdig}
Fordel: enklere å se om verdien/objektet man får fra en funksjon er den samme som det sendt inn. I imperativ må man lagre en kopi og deretter sjekke alle feltene, i funksjonell kan man sjekke id-en/minneadressen til objektet. Har objektene samme minneadresse er det ingen mulighet for at det kan ha blitt endret siden et objekt ikke kan bli endret i den funksjonelle stilen.

\section{Rekursjon og deklarativ programmering}
\subsection*{Hva er rekursjon?}
Rekursjon går ut på at en funksjon kaller seg selv, noe som innebærer at funksjonen bruker seg selv som et steg på veien til løsningen av et problem. I noen tilfeller vil rekursjonen ha semantikk og oppførsel med likhetstrekk til konvensjonelle løkker, men i andre tilfeller vil rekursjonens virkemåte være grunnleggende annerledes. Spesielt i det siste tilfellet kan man argumentere for at rekursjon lar deg løse problemer på en mye mer elegant måte enn tilfellet hadde vært uten rekursjon. Rapporten kommer tilbake til dette senere. Deklarativ programmering er et annet aspekt som er tet knyttet opp mot funksjonell programmering og også på noen måter, rekursjon. Denne seksjonen skal ta for seg begge prinsippene og hvordan de relaterer til funksjonell programmering.\\

Rekursjon er en teknikk som er tilgjengelig i så godt som alle moderne programmeringsspråk. Grunnen er at de fleste språk bruker en kall-stack for funksjonskall og at det i prinsipp ikke spiller noen rolle hvilken funksjon som blir kalt på. Dette gjør at det ikke er noe i veien for at en funksjon kaller på seg selv. På tross av den nesten universelle tilgjengeligheten blir teknikken ofte mye mer brukt i forbindelse med funksjonell programmering enn den gjør i imperativ. Årsakene til dette er flere men blant annet er rekursjon enste mulighet i enkelte språk for å gjenta kode på en organisert måte(som en form for løkker) i tillegg til at rekursjon er et uvurderlig verktøy i den funksjonelle verktøykassen når det kommer til å lage programmer med en funksjonell stil. Rekursjon og funksjonell programmering går på mange måter hånd i hånd.
\subsection*{Hvorfor rekursjon i funksjonell programmering?}
En måte å angripe problemet på er å heller spørre: Hvorfor ikke løkker i funksjonell programmering? Mange av grunnene til dette kommer fra løkkenes natur og virkemåte. En løkke består som regel av en kodeblokk og en betingelse som sjekkes for hver gang kodeblokken eventuelt blir gjentatt. For at løkken ikke skal kjøre ut i det uendelige er det gitt at uttrykket må endres. Eneste muligheten for dette er enten at uttrykket er et ikke-deterministisk funksjonskall (f.eks. en randomfunskjon), et uttrykk som avhenger av eksterne kilder, eller mer vanlig, at en eller flere variabler muteres inne i kodeblokken. De fleste språkene har også en løkkevariant der initialisering og mutering av teller/løkkevariabler og løkke-betingelsen er kombinert. Uansett varianten vil løkken i de fleste tilfeller være avhengig av mutering i en eller annen form. Løkkenes muterende natur innebærer at løkker strider mot grunnleggende prinsipper i funksjonell programmering omtalt i kapitlet "konstanter fremfor variabler". Alternativet blir derfor rekursjon. Det må også legges til at mange moderne språk tilbyr iterator-baserte løkker, f.eks. ved bruk av \textit{for(Type navn: liste) }i Java eller \textit{foreach(Type navn in liste}, som er mer funksjonelle i natur.
\subsection*{Fordeler og ulemper}
\subsubsection*{Lesbarhet og semantikk}
Denne seksjonen skal ta for seg en algoritme for å skrive ut en tekstlig representasjon av et binært tre i både funksjonell og iterativ stil, for deretter å sammenlikne semantikk og lesbarheten til kodesnuttene.

\begin{figure}[H]
\caption{Funksjon for å lage en tekstlig versjon av et tre (Standard ML)}
\label{fig:treeToStrSML}
\begin{minted}{sml}
 fun treeToStr(exprTree: ExprTree) = 
    case exprTree of
        Node(left,value,right) =>  
          Util.format("Tree( Val:$ L:$ R:$ )", 
            [getValue(value), exprTreeToStr(left),exprTreeToStr(right)])
       |EmptyNode => ""
       |treeLit(lit) => getValue(lit) 
   end 
\end{minted}
\end{figure}
\textit{Funksjonen bruker preorder-traverering til å rekursivt lage en tekstlig representasjon av et tre. Util.format er en funksjon for tekstformatering, på samme måte som System.out.printf i Java der dollartegnet er analogt til \%s. Denne funksjonen benyttes til feilsøking i databasen for å skrive ut uttrykks-trær. Eksempelvis vil uttrykket 1+2+3 få denne tekstlig reprsetntasjonen:Tree( Val:+ L:1.0 R:Tree( Val:+ L:2.0 R:3.0 ) ).
}

\begin{figure}
\caption{Funksjon for å lage en tekstlig versjon av et tre (Java)}
\begin{minted}{java}
   public static String treeToStr (Tree treeRoot){
        Stack<Tree> treeStack = new Stack<>();
        treeStack.add(treeRoot);

        String str = "";
        while (!treeStack.isEmpty()){
            Tree curr = treeStack.pop();
            if(curr != null){
                str += (String.format("%s (Val: %s ",curr.getType(), curr.value));

                treeStack.push(curr.right);
                treeStack.push(curr.left);
            }
            else{
                str += (")");
            }
        }
        return  str;
    }
\end{minted}
\end{figure}
\textit{Funksjonen bruker en stack for å lage en tekstlig versjon av treet. For hver node legges verdien til noden til i strengen og høyre og venstre tre legges til i stacken. Dette gjentas inntil stacken er tom, noe som indikerer at vi har nådd bunnen av treet. Funksjonen getType finner ut om noden er en rotnode,venstrenode eller høyrenode}

Hvis man studerer de to kodesnuttene kan man legge merke til at den funksjonelle er mer kompakt med tanke på antall linjer kode, men kanskje mer tydelig: Den angriper problemet på en grunnleggende annerledes måte enn den iterative varianten. I stedet for å eksplisitt definere de ulike stegene i algoritmen, benyttes en mer deklarativ stil. I deklarativ programmering kan utvikleren konsentrere seg om \textit{hva} som skal bli beregnet, uten nødvendigvis å måtte tenke på eller definere \textit{hvordan} dette skal gjøres\cite{declarative_programming}. Sagt på en annen måte- deklarativ programmering innebærer at utvikleren definerer logikken, men ikke programflyten. Dette medfører at elementer som if-setninger, løkker, og nøkkelord som \textit{continue} og \textit{break} ikke benyttes. Både funksjonell programmering og logisk programmering regnes for å tilhøre den deklarative stilen. SQL er kanskje det mest kjente  deklarative programmeringsspråket, selv om dette hverken er rent funksjonelt eller logisk. Regulæruttrykk, selv om det ikke er et programmeringsspråk men heller et domespesifikt språk, er også et kjent eksempel. I kodesnutten i figur \ref{fig:treeToStrSML} kan man se dette i praksis ved at algoritmen har minimalt med styring av kontrollflyt, men heller definerer "regler" for ulike scenarioer av input. Dessuten vil man enklere kunne få et inntrykk av hvordan den endelige strengen vil kunne se ut, kun ved å se på linjen for strengformateringen. Deklarativ programmering har som effekt at utvikleren opererer på et høyere nivå av abstraksjon. Dette er noe som kan bidra til kode som både er enklere å lese og forstå fordi tekniske implementerings-detaljer blir utelatt. Pattern-macthing er også en mekanisme som kan sies å tilhøre denne stilen, og man ser eksempel på denne mekanismen i den funksjonelle versjonen av tre-til-streng algoritmen. Pattern-matching vil bli diskutert i større detalj senere i rapporten. 

Knyttet opp mot rekursjon vil den deklarative stilen innebære at utvikleren ikke trenger å definere hvordan kodeblokkene blir gjentatt(gjennom løkker og logikken som styrer løkken) og at {\qq}kallstcken{\qq} som håndteres manuelt i den iterative varianten abstraheres bort. Traversering av rekursive datastrukturer som binær- og filtrær er problemer som egner seg godt for rekursjon. Det samme er tilfellet for divide-and-qonqeur algoritmer(slik som quicksort). Dette er fordi den rekursive løsningen vil abstrahere bort konseptet med en stack som utvikleren eksplisitt må håndtere og dermed også øke lesbarheten betraktelig. I andre tilfeller er muligens ikke fordelene like åpenbare.\\
\\
På den andre siden kan deklarativ programmering gi utvikleren et mer utydelig inntrykk av hva som faktisk foregår. Dette er fordi den faktiske logikken og programflyten blir gjemt bort under mange lag med abstraksjon. Mulighetene for optimalisering og spesialtilpassing blir også mindre av samme grunn. Et annet aspekt er at høytnivåkonseptene som følger med deklarativ programmering kan være utfordrende å forstå siden mange av begrepene er svært abstrakte og fordi det kan være vanskelig å finne en konkret parallell i den virkelige verden. For eksempel kan en løkke være enklere å forstå enn rekursjon og en iterativ variant som finner summen av elementene i en liste være mer intuitiv enn å bruke \textit{reduce/fold}.\\
\\
Den deklarative stilen i det første eksempelet gjør at funksjonen vil kunne enklere å lese i tillegg til å være enklere å skrive. Likevel krever den rekursive løsningen at utvikleren har kjennskap til og erfaring med rekursive algoritmer. Uten dette kan rekursive funksjoner være svært krevende å forstå, og ikke minst feilsøke, spesielt rekursjon som ikke er halerekursiv eller rekursjon som er av den multirekursive typen. En av grunnene til dette angår semantikken til koden og måten utvikleren kan få en forståelse for virkemåten til algoritmen. Ved en iterativ variant kan vedkommende gå gjennom algoritmen på en lineær måte og holde styr på tilstanden til programmet. Denne stilen vil for mange være mer naturlig og har også den fordelen at den vil kunne være enklere å feilsøke med en konvensjonell debugger. Den rekursive varianten er mer todimensjonal av natur ved at programflyten ikke bar går nedover, men også innover og oppover. Dette medfører at for å gå gjennom og få en forståelse for algoritmen må man danne seg en mental stack og bevege seg nedover og oppover kalltreet eller eventuelt skrible ned kallstacken på et papir. Det skal sies at dersom man har kjennskap til rekursjon, vil denne oppgaven bli enklere, men det vil fremdeles kreve en viss mental kapasitet når man skal lese og forstå mer komplekse rekursive algoritmer, spesielt når det ikke er deg selv som er forfatteren.\\


\begin{figure}[H]
\caption{Funksjon for å fjerne kommentarer fra kildekode(Standard ML)}
\label{fig:rmComments}
\begin{minted}{sml}
fun rmComments(lines: string list):string list =
  case lines of
    (x::xs) =>
    let
      val substr = strToSs(x)
      val (noComment, comment) = Substring.splitl (fn c => c <> #"#") substr
    in
      ssToStr(noComment) :: rmComments(xs)
    end
    |[] => []
\end{minted}
\end{figure}
\textit{Funksjonen fjerner alle karakterer fra og med \#-tegnet for hver streng i listen som sendes inn. splitl deler opp en streng ved hjelp av en predikatfunksjon som blir kjørt på hver enkelt karakter.  Delen uten kommentarer konkatineres med den rekursive løsningen til resten av lista.}
\label{fig:kalltreRmComments}
\begin{figure}[H]
Strengen som sendes inn: \\
\textit{from Person as P \#P er en alias \\
		filter department = "IT" \#Bare datafolkene \\
        output name,salary \#Grunnleggende info \\
        }
 \caption{Kalltre for funksjonen i figur \ref{fig:rmComments}}
\begin{minted}{sml}
"from Person as P" :: rmComments("filter department = IT #Bare datafolkene 
        			  output name,salary #Grunnleggende info")
	"filter department = IT" :: rmComments("output name,salary #Grunnleggende info")
    	"output name, salary"

\end{minted}
\end{figure}


\subsection*{Effektivitet}
Rekursjon blir i mange tilfeller foretrukket fremfor løkker i en rekke funksjonelle språk, mens teknikken ofte er reservert til spesielle tilfeller slik som traversering av trær for språk som er mer imperative. En viktig årsak til dette er måten de ulike kompilatorene og interpreterne implementerer rekursjonen, spesifikt om de tilbyr hale-rekursjon-optimalisering eller ikke.


For hvert funksjonskall, inklusive rekursive funksjonskall, opprettes en stackframe som lagres på kallstacken. Inne i hver stackframe lagres blant annet parameterverdier, lokale variabler(ikke i dette tilfellet) og posisjonen i koden det skal fortsettes fra etter at funksjonen har returnert. I figur \ref{fig:kalltreRmComments} kan man se at måten den rekursive funksjonen i figur \ref{fig:rmComments} kjører på medfører at tilstanden til funksjonen(i dette tilfellet strengen før ::) må lagres slik at denne strengen kan bli konkatinert på et senere tidspunkt når rekursjonen trekker seg oppover. I dette tilfellet vil man da få laget 3 stackframes før rekursjonen trekker seg opp igjen, noe som vil medføre ekstra  minnebruk og ekstra operasjoner med å legge til og fjerne frames fra kallstacken. Hale-kall optimalisering vil kunne eliminere de nevnte ulempene ved å transformere enkelte former for rekursjon til vanlig iterasjon av kompilatoren. Funksjonen for å fjerne kommentarer er et trivielt eksempel som ikke drar nevneverdig effekt av en slik optimalisering, men hvis rekursjonen hadde vært svært dyp, hadde man fått veldig mange stackframes, noe som potensielt kunne ha fylt opp kallstacken og i verste tilfelle medført en stack-owerflow exception, i tillegg til å gjort algoritmen mer ressurskrevende å kjøre. I seksjon \ref{sec:hastighetestester} demonstreres slik dyp rekursjon der en funksjon testes med 100 000 1 og 100 millioner rekursive funksjonskall, med og uten halekall-optimalisering. 
\\


For at en komplilator skal kunne utføre hale-kall-optimalisering må rekursjonen være implementert på en bestemt måte- det rekursive kallet må være det siste som utføres i funksjonen. Dette innebærer at den rekursive funksjonen kun har ett rekursivt kall, men også at det ikke akkumuleres verdier ved å kalle på rekursive funksjoner slik som \textit{ssToStr(noComment) :: rmComments(xs)} i figur \ref{fig:rmComments}.Poenget med at den rekursive delen er den siste medfører at algoritmer som naturlig implementeres med multi-rekursjon slik som traversering av trær, må bli skrevet om og få ganske annerledes logikk i forhold til løsningen med multi-rekursjon. For mer konvensjonell rekursjon er det ofte enklere å refaktorere koden til å være halerekursiv. \\

\begin{figure}[H]
\caption{Funksjon for å fjerne kommentarer fra kildekode, halerekursiv (Standard ML)}
\label{fig:rmCommentsTailrec}
\begin{minted}{sml}
 fun rmCommentsTailrec(inpLines: string list):string list =
   let fun rmTailRec(inpLines:string list, result:string list) = 
    case inpLines of
      (x::xs) =>
     let 
        val substr = Util.strToSs(x)
        val (noComment, comment) = Substring.splitl (fn c => c <> #"#") substr
      in  
        rmTailRec(xs, Util.ssToStr(noComment) :: result)
      end 
      |[] => rev(result)
    in
      rmTailRec(inpLines,[])
   end

\end{minted}
\end{figure}
Funksjonen i figur \ref{fig:rmComments} er transformert til å være halerekursiv. Den utfører samme oppgaven som i figur \ref{fig:rmComments}, men for at den skal oppfylle kravene for halerekursivitet er den blitt refaktorert til å benytte en indre funksjon og et akkumulator-parameter i stedet for å akkumulere rekursivt. Den nye implementeringen medførte også et par andre små endringer slik som reversering av listen når den retunreres, men totalt sett var endringen relativt triviell. At refaktoreringen var lite krevende er ikke alltid tilfellet. Eksempelvis benytter den halerekursive varianten av funksjonen for å beregne det n-te fibbonacci tallet en helt anderledes algoritme enn varianten med ordinær rekursjon.

Siden det rekursive kallet er det siste som blir utført i en halerekursiv funksjon, trenger ikke lokale variabler eller posisjon for returnering å bli lagret.  Fordi rekursjonen aldri kommer til å trekke seg opp igjen, men kun kalle seg selv med endrede parameterverdier vil det nemlig ikke være noen grunn for at rekursjonen skal måtte gå "tilbake". På grunnlag av dette kan kompilatoren optimalisere bak kulissene slik at nye stackframes ikke opprettes, men heller at én gjennbrukes. Rekursjonen blir  omgjort til normal iterasjon, med de hastighetsforbedringene dette medfører. Hvis man har en kompilator som genererer Assembly vil hale-rekursjonen kunne bli konvertert til en goto og mutering av registre, noe som vil gi svært god ytelse. Uoptimalisert rekursjon i Assembly innebærer at  stackframes må pushes og poppes i tillegg til at parameterne må kopieres(hvis man har pass-by-value slik som i Standard ML) for hvert enkelt funksjonskall. Flere operasjoner medfører mer jobb for CPU-en og dermed lavere ytelse. Flere stackframes medfører også større minnebruk. Standard ML er et språk der de mest populære kompilatorene har halekall-optimalisering, noe man vil kunne se tydelig utsalg for i hastighetstester.


\subsubsection{Hastighetstester}
\label{sec:hastighetestester}
For å teste forskjeller i effektivitet mellom ordinær rekursjon og halerekursjon benyttes en funksjon til å summere elementene i en liste.
\label{fig:sumSML}
\begin{figure}[H]
\caption{Sum av elementene i en liste (Standard ML)}
\begin{minted}{sml}
fun sum [] = 0
   |sum(x::xs) = x + sum(xs)
\end{minted}

\end{figure}
\textit{Funksjonen legger rekursivt sammen verdien til første element(x) pluss summen til resten av lista(xs). Dersom lista er tom er summen 0.}

\begin{figure}[H]
\caption{Sum av elementene i en liste, halerekursiv (Standard ML)}
\begin{minted}{sml}
fun sumTail(li) = 
let fun sumFrom([], summed) = summed
	   |sumFrom(x::xs, summed) = sumFrom(xs,summed + x)
in
	sumFrom(li, 0)
end
\end{minted}
\end{figure}
\textit{Funksjonen funger nesten som den med konvensjonell iterasjon, men benytter en indre funksjon og en akkumulator-variabel for summen}
\begin{figure}[H]
\caption{Oversikt over resultater ved kjøring av sum og sumTail}
\begin{center}
\begin{tabular}{|r | r| r| r|}
\hline
\rowcolor{lightGray} Funksjon & Vanlig & Hale-rekursjon & Forbedring \\
\hline
sum: 100 000 & 16.6 msek & 13.3 msek & 24.8\% \\
\hline
sum: 1 million & 30.3 msek & 21.6 msek & 40\% \\
\hline
sum: 100 millioner & 182 msek & 3336 msek & 1732\% \\
\hline 
\end{tabular}
\end{center}
\end{figure}
Vi ser av resultatene ovenfor at hale-rekursjon-optimalisering gir betydelige forbedringer med tanke på effektivitet, spesielt når problemstørrelsen øker.

\subsection*{Oppsummering}
I databasen blir rekursjon benyttet hyppig. Dette har flere effekter- blant annet kode som er mer konsis og kompakt og i mange tilfeller også som kan oppleves som mer lesbar. Det er forbundet en viss lærignskurve med den rekursive stilen, men etter å ha mestret teknikken føles rekursjon i mange tilfeller mer naturlig. Noen av årsaken til dette kan være at man får kode på et høyere nivå som også er mer deklarativ. Andre årsaker kan være at man deler opp problemet i stadig mindre biter og ender opp med å løse problemet når det er svært enkelt(typisk for algortimer slik som mergesort). Å dele opp et problem i mindre deler er en svært kjent taktikk i dagliglivet(tenk f.eks. matlaging) og dette kan være ett av elementene som gjør rekursjon intuitivt for visse problemer. Til slutt skal det også legges til at selv om rekursjon i mange tilfeller vil gi store fordeler, vil et problem alltid kunne løses iterativt ved å bruke mer imperative teknikker. Dette kan eksemplifiseres med at alle programmer skrevet i et funksjonelt programmeringsspråk til slutt vil ende opp som maskinkode kjørende på den grunnleggende imperative CPU-en. \\ \\

\section{Abstraksjon, organisering og gjenbruk av kode}
Når programstørrelsen øker og kompleksiteten til programmet vokser, blir det stadig viktigere å organisere koden på en hensiktsmessig måte. Det vil også være avgjørende å bruke hensiktigsmessige abstraksjoner for å lage kode som enkelt kan gjenbrukes og tilpasses nye krav. Objektorientert programmering innehar flere mekanismer for å oppnå nettopp dette og disse egenskapene kan muligens tillegges noe av grunnen til paradigmets store suksess. På tross av at funksjonell programmering er grunnleggende annerledes fra objektorientert, kan man likevel få mange av de samme gode egenskapene i dette paradigmet. Denne delen skal se på mekanismer og teknikker for å organisere kode og hvordan man kan få abstrakt og gjenbrukbar kode i det funksjonelle paradigmet og samtidig trekke parraleller til objektorientert programmering.

\subsection{Abstraksjon med first-class-functions}
\subsection{Organisering av kode med strukturer, signaturer og funktorer}
Standard ML inkluderer et sett med mekanikker for å organisere kode og skape abstraksjon. I SML kalles de \textit{structure}, \textit{signature} og \textit{functor}.


Strukturer går ut på å pakke ett sett med deklareringer sammen. Deklareringer kan være konstanter, funksjoner, datatyper, typealiaser, exceptions eller strukturer. Alene fungerer en struktur litt som et namespace ved at man må referere til en bestemt struktur når man vil benytte seg av et av elementene inne i strukturen. Dette sørger for at man unngår navnekolisjoner. Man kan også se likheter mellom klasser og strukturer, med den distinkte forskjellen at i den funksjonelle stilen skal man unngå mutering. Funksjonene i en struktur er heller ikke knyttet til noen bestemt instanse av data, og er avhengig av at dataen sendes inn for hvert funksjonskall. De nevnte egenskapene gjør at en struktur likner mer på en klasse med bare konstant-felter og der alle metoder er \textit{static}. At man unngår mutering i en struktur har den effekten at den i større grad blir en statisk, isolert og flyttbar enhet. Man trenger ikke å tenke på at strukturen kan endres fra utsiden eller at den er avhengig av endringer på utsiden for å fungere, siden strukturen aldri vil kunne endres. Feilsøking og forståelse av kildekoden vil derfor kunne bli enklere. De nevnte egenskapene vil i tillegg gjøre testing(spesielt unit-testing) enklere siden en struktur kan testes isolert.

En signatur fungerer som en kontrakt og beskriver typene til deklareringene en struktur må ha, men ikke selve impelementeringen. At implementeringen ikke er med gjør signaturen abstrakt. Signaturer kan derfor sammenliknes med grensesnitt i f.eks. Java, men har et noe annerledes bruksområde. En annen måte å se en signatur på er at en signatur representerer typen til strukturen. En struktur kan implementere en signatur og må i det tilfellet følge kontrakten definert i signaturen. I SML finnes det to måter en signatur kan implementeres på. Hvis signaturen implementeres på en gjennomsiktig måte vil signaturen utelukkende fungere som en kontrakt og alle typer og funksjoner definert utenom kontrakten vil være synlige. Dette vil være et brudd mot abstraksjonen og kanskje også åpne opp for integritetsødeleggende operasjoner. Eksempelvis vil en struktur og en signatur for en kø, implementert gjennomsiktig kunne gjøre det tydelig hvilken datastruktur køen er implementert med og siden man har tilgang til denne underliggende strukturen, vil man også kunne ødelegge integriteten, f.eks. ved å hente ut et element fra slutten av køen. En annen ulempe er at siden man har tilgang til den underliggende datastrukturen, vil man også kunne utføre likhetstester. Denne likhetstesten vil fungere på normal måte, noe som i noen tilfeller ikke er intensjonen med strukturen. En struktur for en uordnet liste vil feks ikke at [1,2] og [2,1] skal bli sett på som to ulike strukturer. Den ugjennomsiktige måten å impelemntere en signatur på vil gjøre den underliggende datatypen abstrakt slik at den ikke kan benyttes utenfor strukturen og dermed heller ikke i likhetstester. Den andre effekten man oppnår er at deklarasjoner som ikke er deinfert i signaturen vil bli skjult fra utsiden, noe som vil gi effekter tilsvarende innkapsulering ved bruk av f.eks. \textit{private} i Java. Strukturer og signaturer kan lages fullstendig uten mutering og er derfor funksjonelle i natur. I SML er signaturer kanskje mest nyttige når de blir brukt i forbindelse med funktorer.

Databasen bruker en funksjonell map basert på et binærtre, også kjent som en assosiativ liste, for å lagre informasjon om de ulike kolonnene med data som leses inn når en spørring utføres. Det brukes en map til å holde på meta-informasjon slik som kolonnenavn, type og standardverdi definert i metadatafilen og en annen til å holde på selve dataen definert i datafilen. Det er ønskelig at mapen har funksjoner for å sette inn og for å hente ut en verdi assosiert med en bestemt nøkkel. Dette er operasjoner som er ønskelig at alle maper skal ha, og funksjons-signaturene er defor definert i signaturen i figur \ref{fig:sigMap}.

Mapen skal kunne bruke nøkler av ulik type data, også de typene som er av mer kompleks form. Med strukturer og signaturer ville løsningen blitt å en inplementering for hver av typene man ønsker å ha som nøkkel. Selv om strukturer og signaturer tilbyr innkapsulering og abstraksjon, bidrar de lite til å lage  kode som er gjenbrukbar. Hvis du har en map-inplementering som skal kunne håndtere 4 typer nøkler(av en kompleks type) må man lage 4 strukturer. Enda værre er det hvis du er i det tilfellet at du også har flere ulike map-inpleneteringer som alle bruker rekkefølgen til elementene for å skape en organisering. Eksempelvis kan man ha en liste som bruker binærsøk i tillegg. I dette tilfellet hadde antall inplementeringer blitt 8 stk. Denne løsningen skaper store mengder duplisert kode og vil være krevende å vedlikeholde. Funktoren i SML lar deg unngå de nevnte problemene. Den fungerer som en slags funksjon som tar imot en eller flere strukturer av en bestemt type(som inplementerer en bestemt signatur) som argument og som produserer en struktur som resultat. For liste-inplementeringen vil man kunne ønske å lage en funktor for hver enkelt listetype, som tar imot en struktur for selve datatypen. Strukturen som blir tatt imot kan da være av type ORDERED\_TYPE. Den kan inneholde en funksjon for å bestemme rekkefølgen til to elementer av den aktuelle typen i tillegg til å inneholde selve data-typen. Funktoren vil da kunne gjenbrukes på mange ulike datatyper og de ulike datatypene vil kunne bli delt på tvers av de ulike funktorene dersom alle tar imot en struktur av samme type. Når man kaller på funktoren vil en ny struktur tilpasset en bestemt type opprettes.

\begin{figure}
\caption{Signatur for en map (Standard ML)}
\label{fig:sigMap}
\begin{minted}{sml}
signature MAP = 
sig
  type 'a MapTree
  type keyType
  val insert: ('a MapTree*keyType*'a)-> 'a MapTree
  val get: ('a MapTree*keyType) -> 'a option
  val empty:(unit) -> 'a MapTree
end;

\end{minted}
\end{figure}
\subsubsection*{Eksempel med map}
 En signatur (figure) bestemmer operasjonene en map må tilby, slik som funksjoner for å sette inn og for å hente ut en verdi assosiert med en bestemt nøkkel. Den krever også at en struktur som implementerer denne signaturen skal definere en datatype for selve mapen. Hvordan dette gjøres er opp til strukturen. 

Siden mapen er i den funksjonelle stilen vil den ikke kunne muteres. Dermed vil man ikke kunne ta i mot en map, endre den og deretter returnere den slik tilfellet ofte er i imperativ programmering. I stedet vil man ta imot en map, og opprette en ny basert på den som ble sendt inn. Det er da den nye mapen som blir returnert. Dette vil ha den positive effekten at man ikke trenger å bekymre seg for om data sendt inn til en funksjon kommer til å bli endret av funksjonen.

\begin{figure}
\caption{Signatur for}
\end{figure}

\subsection{Operasjoner på lagret data ved hjelp av closures}
hvordan strukturer, signaturer og functors relaterer til oop
Ekseplifisere med impelementasjonen av map
 gjenbruk og abstraksjon, utvidbarhet og organisering av koden
Fist-class-functions og hvordan de kan bidra til abstraksjon og gjennbruk

4 prinsipper i oop:
arv
enkapsulering
abstraksjon
polymorfisme


\printbibliography
\end{document}
