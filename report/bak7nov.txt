\documentclass{report}
\input{sml.tex}
\title{Funksjonell programmering gjennom utvikling av et spørrespråk}
\author{Erlend \O
stlie}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{changepage}

\usepackage[backend=biber]{biblatex}
\addbibresource{refs.bib}

\usepackage{url}
\definecolor{lightGray}{rgb}{0.90, 0.90, 0.90}

\usepackage[a4paper, total={6in, 8in}]{geometry}
\usepackage{graphicx}
\usepackage{minitoc}
\usepackage{minted}
\usepackage{geometry}
\usepackage{float}
\usepackage{color, colortbl}
\usepackage{parskip}
\usepackage[norsk]{babel}
\usepackage[font=small,skip=5pt]{caption}
\newcommand*{\escape}[1]{\texttt{\textbackslash#1}}
\usepackage[format=plain,
            labelfont={it},
            textfont=it]{caption}
\captionsetup{justification=raggedright,singlelinecheck=false}
\date{\today}
\newcommand{\qq}{\symbol{34}}
\def \tabX {20pt}
\def \tabY {0pt}
\newcommand{\tab}[1]{
	\begin{adjustwidth}{\tabX}{\tabY}
	#1
	\end{adjustwidth}
}
\newcommand{\keyword}[1]{\colorbox{lightGray}{#1}}

\begin{document}

\maketitle
\dominitoc
\tableofcontents 

\chapter*{Introduksjon}
\addcontentsline{toc}{chapter}{\protect\numberline{}Introduksjon}%
\chapter{Databasen}
\section{Syntaks}
For å beskrive databasens syntaks har jeg valgt å bruke kontekstfri grammatikk og Backus-Naur Form, heretter BNF, som notasjon.
\subsection*{Beskrivelse av notasjonen}
Tekst mellom vinkelparenteser (< og >) betegner navnet på en grammatikkregel hvis de står på venstre side av {\qq}::={\qq}, og henviser til en eksisterende grammatikkregel dersom den står på høyre side. Tekst inne i fnutter({\qq} og {\qq}), er rene tekststrenger som skal skrives rett ut. Merk at tekststrengene vil bli skrevet med små bokstaver i syntaksoversikten, men at alle bokstaver endres til lower-case når spørringen leses inn, slik at hvorvidt bokstavene er store eller små ikke vil ha betydning. Pipe-symbolet(|) betyr at det finnes flere muligheter for å oppfylle regelen. Store bokstaver indikerer at selve verdien angis av brukeren selv.
Elementer omgitt av firkantparanteser ([ og ] betyr at elementet er frivillig.
\subsection{Query}
\label{sec:query}
Lar brukeren hente ut data fra en eller flere tabeller og eventuelt behandle dataene. \\

<query> ::= <from> [ <merge> ] [ <filter> ] <output> | \\

\subsubsection*{From}
<from> ::= {\qq}from{\qq} <tableList> \\
<tableList> :: =<table> | <table> {\qq},{\qq} <tableList> \\
<table> ::= TABLENAME | TABLENAME {\qq}as{\qq} ALIAS
\subsubsection*{Merge}
<merge> ::= {\qq}merge{\qq} <mergeTableList> {\qq}using{\qq} COLUMNNAME \\
<mergeTableList> ::= 
\tab{
<tablename> {\qq}and{\qq} <tablename> |  \\
<tablename> {\qq}and{\qq} <mergeTableList>
}
<tablename> ::= NAME | ALIAS
\subsubsection*{Filter}
<filter> ::= {\qq}filter{\qq} <predicateList> \\
<predicateList> ::= <predicate> | <predicate> <logicOperator> <predicateList> \\
<logicOperator> ::= {\qq}and{\qq} | {\qq}or{\qq} \\
<predicate> ::= 
\tab {
<expression> <predicateOperator> <expression> | \\
<columnName> <predicateFunction>
}
<expression> ::= [{\qq}({\qq}]<expression> <operator> <expression> [{\qq}){\qq}] | <value> \\
<operator> ::= {\qq}+{\qq} | {\qq}-{\qq} | {\qq}*{\qq} | {\qq}/{\qq} \\
<predicateOperator> ::= {\qq}>{\qq} | {\qq}<{\qq} | {\qq}>={\qq} | {\qq}<={\qq} | {\qq}={\qq} | {\qq}!={\qq} \\
<value> ::= <columnName> | LITTERAL \\
<predicateFunction> ::= <predicateFunctionName> {\qq}({\qq}<valueList>{\qq}){\qq} \\
<valueList> ::= <value> | <value> {\qq},{\qq} <valueList> \\
<predicateFunctionName> ::= {\qq}oneof{\qq} | {\qq}noneof{\qq} \\
<columnName> ::= 
\tab {
COLUMNNAME | \\
TABLENAME {\qq}.{\qq} COLNAME | \\
TABLENAME {\qq}.{\qq} COLNAME {\qq}.{\qq} SUBCOLNAME \\
}

\subsection{Output}
Lar brukeren velge hvilke kolonner/uttrykk som skal skrives ut og eventuelle operasjoner som skal gjøres i hvert tilfelle. Hvilket kolonnenavn som blir gitt ved utskrift kan endres ved å benytte en alias(nøkkelordet named). En alias kan være spesielt aktuelt ved transformasjon på en kolonne eller ved utskrift av et uttrykk. Output støtter også pipelining av transformasjoner på dataen som skal skrives ut, men bare på en kolonne/uttrykk om gangen. Det er mulig å skrive ut flere kolonner i en enkelt operasjon, men da støttes ikke pipelining av dataene. Pipelining med flere kolonner ville både ha vært utfordrende å løse teknisk i tillegg til at oppførselen ville kunne ha forvirret brukeren. \\
\\
<output> ::= {\qq}output{\qq} <outputList> \\
<outputList> ::= <outputColumn> | <outputColumn> {\qq},{\qq} <outputList> \\
<outputColumn> ::= <expression> [<functionPipeline>] [<alias>] | <multiColumn> [<alias>] \\
<expression> ::= \textit{Se seksjon\ref{sec:query}: Filter \\}
<functionPipeline> ::= <function> | <function> {\qq}->{\qq} <functionPipeline> \\
<function> ::= {\qq}upper{\qq} | {\qq}lower{\qq} | {\qq}trimWhitespace{\qq} | {\qq}rmChar{\qq} \\
<alias> ::= {\qq}named{\qq} COLNAME \\
<multicolumn> ::= [TABLENAME{\qq}.{\qq}]COLNAME{\qq}.*{\qq} | [TABLENAME{\qq}.{\qq}]COLNAME{\qq}.{{\qq}<subcolList>}{\qq} \\
<subcolList> ::= SUBCOLNAME | SUBCOLNAME {\qq},{\qq} <subcolList> \\
\subsubsection*{Eksempel}
\textit{from Person as P, PersonWork as PW \\
		merge P and PW using personID \\
        filter department oneof({\qq}computers{\qq}, {\qq}phones{\qq}, {\qq}support{\qq}) and \\
        salary > 100000 \\
        output name -> trimWhitespace -> capitalized,\\
        adress.\{streetName, streetNo\}
        }
\subsection{Insert}
\label{sec:insert}
Lar brukeren sette inn data i form av en eller flere rader i en tabell. Tabellen må være oprettet på forhånd. Dersom en eller flere kolonner ikke spesifiseres vil databasen enten sette kolonneverdien til standardverdien, hvis den ble spesifisert ved opprettelse av tabellen, eller gi en feilmelding dersom kolonnen ikke har noen standardverdi. For spesifisering av kolonner benyttes utelukkende navnet på kolonnen/subkolonnen.\\

<insert> ::= {\qq}insert rows into{\qq} TABLE <rowlist> \\
<rowlist> ::= <row> | row {\qq},{\qq} <rowlist> \\
<row> ::= {\qq}({\qq} <columnValueList> {\qq}){\qq} \\
<columnValueList> ::= 
\tab{
<columnValue> | \\
<columnValue> {\qq},{\qq} <columnValueList>
}
<columnValue> ::= <keyValue> | <subkeyValues> \\
<keyValue> ::= COLNAME {\qq}:{\qq} <expression> \\
<subkeyValues> ::= COLNAME {\qq}:\{{\qq}<keyValueList>{\qq}\}{\qq} \\
<keyValueList> ::= <keyValue> | <keyValue> {\qq},{\qq} <keyValueList> \\


\subsection{Remove}
Lar brukeren slette rader fra en tabell som stemmer med en eller flere predikater.
<remove> ::= {\qq}remove rows from{\qq} TABLENAME {\qq}WHERE{\qq} <predicateList>
<predicateList> ::= \textit{Se seksjon \ref{sec:query}: Filter}


\subsection{Update}
Lar brukeren endre verdi på eksisterende celler. Ved endring settes de kolonner som ønskes å endres på samme måte som nevnt i seksjon \ref{sec:insert} men i tilegg kan den reserverte variabelen OLD benyttes i uttrykkene å henvise til den gjeldende verdien. \\
<update> ::= {\qq}update{\qq} TABLENAME {\qq}where{\qq} <predicateList> {\qq}set{\qq} <columnValueList> \\
<predicateList> ::= \textit{Se seksjon \ref{sec:query}: Filter} \\
<columnValueList> ::= \textit{Se seksjon \ref{sec:insert}}



\subsection{Create}
\label{sec:create}
Lar brukeren opprette en ny tabell. Alle kolonene må ha datatyper spesifisert og det er mulig å la kolonnene ha en standardverdi.
\subsubsection*{Datatyper}
Databasen har tre datatyper:
\begin{itemize}
\item boolean: enten true eller false
\item number: et flyttall-nummer, men kan spesifiseres uten desimaler
\item string: en vilkårlig tekststreng
\end{itemize}
<create> ::= {\qq}create table{\qq}  TABLENAME {\qq}with columns{\qq} <columnList>\\
<columnList> ::= <column> | <column> {\qq},{\qq} <columnList>\\
<column> ::= <nameDatatype> | COLNAME {\qq}:\{{\qq}<nameDatatypeList>{\qq}\}{\qq}\\
<nameDatatype> ::= COLNAME {\qq}of{\qq} <datatype> [{\qq}default{\qq} LITTERAL] \\
<nameDatatypeList> ::= <nameDatatype> | <nameDatatype> {\qq},{\qq} \\
<datatype> ::= {\qq}string{\qq} | {\qq}boolean{\qq} | {\qq}number{\qq}\\

Eksampler på oppbrytning av de ulike delene.


\section{Lagring}
\subsection{Metadata}
Informasjon om hver enkelt tabell ligger lagret i en separat fil. Årsaken til at dataen og metadataen ikke ligger i samme fil er at det blir enklere å kun lese inn den informasjonen som er nødvendig. Eksempelvis vil det kun være nødvendig å lese inn metadataen for å sette inn ny data. Metadatafilen inneholder navn på de ulike feltene i tillegg til typen for feltet og eventuelt en standardverdi. Filen har slik syntax:

<entryList> ::= <entry> | <entry>{\qq};{\qq}<entryList> \\
<entry> ::=  <singleEntry> | <nestedEntry> \\
<singleEntry> ::= COLNAME{\qq}\{<datatype>[,<defaultValue>]\}{\qq}  \\
<nestedEntry> ::= COLNAME{\qq}(<singleEntryList>){\qq} \\
<singleEntryList> ::= 
\tab{
<singleEntry> | \\
<singleEntry><singleEntryList> 
}
<datatype> ::= s | i | b
<defaultValue> ::= LITTERAL \\

\subsubsection*{Eksempel}
\textit{Name\{s,{\qq}John Doe{\qq}\};Phone\{i\};Adress(StreetName\{s\}StreetNo\{i\})}

\subsection{Data}
Selve dataen lagres på et enkelt, CSV-linkende format. Formatet er valgt for å være enkelt å lese for både mennesker og maskiner i tillegg til å ta lite plass og være flyttbart. Siden lagringen benytter plassering for å bestemme de ulike feltene, er programmet avhengig av metadatafilen for å kunne skille mellom de ulike feltene. Et felt kan være tomt. Hvis en standardverdi er satt benyttes denne. Hvis ikke vil programmet avslutte med en feilmelding. Filen har slik syntax:\\
<rowList> ::= <row> | <row>{\qq}\escape{n}{\qq}<rowList> \\
<row> ::= <columnList> \\
<columnList> ::= <column> | <column>{\qq};{\qq}<columnList>\\
<column> ::= <flat> | <nested>\\
<flat> ::= LITTERAL\\
<nested> ::= {\qq}(<flatList>){\qq}\\
<flatList> ::= <flat> | <flat>{\qq};{\qq}<flatList>\\

\subsubsection*{Eksempel}
\textit{{\qq}Per Olsen{\qq};67284771;({\qq}Einerveien{\qq};18)\\
        ;88341821;({\qq}Lierveien{\qq};2)}
\chapter{Funskjonell Progammering}
\section{Hva er funksjonell programmering?}
Funksjonell programmering er et programmeringsparadigme. Et programmeringsparadigme kan defineres på ulike måter, men én definisjon er at det er stil eller måte koden blir skrevet på og organisert på. Det er viktig å legge vekt på at funksjonell programmering kun er en stil, og at denne stilen ikke er begrenset til en bestemt gruppe med språk. Likevel snakker man gjerne om funksjonelle språk, og da vil dette være språk som er designet for å programmere i den funksjonelle stilen. Likevel er det fullt mulig å bedrive funksjonell programmering i språk ikke regnes som funksjonelle, slik som C, men opplevelsen vil ofte bli bedre dersom man benytter språk spesielt laget for funksjonell programmering. Eksempler på slike språk er Standard ML, Haskell og Scala. 

Imperativ programmering og paradigmets populære underkategorier objektorientert og prosedyrisk programmering er de dominerende paradigmene i dag. En abstrakt definisjon på forskjellen mellom det imperative og det funksjonelle paradigmet kan være at det imperative er basert på turingmaskinen, mens det funksjonelle er basert på lambda-kalkylen. Denne forskjellen gjør funksjonell programmering til et på mange måter grunnleggende annerledes paradigme - i det funksjonelle paradigmet skapes resultatene ved å la dataen flyte og transformeres gjennom funksjoner(funksjoner i matematisk forstand), fremfor at  tilstanden til programmet stegvis blir mutert inntil resultatet er skapt. At man unngår å endre tilstanden til programmet er en essensiell og karakteristisk egenskap ved funksjonell programmering, og rapporten vil komme tilbake til hvilke implikasjoner dette vil ha på koden og på utviklingsprosessen. Funksjonell programmering regnes i tillegg som en underkategori av deklarativ programmering, noe rapporten også vil nevne. Paradigmet sin deklarative natur og det faktum at man unngår mutering, baner i tillegg vei for rekursjon, som også vil bli drøftet. Sist vil rapporten se på hvordan funksjonell programmering fungerer i større skala, med tanke på gjenbruk og abstraksjon, utvidbarhet og organisering av koden. Hensikten med rapporten er å se hvordan de ulike aspektene til funksjonell programmering kommer til uttrykk i praktisk programvareutvikling, og i dette tilfellet, utvikling av et spørrespråk for en database.\\

\section{Konstanter fremfor variabler}
\textit{NB! avsnitt ikke ferdig}
Fordel: enklere å se om verdien/objektet man får fra en funksjon er den samme som det sendt inn. I imperativ må man lagre en kopi og deretter sjekke alle feltene, i funksjonell kan man sjekke id-en/minneadressen til objektet. Har objektene samme minneadresse er det ingen mulighet for at det kan ha blitt endret siden et objekt ikke kan bli endret i den funksjonelle stilen.

\section{Rekursive funksjoner og deklarativ programmering}
\subsection*{Hva er rekursjon?}
På et abstrakt nivå er noe rekursivt dersom navnet til det som blir definert er en del av selve definisjonen \cite{elements_of_func}. Av dette kan man tyde at rekursjon ikke nødvendigvis er koplet opp mot funksjoner, men denne rapporten vil konsentrere seg om rekursive funksjonsdefinisjoner. Rekursive funksjoner går ut på at en funksjon kaller seg selv, noe som innebærer at funksjonen bruker seg selv som et steg på veien til løsningen av et problem. I noen tilfeller vil rekursjonen ha semantikk og oppførsel med likhetstrekk til konvensjonelle løkker, men i andre tilfeller vil rekursjonens virkemåte være grunnleggende annerledes. Spesielt i det siste tilfellet kan man argumentere for at rekursjon lar deg løse problemer på en mye mer elegant måte enn tilfellet hadde vært uten rekursjon. Rapporten kommer tilbake til dette senere. Deklarativ programmering er et annet tema som er tett knyttet opp mot funksjonell programmering og også på noen måter, rekursjon. Denne seksjonen skal ta for seg begge prinsippene og hvordan de relaterer til funksjonell programmering.\\

Rekursjon er en teknikk som er tilgjengelig i så godt som alle moderne programmeringsspråk. Grunnen er at de fleste språk bruker en kall-stack for funksjonskall og at det i prinsipp ikke spiller noen rolle hvilken funksjon som blir kalt på. En funksjon som kaller seg vil det derfor bli behandlet som et hvilket som helst funksjonskall. På tross av den nesten universelle tilgjengeligheten blir teknikken ofte mye mer brukt i forbindelse med funksjonell programmering enn det den gjør i imperativ. Årsakene til dette er flere men blant annet er rekursjon enste mulighet i enkelte språk til å gjenta kode på en organisert måte(som en form for løkke) i tillegg til at rekursjon er et uvurderlig verktøy i den funksjonelle verktøykassen når det kommer til å skrive programmer i funksjonell stil. Rekursjon og funksjonell programmering går på mange måter hånd i hånd.
\subsection*{Hvorfor rekursjon i funksjonell programmering?}
En måte å angripe problemet på er å heller spørre: Hvorfor ikke løkker i funksjonell programmering? Mange av grunnene til dette kommer fra løkkenes natur og virkemåte. En løkke består som regel av en kodeblokk og en betingelse som sjekkes for hver gang kodeblokken eventuelt blir gjentatt. For at løkken ikke skal bli gjentatt ut i det uendelige er det gitt at uttrykket i betingelsen må endres. Eneste muligheten for dette er enten at uttrykket aldri er sant, at det er et ikke-deterministisk funksjonskall (f.eks. en randomfunskjon), et uttrykk som avhenger av eksterne kilder, eller mer vanlig, at en eller flere variabler muteres inne i kodeblokken. De fleste språkene har også en løkkevariant der initialisering og mutering av teller/løkkevariabler og løkke-betingelsen er kombinert. Uansett varianten vil løkken i de fleste tilfeller være avhengig av mutering i en eller annen form for å ta slutt, men også for å få gjort nyttig arbeid inne i selve løkkekroppen. Løkkenes muterende natur medfører at løkker strider mot grunnleggende prinsipper i funksjonell programmering omtalt i kapitlet {\qq}Konstanter fremfor variabler{\qq}. Alternativet til løkker i funksjonelle språk er ofte funksjoner av høyere orden eller rekursjon. Det må også legges til at mange moderne språk tilbyr iterator-baserte løkker, f.eks. ved bruk av \textit{for(Type navn: liste) }i Java, som er mer funksjonelle i natur.
\subsection*{Fordeler og ulemper}
\subsubsection*{Lesbarhet og semantikk}
Denne seksjonen skal ta for seg en algoritme for å skrive ut en tekstlig representasjon av et binært tre i både funksjonell og imperativ stil, for deretter å sammenlikne semantikk og lesbarhet til kodesnuttene.

\begin{figure}[H]
\caption{Funksjon for å lage en tekstlig versjon av et tre (Standard ML)}
\label{fig:treeToStrSML}
\begin{minted}{sml}
 fun treeToStr(exprTree: ExprTree) = 
     case exprTree of
         Node(left,value,right) =>  
           Util.format("Tree( Val:$ L:$ R:$ )", 
             [getValue(value), exprTreeToStr(left),exprTreeToStr(right)])
        |EmptyNode => ""
        |treeLit(lit) => getValue(lit) 
\end{minted}
\end{figure}
\textit{Funksjonen bruker preorder-traverering til å rekursivt lage en tekstlig representasjon av et tre. Util.format er en funksjon for tekstformatering, på samme måte som System.out.printf i Java der dollartegnet i Util.format er analogt til \%s i Java-varianten. Denne funksjonen benyttes til feilsøking i databasen for å skrive ut uttrykks-trær. Eksempelvis vil uttrykket 1+2+3 få denne tekstlig reprsetntasjonen:Tree( Val:+ L:1.0 R:Tree( Val:+ L:2.0 R:3.0 ) ).
}

\begin{figure}[H]
\caption{Funksjon for å lage en tekstlig versjon av et tre (Java)}
\begin{minted}{java}
   public static String treeToStr (Tree treeRoot){
        Stack<Tree> treeStack = new Stack<>();
        treeStack.add(treeRoot);

        String str = "";
        while (!treeStack.isEmpty()){
            Tree curr = treeStack.pop();
            if(curr != null){
                str += (String.format("%s (Val: %s ",curr.getType(), curr.value));

                treeStack.push(curr.right);
                treeStack.push(curr.left);
            }
            else{
                str += (")");
            }
        }
        return  str;
    }
\end{minted}
\end{figure}
\textit{Funksjonen bruker en stack for å lage en tekstlig versjon av treet. For hver node legges verdien til noden til i strengen og høyre og venstre tre legges til i stacken. Dette gjentas inntil stacken er tom, noe som indikerer at vi har nådd bunnen av treet. Funksjonen getType henter typen til noden (om noden er en rotnode, venstre- eller høyrenode)}

Hvis man studerer de to kodesnuttene kan man legge merke til at den funksjonelle er mer kompakt med tanke på antall linjer kode, men kanskje mer tydelig: Den angriper problemet på en grunnleggende annerledes måte enn den imperative varianten. I stedet for å eksplisitt definere de ulike stegene i algoritmen, benyttes en mer deklarativ stil. I deklarativ programmering kan utvikleren konsentrere seg om \textit{hva} som skal bli beregnet, uten nødvendigvis å måtte tenke på eller definere \textit{hvordan} dette skal gjøres \cite{declarative_programming}. Sagt på en annen måte- deklarativ programmering innebærer at utvikleren definerer logikken, men ikke programflyten. Dette medfører at elementer som if-setninger, løkker, og nøkkelord som \textit{continue} og \textit{break} ikke benyttes. Både funksjonell programmering og logisk programmering regnes for å tilhøre den deklarative stilen. SQL er kanskje det mest kjente  deklarative programmeringsspråket, selv om dette hverken er funksjonelt eller logisk. Regulæruttrykk, selv om det ikke er et programmeringsspråk men heller et domespesifikt språk, er også et kjent eksempel. I kodesnutten i figur \ref{fig:treeToStrSML} kan man se dette i praksis ved at algoritmen har minimalt med styring av kontrollflyt, men heller definerer {\qq}regler{\qq}  for ulike scenarioer av input. Dessuten vil man enklere kunne få et inntrykk av hvordan den endelige strengen vil kunne se ut, kun ved å se på linjen for strengformateringen. Deklarativ programmering har som effekt at utvikleren opererer på et høyere nivå av abstraksjon. Dette er noe som kan bidra til kode som både er enklere å lese og forstå fordi tekniske implementerings-detaljer blir utelatt. Pattern-macthing er også en mekanisme som kan sies å tilhøre denne stilen, og blir brukt i den funksjonelle versjonen av tre-til-streng algoritmen. Pattern-matching vil bli diskutert i større detalj senere i rapporten. 

Knyttet opp mot rekursjon vil den deklarative stilen innebære at utvikleren ikke trenger å definere hvordan kodeblokkene blir gjentatt(gjennom løkker og logikken som styrer løkken) og at {\qq}stacken{\qq} som håndteres manuelt i den imperative varianten abstraheres bort. Dette vil kunne påvirke lesbarheten betraktelig. Traversering av rekursive datastrukturer som binær- og filtrær er derfor problemer som egner seg godt for rekursjon. Det samme er tilfellet for splitt-og-hersk algoritmer(slik som quicksort). I andre tilfeller er muligens ikke fordelene like åpenbare.\\
\\
På den andre siden kan deklarativ programmering gi utvikleren et mer utydelig inntrykk av hva som faktisk foregår. Dette er fordi den faktiske logikken og programflyten blir gjemt bort under flere lag med abstraksjon. Mulighetene for optimalisering og spesialtilpassing blir også mindre av samme grunn. Et annet aspekt er at høytnivåkonseptene som følger med deklarativ programmering kan være utfordrende å forstå siden mange av begrepene er svært abstrakte og fordi det kan være vanskelig å finne en konkret parallell i den virkelige verden. For eksempel kan en løkke være enklere å forstå enn rekursjon og en imperativ variant som finner summen av elementene i en liste være mer intuitiv enn å bruke \textit{reduce/fold}.\\
\\
Den deklarative stilen i det første eksempelet vil kunne gjøre funksjonen enklere å lese og skrive. Likevel krever den rekursive løsningen at utvikleren har kjennskap til og erfaring med rekursive algoritmer. Uten dette kan rekursive funksjoner være svært krevende å forstå, og ikke minst feilsøke, spesielt rekursjon som ikke er halerekursiv eller rekursjon som er av den multirekursive typen. En av grunnene til dette angår semantikken til koden og måten utvikleren kan få en forståelse for virkemåten til algoritmen. Ved en imperativ variant kan vedkommende gå gjennom algoritmen på en lineær måte og holde styr på tilstanden til programmet. Denne stilen vil for mange være mer naturlig og har også den fordelen at den vil kunne være enklere å feilsøke med en konvensjonell debugger. Den rekursive varianten er mer todimensjonal av natur ved at programflyten ikke bare går nedover, men også innover og oppover. Dette medfører at for å gå gjennom og få en forståelse for algoritmen må man danne seg en mental stack og bevege seg nedover og oppover kalltreet eller eventuelt skrible ned kallstacken på et papir. Det skal sies at dersom man har kjennskap til rekursjon, vil denne oppgaven bli enklere, men det vil fremdeles kreve en viss mental kapasitet når man skal lese og forstå mer komplekse rekursive algoritmer, spesielt når det ikke er deg selv som er forfatteren.\\


\begin{figure}[H]
\caption{Funksjon for å fjerne kommentarer fra kildekode(Standard ML)}
\label{fig:rmComments}
\begin{minted}{sml}
fun rmComments(lines: string list):string list =
  case lines of
      (x::xs) =>
          let
             val substr = strToSs(x)
             val (noComment, comment) = Substring.splitl (fn c => c <> #"#") substr
       in
           ssToStr(noComment) :: rmComments(xs)
       end
    |[] => []
\end{minted}
\end{figure}
\textit{Funksjonen fjerner alle tegn fra og med \#-tegnet for hver streng i listen blir sendt inn. splitl deler opp en streng ved hjelp av en predikatfunksjon som blir kjørt på hvert enkelt tegn. Delen uten kommentarer konkatineres med den rekursive løsningen til resten av lista.}
\label{fig:kalltreRmComments}
\begin{figure}[H]
Strengen som sendes inn: \\
\textit{from Person as P \#P er en alias \\
		filter department = {\qq}IT{\qq} \#Bare datafolkene \\
        output name,salary \#Grunnleggende info \\
        }
 \caption{Kalltre for funksjonen i figur \ref{fig:rmComments}}
\begin{minted}{text}
"from Person as P" :: rmComments("filter department = IT #Bare datafolkene 
        			  output name,salary #Grunnleggende info")
	"filter department = IT" :: rmComments("output name,salary #Grunnleggende info")
    	"output name, salary"

\end{minted}
\end{figure}


\subsection*{Effektivitet}
Rekursive funksjoner blir i mange tilfeller foretrukket fremfor løkker i en rekke funksjonelle språk, mens teknikken ofte er reservert til spesielle tilfeller slik som traversering av trær i språk som er mer imperative. En viktig årsak til dette er måten de ulike kompilatorene og interpreterne implementerer rekursjonen, spesifikt om de tilbyr hale-rekursjon-optimalisering eller ikke.


For hvert funksjonskall, inklusive rekursive funksjonskall, opprettes en stackframe som lagres på kallstacken. Inne i hver stackframe lagres blant annet parameterverdier, lokale variabler(ikke i dette tilfellet) og posisjonen i koden det skal fortsettes fra etter at funksjonen har returnert. I figur \ref{fig:kalltreRmComments} kan man se at måten den rekursive funksjonen i figur \ref{fig:rmComments} kjører på medfører at tilstanden til funksjonen(i dette tilfellet strengen før ::) må lagres. Den må lagres slik at strengen kan bli konkatinert på et senere tidspunkt når rekursjonen trekker seg oppover. I dette tilfellet vil man da få laget 3 stackframes før rekursjonen trekker seg opp igjen, noe som vil medføre ekstra  minnebruk og ekstra operasjoner med å legge til og fjerne frames fra kallstacken. Hale-kall optimalisering vil kunne eliminere de nevnte ulempene ved å transformere enkelte former for rekursjon til vanlig iterasjon. Funksjonen for å fjerne kommentarer er et trivielt eksempel som ikke hadde dratt nevneverdig effekt av en slik optimalisering, men hvis rekursjonen hadde vært svært dyp, hadde antallet stackframes blitt svært høyt, noe som potensielt kunne ha fylt opp kallstacken og i verste tilfelle medført en stack-owerflow exception. Dette er i tillegg til at algoritmen blir mer ressurskrevende å kjøre. I seksjon \ref{sec:hastighetestester} demonstreres slik dyp rekursjon der en funksjon testes med 100 000, 1 million og 100 millioner rekursive funksjonskall, med og uten halekall-optimalisering. 
\\


For at en kompilator skal kunne utføre hale-kall-optimalisering må rekursjonen være implementert på en bestemt måte - det kan kun forekomme ett rekursivt kall som må komme helt til sist og det kan ikke akkumuleres verdier rekursivt. Dette innebærer at det rekursive kallet \textit{ssToStr(noComment) :: rmComments(xs)} i figur \ref{fig:rmComments} ikke oppfyller krav nr. 2 og dermed ikke er halerekursivt. Hvis de to egenskapene er oppfylt vil det ikke være noen grunn til å opprette stackframes, siden det ikke vil være noen grunn til å gå tilbake til tidligere rekursive kall. Rapporten går mer i dybden på denne erkjennelsen senere. Kravet om ett rekursivt kall helt til slutt medfører at algoritmer som naturlig implementeres med multi-rekursjon slik som traversering av trær, må bli skrevet om og vil få ganske annerledes logikk. For mer konvensjonell rekursjon er det ofte enklere å refaktorere koden til å være halerekursiv. \\

\begin{figure}[H]
\caption{Funksjon for å fjerne kommentarer fra kildekode, halerekursiv (Standard ML)}
\label{fig:rmCommentsTailrec}
\begin{minted}{sml}
 fun rmCommentsTailrec(inpLines: string list):string list =
   let fun rmTailRec(inpLines:string list, result:string list) = 
    case inpLines of
      (x::xs) =>
     let 
        val substr = Util.strToSs(x)
        val (noComment, comment) = Substring.splitl (fn c => c <> #"#") substr
      in  
        rmTailRec(xs, Util.ssToStr(noComment) :: result)
      end 
      |[] => rev(result)
    in
      rmTailRec(inpLines,[])
   end

\end{minted}
\end{figure}
Funksjonen i figur \ref{fig:rmCommentsTailrec} er transformert til å være halerekursiv. Den utfører samme oppgaven som i figur \ref{fig:rmComments}, men for at den skal oppfylle kravene for halerekursivitet er den blitt refaktorert til å benytte en indre funksjon og et akkumulator-parameter i stedet for å akkumulere rekursivt. Den nye implementeringen medførte også et par andre små endringer slik som reversering av listen når den returneres, men totalt sett var endringen relativt triviell. At refaktoreringen var lite krevende er ikke alltid tilfellet. Eksempelvis benytter den halerekursive varianten av funksjonen for å beregne det n-te Fibonacci tallet en helt annerledes algoritme enn varianten med ordinær rekursjon.

Siden det rekursive kallet er det siste og eneste som blir utført i en halerekursiv funksjon, trenger ikke lokale variabler eller posisjon for returnering å bli lagret.  Fordi rekursjonen aldri kommer til å trekke seg opp igjen, men kun kalle seg selv med endrede parameterverdier vil det som nevnt tidligere ikke være noen grunn for at rekursjonen skal måtte gå {\qq}tilbake{\qq}. På grunnlag av denne kunnskapen kan kompilatoren optimalisere bak kulissene slik at nye stackframes ikke opprettes, men heller at én gjenbrukes. Rekursjonen blir omgjort til normal iterasjon, med de hastighetsforbedringene dette medfører. Hvis man har en kompilator som genererer Assembly vil hale-rekursjonen kunne bli konvertert til å bruke goto og mutering av registre, noe som vil gi svært god ytelse. Uoptimalisert rekursjon i Assembly innebærer at  stackframes må dyttes av og på stacken i tillegg til at parameterne må kopieres(hvis man har pass-by-value slik som i Standard ML) for hvert enkelt funksjonskall. Flere operasjoner medfører mer jobb for CPU-en og dermed lavere ytelse. Flere stackframes medfører også større minnebruk. Standard ML er et språk der de mest populære kompilatorene har halekall-optimalisering, noe man vil kunne se tydelig utsalg for i hastighetstester.


\subsubsection{Hastighetstester}
\label{sec:hastighetestester}
For å teste forskjeller i effektivitet mellom ordinær rekursjon og halerekursjon benyttes en funksjon for å summere elementene i en liste.
\label{fig:sumSML}
\begin{figure}[H]
\caption{Sum av elementene i en liste, ordinær rekursjon (Standard ML)}
\begin{minted}{sml}
fun sum [] = 0
   |sum(x::xs) = x + sum(xs)
\end{minted}

\end{figure}
\textit{Funksjonen legger rekursivt sammen verdien til første element(x) pluss summen til resten av lista(xs). Dersom lista er tom er summen 0.}

\begin{figure}[H]
\caption{Sum av elementene i en liste, halerekursiv (Standard ML)}
\begin{minted}{sml}
fun sumTail(li) = 
let fun sumFrom([], summed) = summed
	   |sumFrom(x::xs, summed) = sumFrom(xs,summed + x)
in
	sumFrom(li, 0)
end
\end{minted}
\end{figure}
\textit{Funksjonen funger nesten som den med ordinær rekursjon, men benytter en indre funksjon og en akkumulator-variabel for summen.}
\begin{figure}[H]
\caption{Oversikt over resultater ved kjøring av sum og sumTail}
\begin{center}
\begin{tabular}{|r | r| r| r|}
\hline
\rowcolor{lightGray} Funksjon & Ordninær rekursjon & Hale-rekursjon & Forbedring \\
\hline
sum: 100 000 & 16.6 msek & 13.3 msek & 24.8\% \\
\hline
sum: 1 million & 30.3 msek & 21.6 msek & 40\% \\
\hline
sum: 100 millioner & 182 msek & 3336 msek & 1732\% \\
\hline 
\end{tabular}
\end{center}
\end{figure}
Vi ser av resultatene ovenfor at hale-rekursjon-optimalisering gir betydelige forbedringer med tanke på effektivitet, spesielt når problemstørrelsen øker.

\subsection*{Oppsummering}
I databasen blir rekursjon benyttet hyppig. Dette har flere positive effekter - blant annet kode som er mer konsis og kompakt og i mange tilfeller som også kan oppleves som mer lesbar. Det er forbundet en viss lærigskurve med den rekursive stilen, men etter å ha blitt komfortabel med teknikken føles rekursjon i mange tilfeller mer naturlig. Noen av årsaken til dette kan være at man ender opp med kode på et høyere nivå som også er mer deklarativ. Andre årsaker kan være at man deler opp problemet i stadig mindre biter og ender opp med å løse problemet når det er svært enkelt(typisk for algoritmer slik som mergesort). Å dele opp et problem i mindre deler er en svært kjent taktikk i dagliglivet(tenk f.eks. matlaging) og dette kan være ett av elementene som gjør rekursjon intuitivt for visse problemer. Til slutt skal det også legges til at selv om rekursjon i mange tilfeller vil gi store fordeler, vil en rekursiv løsning på et problem alltid kunne skrives imperativt ved å bruke løkker. Dette kan eksemplifiseres med at alle programmer skrevet i et funksjonelt programmeringsspråk til slutt vil ende opp som maskinkode kjørende på den grunnleggende imperative CPU-en. \\ \\

\section{Abstraksjon, organisering og gjenbruk av kode}
Når programstørrelsen øker og kompleksiteten til programmet vokser, blir det stadig viktigere å organisere koden på en hensiktsmessig måte. Det vil også være avgjørende å bruke hensiktsmessige abstraksjoner for å lage kode som enkelt kan gjenbrukes og tilpasses nye krav. Objektorientert programmering innehar flere mekanismer for å oppnå nettopp dette og disse egenskapene kan muligens tillegges noe av grunnen til paradigmets store suksess. På tross av at funksjonell programmering er grunnleggende annerledes fra objektorientert, kan man likevel få mange av de samme gode egenskapene i dette paradigmet. Denne delen skal se på mekanismer og teknikker for å organisere kode og hvordan man kan få abstrakt og gjenbrukbar kode i det funksjonelle paradigmet og samtidig trekke paralleller til objektorientert programmering.

\subsection{Abstraksjon med first-class-functions}
I funksjonell programmering har funksjoner en viktig og spesiell plass - noe navnet antyder. I funksjonell programmering sidestilles nemlig funksjoner med de andre datatypene slik som tall og strenger, og kan dermed brukes på de samme stedene. Sagt på en annen måte regnes funksjoner som hvilken som helst annen datatype og ikke en spesiell, annenrangs type slik tilfellet er i en del imperative språk. Dette medfører at funksjoner kan bli lagret i datastrukturer som f.eks. lister, at de kan bli sendt som argumenter, at en funksjon kan returnere en annen funksjon, og at en funksjon kan bli definert inne i en annen funksjon. Dette er en kraftfull mekanisme som lar deg skrive mer abstrakt og gjenbrukbar kode.

\subsection{Currying for spesialiserte funksjoner basert på abstrakte}
\subsection{Organisering av kode med strukturer, signaturer og funktorer}
Standard ML inkluderer et sett med mekanikker for å organisere kode og skape abstraksjon. I SML kalles de \textit{structure}, \textit{signature} og \textit{functor}.


Strukturer går ut på å pakke ett sett med deklareringer sammen. Deklareringer kan være konstanter, funksjoner, datatyper, typealiaser, exceptions, strukturer, funktorer eller signaturer. Alene fungerer en struktur litt som et namespace ved at man må referere til en bestemt struktur når man vil benytte seg av et av elementene inne i strukturen. Dette sørger for at man unngår navnekollisjoner. Man kan også se likheter mellom klasser og strukturer, med den distinkte forskjellen er at i den funksjonelle stilen skal man unngå mutering. Funksjonene i en struktur er heller ikke knyttet til noen bestemt instans av data, og er avhengig av at dataen sendes inn for hvert funksjonskall. Skal man emulere konseptet med å kalle funksjoner på en "instans" kan closures benyttes. De nevnte egenskapene til strukturen gjør at den likner mer på en klasse med bare konstant-felter og der alle metoder er statiske. At man unngår mutering i en struktur har den effekten at den i større grad blir en statisk, isolert og flyttbar enhet. Man trenger ikke å tenke på at strukturen kan endres fra utsiden eller at den er avhengig av endringer på utsiden for å fungere, siden strukturens tilstand aldri vil kunne endres. Feilsøking og forståelse av kildekoden vil derfor kunne bli enklere. De nevnte egenskapene vil i tillegg gjøre testing(spesielt unit-testing) enklere siden en struktur kan testes isolert.

En signatur fungerer som en kontrakt og beskriver typene til deklareringene en struktur må ha, men ikke selve implementeringen. At implementeringen ikke er med gjør signaturen abstrakt. Signaturer kan derfor sammenliknes med grensesnitt i f.eks. Java, men har et noe annerledes bruksområde. En annen måte å se en signatur på er at de representerer typen til en struktur. En struktur kan implementere en signatur og må i det tilfellet følge kontrakten definert i signaturen. I SML finnes det to måter en signatur kan implementeres på. Hvis signaturen implementeres på en gjennomsiktig måte vil signaturen utelukkende fungere som en kontrakt og alle typer og funksjoner definert utenom kontrakten vil være synlige. Dette reduserer abstraksjonen og vil kanskje også åpne opp for integritetsøledeggende operasjoner. Eksempelvis vil en struktur og en signatur for en kø, implementert gjennomsiktig kunne gjøre det tydelig hvilken datastruktur køen er implementert med og siden man har tilgang til denne underliggende strukturen, vil man også kunne ødelegge integriteten, f.eks. ved å hente ut et element fra slutten av køen. En annen ulempe er at siden man har tilgang til den underliggende datastrukturen, vil man også kunne utføre likhetstester. Denne likhetstesten vil fungere på normal måte, noe som i noen tilfeller ikke er intensjonen med strukturen. I en struktur for en samling uordnede elementer vil man f.eks. ikke at [1,2] og [2,1] skal bli sett på som to ulike strukturer. Den ugjennomsiktige måten å implementere en signatur på vil gjøre den underliggende datatypen abstrakt slik at den ikke kan benyttes utenfor strukturen og dermed heller ikke i likhetstester eller i integritetsøledeggende operasjoner. Den andre effekten man oppnår er at deklarasjoner som ikke er definert i signaturen vil bli skjult fra utsiden, noe som vil gi effekter tilsvarende innkapsulering ved bruk av f.eks. \textit{private} i Java. Strukturer og signaturer kan lages fullstendig uten mutering og er derfor funksjonelle i natur. I SML er signaturer kanskje mest nyttige når de blir brukt i forbindelse med funktorer som vil bli diskutert senere.

Databasen bruker en funksjonell map(aka assosiativ liste) basert på et binærtre for å lagre informasjon om de ulike kolonnene med data som leses inn når en spørring utføres. Det brukes en map til å holde på meta-informasjon slik som kolonnenavn, type og standardverdi definert i metadatafilen og en annen til å holde på selve dataen definert i datafilen. Det er ønskelig at mapen har funksjoner for å sette inn og hente hente ut en verdi assosiert med en bestemt nøkkel. Dette er operasjoner som er ønskelig at alle maper skal ha, og funksjons-signaturene for dette er derfor definert i signaturen i figur \ref{fig:sigMap}.

Siden mapen er i den funksjonelle stilen vil den ikke kunne muteres. Dermed vil man ikke kunne ta i mot en map, endre den og deretter returnere den slik tilfellet ofte er i imperativ programmering. I stedet vil man ta imot en map og opprette en ny basert på den som ble sendt inn. Det er da den nye mapen som blir returnert. Dette vil ha den positive effekten at man ikke trenger å bekymre seg for om data sendt inn til en funksjon kommer til å bli endret av funksjonen. Dette faktumet fører til at designet av mapen vil bli grunnleggende annerledes enn tilfellet hadde vært i det objektorienterte paradigmet.

Mapen skal støtte nøkler av ulik typer data, også de typene som er av mer kompleks form. Siden mapen egentlig er et binært tre er man avhengig av å kunne finne rekkefølgen på elementene. Dette er for å kunne bestemme plasseringen i treet og senere for å kunne finne frem til en bestemt nøkkel. Med strukturer og signaturer ville løsningen blitt en implementering for hver av typene man ønsker å ha som nøkkel. Selv om strukturer og signaturer tilbyr innkapsulering og abstraksjon, bidrar de lite til å lage  kode som er gjenbrukbar. Ønsker man å implementere 4 nye typer nøkler må man lage 4 strukturer. Enda verre er det hvis man har flere ulike map-implementeringer som alle bruker rekkefølgen til elementene for å sette inn og hente ut elementene. Eksempelvis kan man ha en liste som bruker binærsøk i tillegg. I dette tilfellet hadde antall implementeringer blitt enormt mange. Løsningen med kun signaturer og strukturer skaper i slike tilfeller store mengder duplisert kode og vil være krevende å vedlikeholde.

Funktoren i SML lar deg unngå de nevnte problemene. Den fungerer som en slags funksjon som tar imot en eller flere strukturer av en bestemt type(som oppfyller en bestemt signatur) og som produserer en ny struktur som resultat. For map-implementeringen vil man kunne ønske å lage en funktor for hver enkelt implementering av map, som tar imot en struktur for datatypen som skal brukes som nøkkel. Strukturen som blir tatt imot kan da være av type ORDERED\_TYPE. Denne signaturen finnes i figur \ref{fig:sigOrdered}. To strukturer som implementerer denne signaturen finnes i figur \ref{fig:structOrdered}. Strukturen som sendes inn kan inneholde en funksjon for å bestemme rekkefølgen til to elementer av den aktuelle typen i tillegg til å inneholde selve data-typen. Funktoren til treeMap, i figur \ref{fig:funktorTreeMap} er laget på denne måten. Ved at type element og dets sortering ikke er hardkodet, men heller er abstrahert vekk vil funktoren kunne gjenbrukes med flere ulike datatyper, noe man ser eksempel på i figur \ref{fig:maps}. Når man kaller på funktoren vil en ny struktur tilpasset en bestemt type opprettes. Gjenbruksfaktoren økes også ved at strukturene til datatypene vil kunne bli delt på tvers av ulike implementeringer av map dersom alle tar imot en struktur av samme type.

\begin{figure}[H]
\caption{Signatur for en map (Standard ML)}
\label{fig:sigMap}
\begin{minted}{sml}
signature MAP = 
sig
  type 'a MapTree
  type keyType
  val insert: ('a MapTree*keyType*'a)-> 'a MapTree
  val get: ('a MapTree*keyType) -> 'a option
  val empty:(unit) -> 'a MapTree
end;

\end{minted}
\end{figure}

\begin{figure}[H]
\caption{Funktor for treeMap (Standard ML)}
\label{fig:funktorTreeMap}
\begin{minted}{sml}
functor MapTreeOfType (ordered:ORDERED_TYPE):MAP =  
struct 
  type keyType = ordered.t

  datatype 'a MapTree = 
    (*Key*value*left*right*)
    Node of keyType * 'a * 'a MapTree * 'a MapTree |
    EmptyNode
  
  (*Creates a empty map. The map does not yet have a value-type associated. This is set upon the     first insert*)
  fun empty() = EmptyNode

  (*Inserts a value into the given map. If the key already exists, no value is
  inserted*)
  fun insert(mt:'a MapTree, key:keyType, value: 'a):'a MapTree =
    case mt of
      EmptyNode     => Node(key,value,EmptyNode,EmptyNode) 
     |Node(k,v,l,r) => case ordered.compare(k,key) of
                         EQUAL   => mt (*The key already exists- the original tree is returned*)
                        |LESS    => Node(k,v,insert(l,key,value),r)
                        |GREATER => Node(k,v,l,insert(r,key,value))

  (*Retrieves the value associated with the given key. The result is wrapped in
   an option*)
  fun get(mt: 'a MapTree, key:keyType):'a option =
    case mt of 
      EmptyNode     => NONE 
     |Node(k,v,l,r) => case ordered.compare(k,key) of
                         EQUAL   => SOME(v)
                        |LESS    => get(l,key)
                        |GREATER => get(r,key)
end;

\end{minted}
\end{figure}

\begin{figure}[H]
\caption{Strukturer av type ORDERED\_TYPE for streng og tall med rekkefølge-funksjon (Standard ML)}
\label{fig:structOrdered}
\begin{minted}{sml}
structure orderedInt:ORDERED_TYPE = 
struct 
  type  t = int

  fun compare(i1,i2) = 
    if i1 < i2 then LESS 
    else if i1 > i2 then GREATER 
    else EQUAL
end;

structure orderedString:ORDERED_TYPE = 
struct
  type t = string
  fun compare(s1,s2) = 
    String.compare(s1,s2)
end;
\end{minted}
\end{figure}

\begin{figure}[H]
\caption{Signatur for en type med rekkefølge-støtte (Standard ML)}
\label{fig:sigOrdered}
\begin{minted}{sml}
signature ORDERED_TYPE= 
sig
  type t
  val compare: (t*t) -> General.order
end;

\end{minted}
\end{figure}

\begin{figure}[H]
\caption{Strukturer for tree-baserte maper for int og streng. En funktor brukes for å lage strukturene. (Standard ML)}
\label{fig:maps}
\begin{minted}{sml}
structure MapInt = MapTreeOfType(orderedInt)
structure MapString = MapTreeOfType(orderedString)
\end{minted}
\end{figure}
\chapter*{Bibiografi}
\addcontentsline{toc}{chapter}{\protect\numberline{}Bibiografi}%
\printbibliography[heading=none]
\end{document}
